<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tinylaker blog</title>
  
  <subtitle>stay hungry stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tinylaker.github.io/"/>
  <updated>2019-11-12T12:31:54.656Z</updated>
  <id>http://tinylaker.github.io/</id>
  
  <author>
    <name>tinylaker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android GUI框架简介</title>
    <link href="http://tinylaker.github.io/2019/11/11/Android-GUI%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
    <id>http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/</id>
    <published>2019-11-11T02:28:05.000Z</published>
    <updated>2019-11-12T12:31:54.656Z</updated>
    
    <content type="html"><![CDATA[<p>在谈及 Android GUI 框架前，先从底层视角梳理一下显示的流程。在 Android 系统中，引入了状态栏、导航栏、壁纸和背景的图层概念，需要把这些图层进行 alpha blending 后显示。</p><p>在嵌入式 linux 系统下显示界面，可以直接操作 framebuffer 的内存；但 Android 应用并不能直接操作 framebuffer，应用需要借助 SurfaceFlinger。</p><p>SurfaceFlinger 通过 Gralloc HAL 向 ashmem 申请内存，供应用使用。同时使用 OpenGL 和 HardwareComposer 来合成 Surface。</p><h1 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h1><p>可以把应用理解为客户端，SurfaceFlinger 理解为服务端，在 SurfaceFlinger 中用 Client 对象表示应用，有多少个应用就有多少个 Client 对象。</p><p>Client 对象中包含了 Layer 对象，用来对应应用层的 SurfaceControl ；其中 Layer 对象包含生产者和消费者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceFlingerConsumer&gt; mSurfaceFlingerConsumer;</span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; mProducer;</span><br></pre></td></tr></table></figure><p>在 mProducer 与 mSurfaceFlingerConsumer 存在同一个 mCore（类型为：BufferQueueCore），BufferQueueCore 中有以下的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueDefs::SlotsType mSlots;</span><br></pre></td></tr></table></figure><p>BufferQueueDefs::SlotsType 定义在 BufferQueueDefs.h 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace BufferQueueDefs &#123;</span><br><span class="line">    // BufferQueue will keep track of at most this value of buffers.</span><br><span class="line">    // Attempts at runtime to increase the number of buffers past this</span><br><span class="line">    // will fail.</span><br><span class="line">    enum &#123; NUM_BUFFER_SLOTS = 64 &#125;;</span><br><span class="line"></span><br><span class="line">    typedef BufferSlot SlotsType[NUM_BUFFER_SLOTS];</span><br><span class="line">&#125; // namespace BufferQueueDefs</span><br></pre></td></tr></table></figure><p>所以 mSlots 是拥有64个 BufferSlot 的数组，表示一个 Surface 中最多可以存在64个 buffer。</p><p>BufferSlot 结构中有下面的定义，用来表示实际的 buffer 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br></pre></td></tr></table></figure><p>通过系统的测试用例 resize 了解应用的基本流程，追踪代码分析 SurfaceFlinger 的工作方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/tests/resize/resize.cpp</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    // set up the thread-pool</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    // create a client to surfaceflinger</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient(); //&lt;1&gt;</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;createSurface(String8(&quot;resize&quot;), 160, 240, PIXEL_FORMAT_RGB_565, 0);    //&lt;2&gt;</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;getSurface(); //&lt;3&gt;</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    surfaceControl-&gt;setLayer(100000);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    surface-&gt;lock(&amp;outBuffer, NULL);    //&lt;4&gt;</span><br><span class="line">    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    android_memset16((uint16_t*)outBuffer.bits, 0xF800, bpr*outBuffer.height);</span><br><span class="line">    surface-&gt;unlockAndPost();   &lt;5&gt;</span><br><span class="line"></span><br><span class="line">    surface-&gt;lock(&amp;outBuffer);</span><br><span class="line">    android_memset16((uint16_t*)outBuffer.bits, 0x07E0, bpr*outBuffer.height);</span><br><span class="line">    surface-&gt;unlockAndPost();</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    surfaceControl-&gt;setSize(320, 240);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的流程图如下：</p><p><img src="//tinylaker.github.io/2019/11/11/Android-GUI框架简介/surface.png" alt="SurfaceFlinger"></p><h2 id="sp-lt-SurfaceComposerClient-gt-client-new-SurfaceComposerClient"><a href="#sp-lt-SurfaceComposerClient-gt-client-new-SurfaceComposerClient" class="headerlink" title="sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient()"></a>sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient()</h2><p>当应用程序需要请求 SurfaceFlinger 服务时，首先需要构造 SurfaceComposerClient 对象，通过 SurfaceComposerClient 对象访问 SurfaceFlinger 服务。</p><p>SurfaceComposerClient 有两个重要的成员变量，一个是 Composer，该对象采用单例模式创建；另一个是 <strong>ISurfaceComposerClient</strong> 。</p><p>一个 <strong>ISurfaceComposerClient</strong> 接口对应本地实现类 <strong>BnSurfaceComposerClient</strong> 和代理类 <strong>BpSurfaceComposerClient</strong> ，这里的mClient获取的就是代理类 <strong>BpSurfaceComposerClient</strong> 的对象。</p><p>当应用程序请求连接 SurfaceFlinger ，SurfaceFlinger 会为应用程序创建一个 Client 对象，并返回代理对象 <strong>BpSurfaceComposerClient</strong> 给应用程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/include/gui/SurfaceComposerClient.h</span><br><span class="line"></span><br><span class="line">class SurfaceComposerClient : public RefBase</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    virtual void onFirstRef();</span><br><span class="line">    Composer&amp; getComposer();</span><br><span class="line"></span><br><span class="line">    mutable     Mutex                       mLock;</span><br><span class="line">                status_t                    mStatus;</span><br><span class="line">                sp&lt;ISurfaceComposerClient&gt;  mClient;</span><br><span class="line">                Composer&amp;                   mComposer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 SurfaceComposerClient 继承于 RefBase 类，在创建 SurfaceComposerClient 对象后，第一次引用对象时，调用 onFirstRef() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">    : mStatus(NO_INIT), mComposer(Composer::getInstance())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line">    //获取 BpSurfaceComposer 的实例化对象</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());</span><br><span class="line">    if (sm != 0) &#123;</span><br><span class="line">        //获取 BpSurfaceComposerClient 实例化对象</span><br><span class="line">        sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">        if (conn != 0) &#123;</span><br><span class="line">            mClient = conn;</span><br><span class="line">            mStatus = NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onFirstRef() 方法首先调用 ComposerService 类的 getComposerService() 方法获取 SurfaceFlinger 的代理对象 BpSurfaceComposer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">/*static*/ sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();</span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    if (instance.mComposerService == NULL) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != NULL);</span><br><span class="line">        ALOGD(&quot;ComposerService reconnected&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance.mComposerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过单例模式调用 getInstance() 方法构造 ComposerService 对象，期间会调用 connectLocked() 方法获取 BpServiceComposerClient 服务的代理对象 ，并保存到成员变量 mComposerService 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">ANDROID_SINGLETON_STATIC_INSTANCE(ComposerService);</span><br><span class="line"></span><br><span class="line">ComposerService::ComposerService()</span><br><span class="line">: Singleton&lt;ComposerService&gt;() &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    connectLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ComposerService::connectLocked() &#123;</span><br><span class="line">    const String16 name(&quot;SurfaceFlinger&quot;);</span><br><span class="line">    while (getService(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        usleep(250000);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(mComposerService != NULL);</span><br><span class="line"></span><br><span class="line">    // Create the death listener.</span><br><span class="line">    class DeathObserver : public IBinder::DeathRecipient &#123;</span><br><span class="line">        ComposerService&amp; mComposerService;</span><br><span class="line">        virtual void binderDied(const wp&lt;IBinder&gt;&amp; who) &#123;</span><br><span class="line">            ALOGW(&quot;ComposerService remote (surfaceflinger) died [%p]&quot;,</span><br><span class="line">                  who.unsafe_get());</span><br><span class="line">            mComposerService.composerServiceDied();</span><br><span class="line">        &#125;</span><br><span class="line">     public:</span><br><span class="line">        DeathObserver(ComposerService&amp; mgr) : mComposerService(mgr) &#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mDeathObserver = new DeathObserver(*const_cast&lt;ComposerService*&gt;(this));</span><br><span class="line">    mComposerService-&gt;asBinder()-&gt;linkToDeath(mDeathObserver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经获取到 BpSurfaceComposer 对象，调用它的 createConnection() 方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="line"></span><br><span class="line">class BpSurfaceComposer : public BpInterface&lt;ISurfaceComposer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BpSurfaceComposer(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;ISurfaceComposer&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">virtual sp&lt;ISurfaceComposerClient&gt; createConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        uint32_t n;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(BnSurfaceComposer::CREATE_CONNECTION, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;ISurfaceComposerClient&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createConnection() 方法中调用 <code>remote()-&gt;transact</code> 会导致 SurfaceFlinger 类的onTransact()方法被调用，进而调用 BnSurfaceComposer::onTransact() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case CREATE_CONNECTION:</span><br><span class="line">        case CREATE_DISPLAY:</span><br><span class="line">        case SET_TRANSACTION_STATE:</span><br><span class="line">        case BOOT_FINISHED:</span><br><span class="line">        case BLANK:</span><br><span class="line">        case UNBLANK:</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = BnSurfaceComposer::onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="line"></span><br><span class="line">status_t BnSurfaceComposer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_CONNECTION: &#123;</span><br><span class="line">            CHECK_INTERFACE(ISurfaceComposer, data, reply);</span><br><span class="line">            sp&lt;IBinder&gt; b = createConnection()-&gt;asBinder();</span><br><span class="line">            reply-&gt;writeStrongBinder(b);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        default: &#123;</span><br><span class="line">            return BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger 继承 BnSurfaceComposer，重新实现 createConnection()方法，该方法会构造 Client 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.h</span><br><span class="line"></span><br><span class="line">class SurfaceFlinger : public BnSurfaceComposer,</span><br><span class="line">                        private IBinder::DeathRecipient,</span><br><span class="line">                        private HWComposer::EventHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/include/gui/ISurfaceComposer.h</span><br><span class="line"></span><br><span class="line">class BnSurfaceComposer: public BnInterface&lt;ISurfaceComposer&gt;                        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line">    sp&lt;Client&gt; client(new Client(this));</span><br><span class="line">    status_t err = client-&gt;initCheck();</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        bclient = client;</span><br><span class="line">    &#125;</span><br><span class="line">    return bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 Binder 机制返回 BpSurfaceComposerClient 代理对象，将其保存在 SurfaceComposerClient::mClient 成员中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp\&lt;IBinder&gt; b = IInterface::asBinder(createConnection());</span><br><span class="line"></span><br><span class="line">reply-&gt;writeStrongBinder(b);</span><br><span class="line"></span><br><span class="line">interface_cast&lt;ISurfaceComposerClient&gt;(reply.readStrongBinder());</span><br></pre></td></tr></table></figure><p>总结：应用程序创建 SurfaceFlinger Client，需要首先获取 SurfaceFlinger 服务，通过 SurfaceFlinger::createConnection() 方法建立应用程序和 SurfaceFlinger 的连接。SurfaceFlinger 会创建一个 BnSurfaceComposerClient 本地对象，同时应用程序会得到一个 BpSurfaceComposerClient 代理类对象，后面会通过这个代理类对象创建 Surface。</p><h2 id="sp-lt-SurfaceControl-gt-surfaceControl-client-gt-createSurface"><a href="#sp-lt-SurfaceControl-gt-surfaceControl-client-gt-createSurface" class="headerlink" title="sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;createSurface()"></a>sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;createSurface()</h2><p>根据 SurfaceComposerClient 对象创建 SurfafeControl 对象，其实就是调用 SurfaceFlinger 创建 Layer，下面分析代码</p><p>SurfaceComposerClient::mClient 即上面流程中保存的 BpSurfaceComposerClient ，所以实际调用的是 BpSurfaceComposerClient::createSurface() 方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        uint32_t w,</span><br><span class="line">        uint32_t h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    if (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">        status_t err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">                &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, &quot;SurfaceComposerClient::createSurface error %s&quot;, strerror(-err));</span><br><span class="line">        if (err == NO_ERROR) &#123;</span><br><span class="line">            sur = new SurfaceControl(this, handle, gbp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remote()-&gt;transact</code> 根据 Binder 机制，调用 BnSurfaceComposerClient::onTransact() 本地方法，进而调用到 Client::createSurface() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ISurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">class BpSurfaceComposerClient : public BpInterface&lt;ISurfaceComposerClient&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    virtual status_t createSurface(const String8&amp; name, uint32_t w,</span><br><span class="line">                uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp) &#123;</span><br><span class="line">          Parcel data, reply;</span><br><span class="line">          data.writeInterfaceToken(ISurfaceComposerClient::getInterfaceDescriptor());</span><br><span class="line">          data.writeString8(name);</span><br><span class="line">          data.writeInt32(w);</span><br><span class="line">          data.writeInt32(h);</span><br><span class="line">          data.writeInt32(format);</span><br><span class="line">          data.writeInt32(flags);</span><br><span class="line">          remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">          *handle = reply.readStrongBinder();</span><br><span class="line">          *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">          return reply.readInt32();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BnSurfaceComposerClient::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_SURFACE: &#123;</span><br><span class="line">            CHECK_INTERFACE(ISurfaceComposerClient, data, reply);</span><br><span class="line">            String8 name = data.readString8();</span><br><span class="line">            uint32_t w = data.readInt32();</span><br><span class="line">            uint32_t h = data.readInt32();</span><br><span class="line">            PixelFormat format = data.readInt32();</span><br><span class="line">            uint32_t flags = data.readInt32();</span><br><span class="line">            sp&lt;IBinder&gt; handle;</span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">            status_t result = createSurface(name, w, h, format, flags,</span><br><span class="line">                    &amp;handle, &amp;gbp);</span><br><span class="line">            reply-&gt;writeStrongBinder(handle);</span><br><span class="line">            reply-&gt;writeStrongBinder(gbp-&gt;asBinder());</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createSurface() 方法定义了一个消息类 MessageCreateLayer ，然后把它的对象通过 postMessageSync() 方法发送出去，这个消息是以同步的方式发送，因此函数结束后可以直接返回结果。所以会调用到消息处理方法 handler()，直接调用 SurfaceFlinger::createLayer() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"></span><br><span class="line">status_t Client::createSurface(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    class MessageCreateLayer : public MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        status_t result;</span><br><span class="line">        const String8&amp; name;</span><br><span class="line">        uint32_t w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">    public:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                const String8&amp; name, Client* client,</span><br><span class="line">                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">            handle(handle), gbp(gbp),</span><br><span class="line">            name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        status_t getResult() const &#123; return result; &#125;</span><br><span class="line">        virtual bool handler() &#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, this, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createLayer() 方法根据 flags 参数选择创建不同类型的 Layer ( NormalLayer 和 DimLayer )，这里以 createNormalLayer 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::createLayer(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    //ALOGD(&quot;createLayer for (%d x %d), name=%s&quot;, w, h, name.string());</span><br><span class="line">    if (int32_t(w|h) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;createLayer() failed, w or h is negative (w=%d, h=%d)&quot;,</span><br><span class="line">                int(w), int(h));</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line"></span><br><span class="line">    switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceNoDisp:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            break;</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result == NO_ERROR) &#123;</span><br><span class="line">        addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">        if(!(flags &amp; ISurfaceComposerClient::eFXSurfaceNoDisp)) &#123;</span><br><span class="line">            setTransactionFlags(eTransactionNeeded);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ALOGD(&quot;%s flags=%x&quot;, __FUNCTION__, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createNormalLayer() 方法根据 format 参数不同创建 Layer 对象 outLayer ，调用 Layer::getHandle() 方法赋值给 handle，调用 Layer::getBufferQueue() 方法赋值给 gbp 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span><br><span class="line">&#123;</span><br><span class="line">    // initialize the surfaces</span><br><span class="line">    switch (format) &#123;</span><br><span class="line">    case PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    case PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">        break;</span><br><span class="line">    case PIXEL_FORMAT_OPAQUE:</span><br><span class="line">#ifdef NO_RGBX_8888</span><br><span class="line">        format = PIXEL_FORMAT_RGB_565;</span><br><span class="line">#else</span><br><span class="line">        format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">#endif</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef NO_RGBX_8888</span><br><span class="line">    if (format == PIXEL_FORMAT_RGBX_8888)</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    *outLayer = new Layer(this, client, name, w, h, flags);</span><br><span class="line">    status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">        *gbp = (*outLayer)-&gt;getBufferQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE_IF(err, &quot;createNormalLayer() failed (%s)&quot;, strerror(-err));</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下 Layer 类的构造方法和 onFirstRef() 方法的实现，这里会构造图像缓冲区队列 mBufferQueue ，同时创建消费者对象 mSurfaceFlingerConsumer </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Layer::Layer(SurfaceFlinger* flinger, const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags)</span><br><span class="line">    :   contentDirty(false),</span><br><span class="line">        sequence(uint32_t(android_atomic_inc(&amp;sSequence))),</span><br><span class="line">        mFlinger(flinger),</span><br><span class="line">        mTextureName(-1U),</span><br><span class="line">        mPremultipliedAlpha(true),</span><br><span class="line">        mName(&quot;unnamed&quot;),</span><br><span class="line">        mDebug(false),</span><br><span class="line">        mFormat(PIXEL_FORMAT_NONE),</span><br><span class="line">        mOpaqueLayer(true),</span><br><span class="line">        mTransactionFlags(0),</span><br><span class="line">        mQueuedFrames(0),</span><br><span class="line">        mCurrentTransform(0),</span><br><span class="line">        mCurrentScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),</span><br><span class="line">        mCurrentOpacity(true),</span><br><span class="line">        mRefreshPending(false),</span><br><span class="line">        mFrameLatencyNeeded(false),</span><br><span class="line">        mFiltering(false),</span><br><span class="line">        mNeedsFiltering(false),</span><br><span class="line">        mMesh(Mesh::TRIANGLE_FAN, 4, 2, 2),</span><br><span class="line">        mSecure(false),</span><br><span class="line">        mProtectedByApp(false),</span><br><span class="line">        mHasSurface(false),</span><br><span class="line">        mClientRef(client),</span><br><span class="line">        mCaptureScreen(false)</span><br><span class="line">&#123;</span><br><span class="line">    mCurrentCrop.makeInvalid();</span><br><span class="line">    mFlinger-&gt;getRenderEngine().genTextures(1, &amp;mTextureName);</span><br><span class="line">    mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line"></span><br><span class="line">    uint32_t layerFlags = 0;</span><br><span class="line">    if (flags &amp; ISurfaceComposerClient::eHidden)</span><br><span class="line">        layerFlags = layer_state_t::eLayerHidden;</span><br><span class="line"></span><br><span class="line">    if (flags &amp; ISurfaceComposerClient::eNonPremultiplied)</span><br><span class="line">        mPremultipliedAlpha = false;</span><br><span class="line"></span><br><span class="line">    mName = name;</span><br><span class="line"></span><br><span class="line">    mCurrentState.active.w = w;</span><br><span class="line">    mCurrentState.active.h = h;</span><br><span class="line">    mCurrentState.active.crop.makeInvalid();</span><br><span class="line">    mCurrentState.z = 0;</span><br><span class="line">    mCurrentState.alpha = 0xFF;</span><br><span class="line">    mCurrentState.layerStack = 0;</span><br><span class="line">    mCurrentState.flags = layerFlags;</span><br><span class="line">    mCurrentState.sequence = 0;</span><br><span class="line">    mCurrentState.transform.set(0, 0);</span><br><span class="line">    mCurrentState.requested = mCurrentState.active;</span><br><span class="line"></span><br><span class="line">    // drawing state &amp; current state are identical</span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    nsecs_t displayPeriod =</span><br><span class="line">            flinger-&gt;getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    mFrameTracker.setDisplayRefreshPeriod(displayPeriod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Layer::onFirstRef() &#123;</span><br><span class="line">    // Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span><br><span class="line">    mBufferQueue = new SurfaceTextureLayer(mFlinger);</span><br><span class="line">    mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(mBufferQueue, mTextureName);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setFrameAvailableListener(this);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"></span><br><span class="line">#ifdef TARGET_DISABLE_TRIPLE_BUFFERING</span><br><span class="line">#warning &quot;disabling triple buffering&quot;</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(2);</span><br><span class="line">#else</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(3);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">    updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着调用 addClientLayer() 方法，把 Layer 对象和 SurfaceFlinger 以及应用程序关联起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; gbc,</span><br><span class="line">        const sp&lt;Layer&gt;&amp; lbc)</span><br><span class="line">&#123;</span><br><span class="line">    // attach this layer to the client</span><br><span class="line">    client-&gt;attachLayer(handle, lbc);</span><br><span class="line"></span><br><span class="line">    // add this layer to the current state list</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    mCurrentState.layersSortedByZ.add(lbc);</span><br><span class="line">    mGraphicBufferProducerList.add(gbc-&gt;asBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attachLayer() 将 handle 和 outLayer 添加到 Client::mLayers 成员变量中; SurfaceFlinger 分别使用成员变量 mCurrentState 和 mGraphicBufferProducerList 保存 outLayer 和 gbp 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"></span><br><span class="line">void Client::attachLayer(const sp&lt;IBinder&gt;&amp; handle, const sp&lt;Layer&gt;&amp; layer)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLayers.add(handle, layer);//添加到client的mLayers变量中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面获取的 handle 和 gbp ，构造 SurfaceControl 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceControl.cpp</span><br><span class="line"></span><br><span class="line">SurfaceControl::SurfaceControl(</span><br><span class="line">        const sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">        const sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; gbp)</span><br><span class="line">      : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：通过 SurfaceFlinger 构造 Layer ，然后创建 surfaceControl 对象。该对象有三个参数，第一个参数是 SurfaceComposerClient 代理对象；第二个参数是 handle ，表示 SurfaceControl 的唯一性；第三个参数是 gbp ,表示 Layer 对象中的 GraphicBufferProducer 的生产者代理类对象。</p><h2 id="sp-lt-Surface-gt-surface-surfaceControl-gt-getSurface"><a href="#sp-lt-Surface-gt-surface-surfaceControl-gt-getSurface" class="headerlink" title="sp&lt;Surface&gt; surface = surfaceControl-&gt;getSurface()"></a>sp&lt;Surface&gt; surface = surfaceControl-&gt;getSurface()</h2><p>通过 SurfaceControl 对象的 getSurface() 方法构造 Surface 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceControl.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() const</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    if (mSurfaceData == 0) &#123;</span><br><span class="line">        // This surface is always consumed by SurfaceFlinger, so the</span><br><span class="line">        // producerControlledByApp value doesn&apos;t matter; using false.</span><br><span class="line">        mSurfaceData = new Surface(mGraphicBufferProducer, false);</span><br><span class="line">    &#125;</span><br><span class="line">    return mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 mGraphicBufferProducer 代理类对象构造 Surface 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Surface::Surface(</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,</span><br><span class="line">        bool controlledByApp)</span><br><span class="line">    : mGraphicBufferProducer(bufferProducer)</span><br><span class="line">&#123;</span><br><span class="line">    // Initialize the ANativeWindow function pointers.</span><br><span class="line">    ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">    ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">    ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">    ANativeWindow::query            = hook_query;</span><br><span class="line">    ANativeWindow::perform          = hook_perform;</span><br><span class="line"></span><br><span class="line">    ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line">    const_cast&lt;int&amp;&gt;(ANativeWindow::minSwapInterval) = 0;</span><br><span class="line">    const_cast&lt;int&amp;&gt;(ANativeWindow::maxSwapInterval) = 1;</span><br><span class="line"></span><br><span class="line">    mReqWidth = 0;</span><br><span class="line">    mReqHeight = 0;</span><br><span class="line">    mReqFormat = 0;</span><br><span class="line">    mReqUsage = 0;</span><br><span class="line">    mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;</span><br><span class="line">    mCrop.clear();</span><br><span class="line">    mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;</span><br><span class="line">    mTransform = 0;</span><br><span class="line">    mDefaultWidth = 0;</span><br><span class="line">    mDefaultHeight = 0;</span><br><span class="line">    mUserWidth = 0;</span><br><span class="line">    mUserHeight = 0;</span><br><span class="line">    mTransformHint = 0;</span><br><span class="line">    mConsumerRunningBehind = false;</span><br><span class="line">    mConnectedToCpu = false;</span><br><span class="line">    mProducerControlledByApp = controlledByApp;</span><br><span class="line">    mSwapIntervalZero = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：当应用程序构建 Surface 的时候， SurfaceFlinger 会创建对应的图层 Layer， 并且把 Layer 的图像缓冲区的生产者对象赋值给 Surface 对象的成员变量 mGraphicBufferProducer ，这样应用程序就可以通过这个生产者接口更新数据。</p><p>那么缓冲区的消费者呢，Layer::onFirstRef() 方法中创建 SurfaceFlingerConsumer 对象，该类间接继承于 ConsumerBase 消费者基类，所以 <code>mSurfaceFlingerConsumer-&gt;setFrameAvailableListener(this)</code> 实际等于 <code>ConsumerBase::setFrameAvailableListener(const Layer &amp;)</code> ，注册 Layer 为 Listener。</p><p>当缓冲区数据准备好，BufferQueue 就会调用 onFrameAvailable() 方法通知消费者，这里还涉及到很多 Binder 的流程，我们暂不关心，只看 Layer::onFrameAvailable() 方法的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ConsumerBase.cpp</span><br><span class="line"></span><br><span class="line">void ConsumerBase::setFrameAvailableListener(</span><br><span class="line">        const wp&lt;FrameAvailableListener&gt;&amp; listener) &#123;</span><br><span class="line">    CB_LOGV(&quot;setFrameAvailableListener&quot;);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    mFrameAvailableListener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ConsumerBase::onFrameAvailable() &#123;</span><br><span class="line">    CB_LOGV(&quot;onFrameAvailable&quot;);</span><br><span class="line"></span><br><span class="line">    sp&lt;FrameAvailableListener&gt; listener;</span><br><span class="line">    &#123; // scope for the lock</span><br><span class="line">        Mutex::Autolock lock(mMutex);</span><br><span class="line">        listener = mFrameAvailableListener.promote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (listener != NULL) &#123;</span><br><span class="line">        CB_LOGV(&quot;actually calling onFrameAvailable&quot;);</span><br><span class="line">        listener-&gt;onFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会去调用 SurfaceFlinger::signalLayerUpdate() 方法发送图层更新消息，通过 handleMessageInvalidate() 方法处理消息，调用 handlePageFlip() 把有效缓冲区换到前台，等待 SurfaceFlinger 合成显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Layer.cpp</span><br><span class="line"></span><br><span class="line">void Layer::onFrameAvailable() &#123;</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">    mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::onMessageReceived(int32_t what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    switch (what) &#123;</span><br><span class="line">    case MessageQueue::TRANSACTION:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        break;</span><br><span class="line">    case MessageQueue::INVALIDATE:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        handleMessageInvalidate();</span><br><span class="line">        signalRefresh();</span><br><span class="line">        break;</span><br><span class="line">    case MessageQueue::REFRESH:</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::handleMessageInvalidate() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    handlePageFlip();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::handlePageFlip()</span><br><span class="line">&#123;</span><br><span class="line">    Region dirtyRegion;</span><br><span class="line"></span><br><span class="line">    bool visibleRegions = false;</span><br><span class="line">    const LayerVector&amp; layers(mDrawingState.layersSortedByZ);</span><br><span class="line">    const size_t count = layers.size();</span><br><span class="line">    for (size_t i=0 ; i&lt;count ; i++) &#123;</span><br><span class="line">        const sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">        const Region dirty(layer-&gt;latchBuffer(visibleRegions));</span><br><span class="line">        const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">        invalidateLayerStack(s.layerStack, dirty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="surface-gt-lock-amp-outBuffer-NULL"><a href="#surface-gt-lock-amp-outBuffer-NULL" class="headerlink" title="surface-&gt;lock(&amp;outBuffer, NULL)"></a>surface-&gt;lock(&amp;outBuffer, NULL)</h2><p>这里通过前面代码构建的 Surface，获取图像缓冲区内容，首先调用 Surface::dequeueBuffer() 方法申请 Buffer进行应用层图像绘制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/Surface.cpp</span><br><span class="line"></span><br><span class="line">status_t Surface::lock(</span><br><span class="line">        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">&#123;</span><br><span class="line">    if (!mConnectedToCpu) &#123;</span><br><span class="line">        int err = Surface::connect(NATIVE_WINDOW_API_CPU);</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">        // we&apos;re intending to do software rendering from this point</span><br><span class="line">        setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ANativeWindowBuffer* out;</span><br><span class="line">    int fenceFd = -1;</span><br><span class="line">    status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));</span><br><span class="line">        sp&lt;Fence&gt; fence(new Fence(fenceFd));</span><br><span class="line"></span><br><span class="line">        err = fence-&gt;waitForever(&quot;Surface::lock&quot;);</span><br><span class="line">    </span><br><span class="line">        void* vaddr;</span><br><span class="line">        status_t res = backBuffer-&gt;lock(</span><br><span class="line">                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">                newDirtyRegion.bounds(), &amp;vaddr);     </span><br><span class="line">        </span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLockedBuffer = backBuffer;</span><br><span class="line">            outBuffer-&gt;width  = backBuffer-&gt;width;</span><br><span class="line">            outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">            outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">            outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">            outBuffer-&gt;bits   = vaddr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;</span><br><span class="line">    //申请buffer</span><br><span class="line">    status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, mSwapIntervalZero,</span><br><span class="line">            reqW, reqH, mReqFormat, mReqUsage);</span><br><span class="line"></span><br><span class="line">    //mSlots 在前面有提到，是 Layer 对象中定义的缓冲队列，这里获取队列中的第 buf 项</span><br><span class="line">    sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line"></span><br><span class="line">    if (result &amp; IGraphicBufferProducer::RELEASE_ALL_BUFFERS) &#123;</span><br><span class="line">        freeAllBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == 0) &#123;</span><br><span class="line">        // 因为前面的内存是在 SurfaceFlinger 进程中申请的，这里将内存映射到当前 Surface 所在进程</span><br><span class="line">        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    //返回内存对象的指针</span><br><span class="line">    *buffer = gbuf.get();</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mGraphicBufferProducer-&gt;dequeueBuffer()</code> 进而会去调用 <code>BpGraphicBufferProducer::dequeueBuffer()</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class BpGraphicBufferProducer : public BpInterface&lt;IGraphicBufferProducer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t dequeueBuffer(int *buf, sp&lt;Fence&gt;* fence, bool async,</span><br><span class="line">            uint32_t w, uint32_t h, uint32_t format, uint32_t usage) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(async);</span><br><span class="line">        data.writeInt32(w);</span><br><span class="line">        data.writeInt32(h);</span><br><span class="line">        data.writeInt32(format);</span><br><span class="line">        data.writeInt32(usage);</span><br><span class="line">        //这里通过 BpBinder 将相关参数进行序列化，并发送给 BBinder</span><br><span class="line">        status_t result = remote()-&gt;transact(DEQUEUE_BUFFER, data, &amp;reply);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;BpGraphicBufferProducer::dequeueBuffer binder transact failed, result: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取 BBinder 回复的int数据，这里指的是 mSlots 缓冲区数组的索引</span><br><span class="line">        *buf = reply.readInt32();</span><br><span class="line">        bool nonNull = reply.readInt32();</span><br><span class="line">        if (nonNull) &#123;</span><br><span class="line">            *fence = new Fence();</span><br><span class="line">            reply.read(**fence);</span><br><span class="line">        &#125;</span><br><span class="line">        result = reply.readInt32();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回归到 BnGraphicBufferProducer 实现，这里会调用 BufferQueue::dequeueBuffer() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">status_t BnGraphicBufferProducer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case DEQUEUE_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);</span><br><span class="line">            bool async      = data.readInt32();</span><br><span class="line">            uint32_t w      = data.readInt32();</span><br><span class="line">            uint32_t h      = data.readInt32();</span><br><span class="line">            uint32_t format = data.readInt32();</span><br><span class="line">            uint32_t usage  = data.readInt32();</span><br><span class="line">            int buf;</span><br><span class="line">            sp&lt;Fence&gt; fence;</span><br><span class="line">            int result = dequeueBuffer(&amp;buf, &amp;fence, async, w, h, format, usage);</span><br><span class="line">            reply-&gt;writeInt32(buf);</span><br><span class="line">            reply-&gt;writeInt32(fence != NULL);</span><br><span class="line">            if (fence != NULL) &#123;</span><br><span class="line">                reply-&gt;write(*fence);</span><br><span class="line">            &#125;</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查找 mSlots 数组中 BufferSlot::FREE 状态的缓存区，如果没有找到继续等待消费者；设置找到的缓存区状态为 BufferSlot::DEQUEUED，并检查这个缓冲区的 mGraphicBuffer 内存是否满足使用条件，如果不满足则设置 BUFFER_NEEDS_REALLOCATION 标志，调用 <code>mGraphicBufferAlloc-&gt;createGraphicBuffer()</code> 重新申请内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">status_t BufferQueue::dequeueBuffer(int *outBuf, sp&lt;Fence&gt;* outFence, bool async,</span><br><span class="line">        uint32_t w, uint32_t h, uint32_t format, uint32_t usage) &#123;</span><br><span class="line"></span><br><span class="line">    bool tryAgain = true;</span><br><span class="line">    while (tryAgain) &#123;</span><br><span class="line">        // look for a free buffer to give to the client</span><br><span class="line">        found = INVALID_BUFFER_SLOT;</span><br><span class="line">        int dequeuedCount = 0;</span><br><span class="line">        int acquiredCount = 0;</span><br><span class="line">        for (int i = 0; i &lt; maxBufferCount; i++) &#123;</span><br><span class="line">            const int state = mSlots[i].mBufferState;</span><br><span class="line">            switch (state) &#123;</span><br><span class="line">                case BufferSlot::DEQUEUED:</span><br><span class="line">                    dequeuedCount++;</span><br><span class="line">                    break;</span><br><span class="line">                case BufferSlot::ACQUIRED:</span><br><span class="line">                    acquiredCount++;</span><br><span class="line">                    break;</span><br><span class="line">                case BufferSlot::FREE:</span><br><span class="line">                    /* We return the oldest of the free buffers to avoid</span><br><span class="line">                    * stalling the producer if possible.  This is because</span><br><span class="line">                    * the consumer may still have pending reads of the</span><br><span class="line">                    * buffers in flight.</span><br><span class="line">                    */</span><br><span class="line">                    if ((found &lt; 0) ||</span><br><span class="line">                            mSlots[i].mFrameNumber &lt; mSlots[found].mFrameNumber) &#123;</span><br><span class="line">                        found = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        // See whether a buffer has been queued since the last</span><br><span class="line">        // setBufferCount so we know whether to perform the min undequeued</span><br><span class="line">        // buffers check below.</span><br><span class="line">        if (mBufferHasBeenQueued) &#123;</span><br><span class="line">            // make sure the client is not trying to dequeue more buffers</span><br><span class="line">            // than allowed.</span><br><span class="line">            const int newUndequeuedCount = maxBufferCount - (dequeuedCount+1);</span><br><span class="line">            const int minUndequeuedCount = getMinUndequeuedBufferCount(async);</span><br><span class="line">            if (newUndequeuedCount &lt; minUndequeuedCount) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: min undequeued buffer count (%d) &quot;</span><br><span class="line">                        &quot;exceeded (dequeued=%d undequeudCount=%d)&quot;,</span><br><span class="line">                        minUndequeuedCount, dequeuedCount,</span><br><span class="line">                        newUndequeuedCount);</span><br><span class="line">                return -EBUSY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If no buffer is found, wait for a buffer to be released or for</span><br><span class="line">        // the max buffer count to change.</span><br><span class="line">        tryAgain = found == INVALID_BUFFER_SLOT;</span><br><span class="line">        if (tryAgain) &#123;</span><br><span class="line">            // return an error if we&apos;re in &quot;cannot block&quot; mode (producer and consumer</span><br><span class="line">            // are controlled by the application) -- however, the consumer is allowed</span><br><span class="line">            // to acquire briefly an extra buffer (which could cause us to have to wait here)</span><br><span class="line">            // and that&apos;s okay because we know the wait will be brief (it happens</span><br><span class="line">            // if we dequeue a buffer while the consumer has acquired one but not released</span><br><span class="line">            // the old one yet -- for e.g.: see GLConsumer::updateTexImage()).</span><br><span class="line">            if (mDequeueBufferCannotBlock &amp;&amp; (acquiredCount &lt;= mMaxAcquiredBufferCount)) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: would block! returning an error instead.&quot;);</span><br><span class="line">                return WOULD_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            mDequeueCondition.wait(mMutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const int buf = found;</span><br><span class="line">    *outBuf = found;</span><br><span class="line">    mSlots[buf].mBufferState = BufferSlot::DEQUEUED;</span><br><span class="line"></span><br><span class="line">    const sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[buf].mGraphicBuffer);</span><br><span class="line">    if ((buffer == NULL) ||</span><br><span class="line">        (uint32_t(buffer-&gt;width)  != w) ||</span><br><span class="line">        (uint32_t(buffer-&gt;height) != h) ||</span><br><span class="line">        (uint32_t(buffer-&gt;format) != format) ||</span><br><span class="line">        ((uint32_t(buffer-&gt;usage) &amp; usage) != usage))</span><br><span class="line">    &#123;</span><br><span class="line">        mSlots[buf].mAcquireCalled = false;</span><br><span class="line">        mSlots[buf].mGraphicBuffer = NULL;</span><br><span class="line">        mSlots[buf].mRequestBufferCalled = false;</span><br><span class="line">        mSlots[buf].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">        mSlots[buf].mFence = Fence::NO_FENCE;</span><br><span class="line">        mSlots[buf].mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line"></span><br><span class="line">        returnFlags |= IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (returnFlags &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">        status_t error;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer(</span><br><span class="line">                mGraphicBufferAlloc-&gt;createGraphicBuffer(w, h, format, usage, &amp;error));</span><br><span class="line">        if (graphicBuffer == 0) &#123;</span><br><span class="line">            ST_LOGE(&quot;dequeueBuffer: SurfaceComposer::createGraphicBuffer failed&quot;);</span><br><span class="line">            return error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123; // Scope for the lock</span><br><span class="line">            Mutex::Autolock lock(mMutex);</span><br><span class="line"></span><br><span class="line">            if (mAbandoned) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: BufferQueue has been abandoned!&quot;);</span><br><span class="line">                return NO_INIT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSlots[*outBuf].mFrameNumber = ~0;</span><br><span class="line">            mSlots[*outBuf].mGraphicBuffer = graphicBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BpGraphicBufferAlloc::createGraphicBuffer()</code> 通过 Binder 机制调用 <code>BnGraphicBufferAlloc::onTransact()</code> ，进而调用 GraphicBufferAlloc::createGraphicBuffer() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/IGraphicBufferAlloc.cpp</span><br><span class="line"></span><br><span class="line">class BpGraphicBufferAlloc : public BpInterface&lt;IGraphicBufferAlloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BpGraphicBufferAlloc(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IGraphicBufferAlloc&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;GraphicBuffer&gt; createGraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">            PixelFormat format, uint32_t usage, status_t* error) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferAlloc::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(w);</span><br><span class="line">        data.writeInt32(h);</span><br><span class="line">        data.writeInt32(format);</span><br><span class="line">        data.writeInt32(usage);</span><br><span class="line">        remote()-&gt;transact(CREATE_GRAPHIC_BUFFER, data, &amp;reply);</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer;</span><br><span class="line">        status_t result = reply.readInt32();</span><br><span class="line">        if (result == NO_ERROR) &#123;</span><br><span class="line">            graphicBuffer = new GraphicBuffer();</span><br><span class="line">            result = reply.read(*graphicBuffer);</span><br><span class="line">            // reply.readStrongBinder();</span><br><span class="line">            // here we don&apos;t even have to read the BufferReference from</span><br><span class="line">            // the parcel, it&apos;ll die with the parcel.</span><br><span class="line">        &#125;</span><br><span class="line">        *error = result;</span><br><span class="line">        return graphicBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">status_t BnGraphicBufferAlloc::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // codes that don&apos;t require permission check</span><br><span class="line"></span><br><span class="line">    /* BufferReference just keeps a strong reference to a</span><br><span class="line">     * GraphicBuffer until it is destroyed (that is, until</span><br><span class="line">     * no local or remote process have a reference to it).</span><br><span class="line">     */</span><br><span class="line">    class BufferReference : public BBinder &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">    public:</span><br><span class="line">        BufferReference(const sp&lt;GraphicBuffer&gt;&amp; buffer) : buffer(buffer) &#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_GRAPHIC_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);</span><br><span class="line">            uint32_t w = data.readInt32();</span><br><span class="line">            uint32_t h = data.readInt32();</span><br><span class="line">            PixelFormat format = data.readInt32();</span><br><span class="line">            uint32_t usage = data.readInt32();</span><br><span class="line">            status_t error;</span><br><span class="line">            sp&lt;GraphicBuffer&gt; result =</span><br><span class="line">                    createGraphicBuffer(w, h, format, usage, &amp;error);</span><br><span class="line">            reply-&gt;writeInt32(error);</span><br><span class="line">            if (result != 0) &#123;</span><br><span class="line">                reply-&gt;write(*result);</span><br><span class="line">                // We add a BufferReference to this parcel to make sure the</span><br><span class="line">                // buffer stays alive until the GraphicBuffer object on</span><br><span class="line">                // the other side has been created.</span><br><span class="line">                // This is needed so that the buffer handle can be</span><br><span class="line">                // registered before the buffer is destroyed on implementations</span><br><span class="line">                // that do not use file-descriptors to track their buffers.</span><br><span class="line">                reply-&gt;writeStrongBinder( new BufferReference(result) );</span><br><span class="line">            &#125;</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">        default:</span><br><span class="line">            return BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据传递的宽度、高度、格式等信息来构造 GraphicBuffer 对象，GraphicBuffer 类的构造函数会调用 initSize() 分配图形缓冲区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/GraphicBufferAlloc.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">        PixelFormat format, uint32_t usage, status_t* error) &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; graphicBuffer(new GraphicBuffer(w, h, format, usage));</span><br><span class="line">    status_t err = graphicBuffer-&gt;initCheck();</span><br><span class="line">    *error = err;</span><br><span class="line">    if (err != 0 || graphicBuffer-&gt;handle == 0) &#123;</span><br><span class="line">        if (err == NO_MEMORY) &#123;</span><br><span class="line">            GraphicBuffer::dumpAllocationsToSystemLog();</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGE(&quot;GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) &quot;</span><br><span class="line">            &quot;failed (%s), handle=%p&quot;,</span><br><span class="line">                w, h, strerror(-err), graphicBuffer-&gt;handle);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return graphicBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">        PixelFormat reqFormat, uint32_t reqUsage)</span><br><span class="line">    : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">    mInitCheck(NO_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">    width  =</span><br><span class="line">    height =</span><br><span class="line">    stride =</span><br><span class="line">    format =</span><br><span class="line">    usage  = 0;</span><br><span class="line">    handle = NULL;</span><br><span class="line">    mInitCheck = initSize(w, h, reqFormat, reqUsage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,</span><br><span class="line">        uint32_t reqUsage)</span><br><span class="line">&#123;</span><br><span class="line">    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();</span><br><span class="line">    status_t err = allocator.alloc(w, h, format, reqUsage, &amp;handle, &amp;stride);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        this-&gt;width  = w;</span><br><span class="line">        this-&gt;height = h;</span><br><span class="line">        this-&gt;format = format;</span><br><span class="line">        this-&gt;usage  = reqUsage;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GraphicBufferAllocator 是作为分配图形缓冲区的工具类，这里使用单例模式获取 GraphicBufferAllocator 对象，加载 Gralloc HAL ，最终调用 gralloc_alloc 实现图形缓冲区的分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/include/ui/GraphicBufferAllocator.h</span><br><span class="line"></span><br><span class="line">class GraphicBufferAllocator : public Singleton&lt;GraphicBufferAllocator&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static inline GraphicBufferAllocator&amp; get() &#123; return getInstance(); &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBufferAllocator.cpp</span><br><span class="line"></span><br><span class="line">GraphicBufferAllocator::GraphicBufferAllocator()</span><br><span class="line">    : mAllocDev(0)</span><br><span class="line">&#123;</span><br><span class="line">    hw_module_t const* module;</span><br><span class="line">    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module);</span><br><span class="line">    ALOGE_IF(err, &quot;FATAL: can&apos;t find the %s module&quot;, GRALLOC_HARDWARE_MODULE_ID);</span><br><span class="line">    if (err == 0) &#123;</span><br><span class="line">        gralloc_open(module, &amp;mAllocDev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在为止 BufferQueue 中已经申请到了内存，返回给 Surface 一个的数组下标，但这时候 Surface 还没有获取到任何图形缓冲区相关的东西。由于申请的内存是在 SurfaceFlinger 所在的进程，接下来调用 <code>mGraphicBufferProducer-&gt;requestBuffer</code> 将 buffer 映射到 Surface 所在的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/IGraphicBufferProducer.cpp</span><br><span class="line"></span><br><span class="line">class BpGraphicBufferProducer : public BpInterface&lt;IGraphicBufferProducer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t requestBuffer(int bufferIdx, sp&lt;GraphicBuffer&gt;* buf) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(bufferIdx);</span><br><span class="line">        status_t result =remote()-&gt;transact(REQUEST_BUFFER, data, &amp;reply);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;BpGraphicBufferProducer::requestBuffer binder transact failed, result: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        bool nonNull = reply.readInt32();</span><br><span class="line">        if (nonNull) &#123;</span><br><span class="line">            *buf = new GraphicBuffer();</span><br><span class="line">            reply.read(**buf);</span><br><span class="line">        &#125;</span><br><span class="line">        result = reply.readInt32();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BnGraphicBufferProducer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case REQUEST_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);</span><br><span class="line">            int bufferIdx   = data.readInt32();</span><br><span class="line">            sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">            int result = requestBuffer(bufferIdx, &amp;buffer);</span><br><span class="line">            reply-&gt;writeInt32(buffer != 0);</span><br><span class="line">            if (buffer != 0) &#123;</span><br><span class="line">                reply-&gt;write(*buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">status_t BufferQueue::requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ST_LOGV(&quot;requestBuffer: slot=%d&quot;, slot);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    if (mAbandoned) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: BufferQueue has been abandoned!&quot;);</span><br><span class="line">        return NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (slot &lt; 0 || slot &gt;= NUM_BUFFER_SLOTS) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: slot index out of range [0, %d]: %d&quot;,</span><br><span class="line">                NUM_BUFFER_SLOTS, slot);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125; else if (mSlots[slot].mBufferState != BufferSlot::DEQUEUED) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: slot %d is not owned by the client (state=%d)&quot;,</span><br><span class="line">                slot, mSlots[slot].mBufferState);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    mSlots[slot].mRequestBufferCalled = true;</span><br><span class="line">    *buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 requestBuffer() 方法返回后，调用 <code>reply-&gt;write(*buffer)</code> ，这里经过数据打包处理然后发送到应用程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/binder/Parcel.cpp</span><br><span class="line"></span><br><span class="line">status_t Parcel::write(const FlattenableHelperInterface&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    // size if needed</span><br><span class="line">    const size_t len = val.getFlattenedSize();</span><br><span class="line">    const size_t fd_count = val.getFdCount();</span><br><span class="line"></span><br><span class="line">    err = this-&gt;writeInt32(len);</span><br><span class="line">    if (err) return err;</span><br><span class="line"></span><br><span class="line">    err = this-&gt;writeInt32(fd_count);</span><br><span class="line">    if (err) return err;</span><br><span class="line"></span><br><span class="line">    // payload</span><br><span class="line">    void* const buf = this-&gt;writeInplace(PAD_SIZE(len));</span><br><span class="line">    if (buf == NULL)</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line"></span><br><span class="line">    int* fds = NULL;</span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        fds = new int[fd_count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数据的打包处理</span><br><span class="line">    err = val.flatten(buf, len, fds, fd_count);</span><br><span class="line">    for (size_t i=0 ; i&lt;fd_count &amp;&amp; err==NO_ERROR ; i++) &#123;</span><br><span class="line">        err = this-&gt;writeDupFileDescriptor( fds[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        delete [] fds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::flatten(void*&amp; buffer, size_t&amp; size, int*&amp; fds, size_t&amp; count) const &#123;</span><br><span class="line">    size_t sizeNeeded = GraphicBuffer::getFlattenedSize();</span><br><span class="line">    if (size &lt; sizeNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    size_t fdCountNeeded = GraphicBuffer::getFdCount();</span><br><span class="line">    if (count &lt; fdCountNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    int* buf = static_cast&lt;int*&gt;(buffer);</span><br><span class="line">    buf[0] = &apos;GBFR&apos;;</span><br><span class="line">    buf[1] = width;</span><br><span class="line">    buf[2] = height;</span><br><span class="line">    buf[3] = stride;</span><br><span class="line">    buf[4] = format;</span><br><span class="line">    buf[5] = usage;</span><br><span class="line">    buf[6] = 0;</span><br><span class="line">    buf[7] = 0;</span><br><span class="line"></span><br><span class="line">    if (handle) &#123;</span><br><span class="line">        buf[6] = handle-&gt;numFds;</span><br><span class="line">        buf[7] = handle-&gt;numInts;</span><br><span class="line">        native_handle_t const* const h = handle;</span><br><span class="line">        memcpy(fds,     h-&gt;data,             h-&gt;numFds*sizeof(int));</span><br><span class="line">        memcpy(&amp;buf[8], h-&gt;data + h-&gt;numFds, h-&gt;numInts*sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = reinterpret_cast&lt;void*&gt;(static_cast&lt;int*&gt;(buffer) + sizeNeeded);</span><br><span class="line">    size -= sizeNeeded;</span><br><span class="line">    fds += handle-&gt;numFds;</span><br><span class="line">    count -= handle-&gt;numFds;</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用程序端使用 <code>reply.read(*graphicBuffer)</code> 把数据读取出来，这里使用 Parcel::read() 方法，进而调用 GraphicBufer::unflatten() 方法，这里使用 fd 构造 native_handle 对象，然后调用 GraphicBufferMapper::registerBuffer() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/binder/Parcel.cpp</span><br><span class="line"></span><br><span class="line">status_t Parcel::read(FlattenableHelperInterface&amp; val) const</span><br><span class="line">&#123;</span><br><span class="line">    // size</span><br><span class="line">    const size_t len = this-&gt;readInt32();</span><br><span class="line">    const size_t fd_count = this-&gt;readInt32();</span><br><span class="line"></span><br><span class="line">    // payload</span><br><span class="line">    void const* const buf = this-&gt;readInplace(PAD_SIZE(len));</span><br><span class="line">    if (buf == NULL)</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line"></span><br><span class="line">    int* fds = NULL;</span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        fds = new int[fd_count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = NO_ERROR;</span><br><span class="line">    for (size_t i=0 ; i&lt;fd_count &amp;&amp; err==NO_ERROR ; i++) &#123;</span><br><span class="line">        fds[i] = dup(this-&gt;readFileDescriptor());</span><br><span class="line">        if (fds[i] &lt; 0) err = BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        err = val.unflatten(buf, len, fds, fd_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        delete [] fds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::unflatten(</span><br><span class="line">        void const*&amp; buffer, size_t&amp; size, int const*&amp; fds, size_t&amp; count) &#123;</span><br><span class="line">    if (size &lt; 8*sizeof(int)) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    int const* buf = static_cast&lt;int const*&gt;(buffer);</span><br><span class="line">    if (buf[0] != &apos;GBFR&apos;) return BAD_TYPE;</span><br><span class="line"></span><br><span class="line">    const size_t numFds  = buf[6];</span><br><span class="line">    const size_t numInts = buf[7];</span><br><span class="line"></span><br><span class="line">    const size_t sizeNeeded = (8 + numInts) * sizeof(int);</span><br><span class="line">    if (size &lt; sizeNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    size_t fdCountNeeded = 0;</span><br><span class="line">    if (count &lt; fdCountNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    if (handle) &#123;</span><br><span class="line">        // free previous handle if any</span><br><span class="line">        free_handle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (numFds || numInts) &#123;</span><br><span class="line">        width  = buf[1];</span><br><span class="line">        height = buf[2];</span><br><span class="line">        stride = buf[3];</span><br><span class="line">        format = buf[4];</span><br><span class="line">        usage  = buf[5];</span><br><span class="line">        native_handle* h = native_handle_create(numFds, numInts);</span><br><span class="line">        memcpy(h-&gt;data,          fds,     numFds*sizeof(int));</span><br><span class="line">        memcpy(h-&gt;data + numFds, &amp;buf[8], numInts*sizeof(int));</span><br><span class="line">        handle = h;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        width = height = stride = format = usage = 0;</span><br><span class="line">        handle = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOwner = ownHandle;</span><br><span class="line"></span><br><span class="line">    if (handle != 0) &#123;</span><br><span class="line">        status_t err = mBufferMapper.registerBuffer(handle);</span><br><span class="line">        if (err != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;unflatten: registerBuffer failed: %s (%d)&quot;,</span><br><span class="line">                    strerror(-err), err);</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际会调用 Gralloc 模块的 registerBuffer() 方法，这里会把申请的 buffer 进行 mmap 映射，然后将 vaddr 数据保存在 handle-&gt;base 中。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/ui/GraphicBufferMapper.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBufferMapper::registerBuffer(buffer_handle_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    err = mAllocMod-&gt;registerBuffer(mAllocMod, handle);</span><br><span class="line"></span><br><span class="line">    ALOGW_IF(err, &quot;registerBuffer(%p) failed %d (%s)&quot;,</span><br><span class="line">            handle, err, strerror(-err));</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dequeueBuffer() 完成之后会调用 backBuffer-&gt;lock()，实际上调用的是 gralloc_lock()，直接返回 handle-&gt;base()。</p><p>总结：真正的申请图形缓冲区是在 SurfaceFlinger 进程中，因为 GraphicBufferAlloc 对象是在 SurfaceFlinger 中构造出来的，然后 BufferQueue 和 Surface 中的图形缓冲区都是通过 GraphicBuffer 的序列化和反序列化新映射出来的。</p><h2 id="surface-gt-unlockAndPost"><a href="#surface-gt-unlockAndPost" class="headerlink" title="surface-&gt;unlockAndPost();"></a>surface-&gt;unlockAndPost();</h2><p>更新缓冲区后送给 SurfaceFlinger ，代码调用 queueBuffer() 方法，而 <code>mGraphicBufferProducer-&gt;queueBuffer()</code> 方法实际上调用的是本地对象的 BnGraphicBufferProducer::queueBuffer() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/Surface.cpp</span><br><span class="line"></span><br><span class="line">status_t Surface::unlockAndPost()</span><br><span class="line">&#123;</span><br><span class="line">    if (mLockedBuffer == 0) &#123;</span><br><span class="line">        ALOGE(&quot;Surface::unlockAndPost failed, no locked buffer&quot;);</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = mLockedBuffer-&gt;unlock();</span><br><span class="line">    ALOGE_IF(err, &quot;failed unlocking buffer (%p)&quot;, mLockedBuffer-&gt;handle);</span><br><span class="line"></span><br><span class="line">    err = queueBuffer(mLockedBuffer.get(), -1);</span><br><span class="line">    ALOGE_IF(err, &quot;queueBuffer (handle=%p) failed (%s)&quot;,</span><br><span class="line">            mLockedBuffer-&gt;handle, strerror(-err));</span><br><span class="line"></span><br><span class="line">    mPostedBuffer = mLockedBuffer;</span><br><span class="line">    mLockedBuffer = 0;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;Surface::queueBuffer&quot;);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    int64_t timestamp;</span><br><span class="line">    bool isAutoTimestamp = false;</span><br><span class="line">    if (mTimestamp == NATIVE_WINDOW_TIMESTAMP_AUTO) &#123;</span><br><span class="line">        timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        isAutoTimestamp = true;</span><br><span class="line">        ALOGV(&quot;Surface::queueBuffer making up timestamp: %.2f ms&quot;,</span><br><span class="line">            timestamp / 1000000.f);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        timestamp = mTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = getSlotFromBufferLocked(buffer);</span><br><span class="line">    if (i &lt; 0) &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure the crop rectangle is entirely inside the buffer.</span><br><span class="line">    Rect crop;</span><br><span class="line">    mCrop.intersect(Rect(buffer-&gt;width, buffer-&gt;height), &amp;crop);</span><br><span class="line"></span><br><span class="line">    sp&lt;Fence&gt; fence(fenceFd &gt;= 0 ? new Fence(fenceFd) : Fence::NO_FENCE);</span><br><span class="line">    IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">    IGraphicBufferProducer::QueueBufferInput input(timestamp, isAutoTimestamp,</span><br><span class="line">            crop, mScalingMode, mTransform, mSwapIntervalZero, fence);</span><br><span class="line">    status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">    if (err != OK)  &#123;</span><br><span class="line">        ALOGE(&quot;queueBuffer: error queuing buffer to SurfaceTexture, %d&quot;, err);</span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t numPendingBuffers = 0;</span><br><span class="line">    output.deflate(&amp;mDefaultWidth, &amp;mDefaultHeight, &amp;mTransformHint,</span><br><span class="line">            &amp;numPendingBuffers);</span><br><span class="line"></span><br><span class="line">    mConsumerRunningBehind = (numPendingBuffers &gt;= 2);</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在谈及 Android GUI 框架前，先从底层视角梳理一下显示的流程。在 Android 系统中，引入了状态栏、导航栏、壁纸和背景的图层概念，需要把这些图层进行 alpha blending 后显示。&lt;/p&gt;
&lt;p&gt;在嵌入式 linux 系统下显示界面，可以直接操作 fr
      
    
    </summary>
    
    
      <category term="android" scheme="http://tinylaker.github.io/categories/android/"/>
    
    
      <category term="GUI" scheme="http://tinylaker.github.io/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>sc7731 lcd流程分析</title>
    <link href="http://tinylaker.github.io/2019/11/09/sc7731-lcd%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/</id>
    <published>2019-11-09T11:34:45.000Z</published>
    <updated>2019-11-10T14:46:14.611Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。</p><p>本文基于Android 4.4代码分析sc7731 lcd的基本流程。</p><h1 id="显示系统"><a href="#显示系统" class="headerlink" title="显示系统"></a>显示系统</h1><p>这里暂时以7710芯片手册为例，多媒体显示系统包含 LCDC 和 DISPC，其中 LCDC 仅支持 MCU 接口类型，支持 2 路显示；而 DISPC 同时支持 DBI 和 DPI 接口类型。</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png" alt="lcd"></p><ul><li>LCDC</li></ul><p>支持最多6个图层的Alaha Blending，RGB888数据格式到RGB565/RGB666数据格式的Dithering等功能。</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcdc_module.png" alt="lcdc"></p><ul><li>LCM</li></ul><p>LCM接收AHB总线或者LCDC数据，并按照MCU接口格式按照固定的时序传输到显示模组上。<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcm_module.png" alt="lcm"></p><p>MCU支持8080和6080两种传输格式，两者的区别只是在读写控制上。</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/8080.png" alt="8080"></p><ul><li>DISPC</li></ul><p>这里可以看出2种路线，一种直接由LCDC DBI经由DISPC DBI输出；另一种直接由AXI Domain到DISPC DBI/DPI输出。所以如果使用MIPI接口显示模组，是不需要经过LCDC显示模块的，直接由DISPC模块控制。      </p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/DISPC.png" alt="DISPC"></p><h1 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h1><p>lcd相关源码位于 <code>drivers/video/sprdfb</code>，代码文件截图如下:</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sc7731_uboot_lcd.png" alt="uboot source code"></p><p>可以看到代码兼容了多款 Soc，Makefile 中也包含了多个平台的配置。</p><p>头文件 <code>include/configs/sp7731gea.h</code>，里面定义了 <code>CONFIG_SC8830</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SC8830</span><br><span class="line">#define CONFIG_DSIH_VERSION_1P21A</span><br><span class="line">#define CONFIG_FB_LCD_NT35516_MIPI</span><br></pre></td></tr></table></figure><p>这里值得一提的是7731和8830的AP相同，只是Modem存在差异，前者支持WCMDA，后者支持TD_SCMDA。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_SC8830)+= sprdfb_main.o sprdfb_panel.o sprdfb_dispc.o \</span><br><span class="line">    sprdfb_mcu.o sprdfb_rgb.o sprdfb_mipi.o \</span><br><span class="line">     sprdfb_i2c.o sprdfb_spi.o sprdfb_dsi.o \</span><br><span class="line">     sprdfb_chip_common.o sprdfb_chip_8830.o</span><br></pre></td></tr></table></figure><p>能够看出该平台的显示系统支持多种lcd接口，包括mcu、rgb、mipi、i2c、spi。</p><p>这里的mipi dsi有2个不同版本的IP核，参考头文件中的定义，这里使用的是dsi_1_21a中的代码。</p><p>下面以 <code>lcd_nt35516_mipi.c</code> 为例，分析 uboot lcd 的整个流程。</p><h2 id="lcd-模组配置"><a href="#lcd-模组配置" class="headerlink" title="lcd 模组配置"></a>lcd 模组配置</h2><ol><li><p><code>drivers/video/sprdfb/lcd/Makefile</code> 包含编译该屏驱动的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_FB_LCD_NT35516_MIPI) += lcd_nt35516_mipi.o</span><br></pre></td></tr></table></figure></li><li><p><code>drivers/video/sprdfb/sprdfb_panel.c</code> 中包含该屏的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern struct panel_spec lcd_nt35516_mipi_spec;</span><br><span class="line">static struct panel_cfg panel_cfg[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">#ifdef CONFIG_FB_LCD_NT35516_MIPI </span><br><span class="line">    &#123; </span><br><span class="line">        .lcd_id = 0x16, </span><br><span class="line">        .panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">    &#125;,</span><br><span class="line"> #endif</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code> 中详细描述了该模组的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">        //.cap = PANEL_CAP_NOT_TEAR_SYNC,</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">        .display_width = 480,</span><br><span class="line">        .display_height= 854,</span><br><span class="line">#endif</span><br><span class="line">        .width = 540,</span><br><span class="line">        .height = 960,</span><br><span class="line">        .fps = 60,</span><br><span class="line">        .type = LCD_MODE_DSI,</span><br><span class="line">        .direction = LCD_DIRECT_NORMAL,</span><br><span class="line">        .info = &#123;</span><br><span class="line">                .mipi = &amp;lcd_nt35516_mipi_info    //(1) mipi lcd模组的常规配置</span><br><span class="line">        &#125;,</span><br><span class="line">        .ops = &amp;lcd_nt35516_mipi_operations,    //(2) mipi lcd的操作集合</span><br><span class="line">&#125;;</span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">        .work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">        .video_bus_width = 24, /*18,16*/</span><br><span class="line">        .lan_number = 3,</span><br><span class="line">        .phy_feq = 500*1000,</span><br><span class="line">        .h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .timing = &amp;lcd_nt35516_mipi_timing,    //(3) mipi lcd的时序proch配置</span><br><span class="line">        .ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">        .panel_init = nt35516_mipi_init,    //包含mipi屏大量初始化代码</span><br><span class="line">        .panel_readid = nt35516_readid,    //mipi屏的读取id操作</span><br><span class="line">&#125;;</span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">        .hfp = 20,  /* unit: pixel */</span><br><span class="line">        .hbp = 20,</span><br><span class="line">        .hsync = 20,//4,</span><br><span class="line">        .vfp = 10, /*unit: line*/</span><br><span class="line">        .vbp = 10,</span><br><span class="line">        .vsync = 6,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="lcd-模组初始化流程"><a href="#lcd-模组初始化流程" class="headerlink" title="lcd 模组初始化流程"></a>lcd 模组初始化流程</h2><p>系统上电执行芯片 <strong>RomCode</strong>，完成 DDR 和外部存储器等常用外设的初始化；</p><p>之后读取外部存储器中的 uboot 并跳转执行，优先完成板级初始化 <code>board_init_f</code> 和 <code>board_init_r</code>，其中 <code>board_init_r</code> 中调用了<code>stdio_init</code>。代码流程图如下：</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprdfb_uboot_lcd_init.png" alt="sprdfb_lcd_init"></p><p>我们把重点聚焦在 sprdfb_probe 的实现上，下面剔除了部分无关代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c  </span><br><span class="line"></span><br><span class="line">static int sprdfb_probe(void * lcdbase)</span><br><span class="line">&#123;</span><br><span class="line">        struct sprdfb_device *dev = &amp;s_sprdfb_dev;</span><br><span class="line">        set_backlight(0);    //(1)</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(2) </span><br><span class="line">        dev-&gt;ctrl-&gt;early_init(dev);    //(3)</span><br><span class="line">        if (0 != sprdfb_panel_probe(dev)) &#123;    //(4)</span><br><span class="line">                sprdfb_panel_remove(dev);</span><br><span class="line">                dev-&gt;ctrl-&gt;uninit(dev);</span><br><span class="line">                printf(&quot;sprdfb: failed to probe\n&quot;);</span><br><span class="line">                return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        dev-&gt;smem_start = ((uint32_t)lcdbase);</span><br><span class="line">        dev-&gt;ctrl-&gt;init(dev);    //(5)</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(1) 关闭pwm控制</li><li>(2) 获取display controller的接口，定义在 <code>sprdfb_dispc.c</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_dispc.c</span><br><span class="line"></span><br><span class="line">struct display_ctrl sprdfb_dispc_ctrl = &#123;</span><br><span class="line">        .name           = &quot;dispc&quot;,</span><br><span class="line">        .early_init             = sprdfb_dispc_early_init,</span><br><span class="line">        .init                   = sprdfb_dispc_init,</span><br><span class="line">        .uninit         = sprdfb_dispc_uninit,</span><br><span class="line">        .refresh                = sprdfb_dispc_refresh,</span><br><span class="line">        .update_clk     = dispc_update_clock,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li>(3) 调用<code>sprdfb_dispc_early_init</code>，配置相关的clk，使能<code>dispc module</code></li><li>(4) <code>sprdfb_panel_probe</code> 会读取和保存 lcd 模组的 id，并对该模组完成初始化。</li><li>(5) <code>sprdfb_dispc_init</code> 会完成显示系统 dithering 和 osd layer 的设置。</li></ul><p>需要特别注意 uboot lcd 初始化流程中会保存 <strong>lcd_base</strong> 和 <strong>lcd_id</strong>，通过命令行参数传递，以供 kernel 阶段继续使用。</p><h2 id="lcd-刷新显示流程"><a href="#lcd-刷新显示流程" class="headerlink" title="lcd 刷新显示流程"></a>lcd 刷新显示流程</h2><p>看到这里读者可能会有疑问，uboot logo 是什么时候显示的呢？</p><p>下面开始分析lcd refresh流程，这里要从 <code>board_init_r</code> 中的<strong>do_cboot</strong>代码分析。</p><ol><li><p>normal_mode<br>代码定义了多种启动方式：normal、recovery、fastboot、charge、watchdog等，这里直接看normal_boot的代码。<br>首先初始化马达硬件，完成开机震动，然后调用 vlx_nand_boot，这里的代码取决有是 nand 方案还是 emmc 方案，这里假设是 emmc 启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ property/normal_mode.c</span><br><span class="line"></span><br><span class="line">void normal_mode(void) &#123;</span><br><span class="line">    vibrator_hw_init();</span><br><span class="line">    set_vibrator(1);</span><br><span class="line">#if BOOT_NATIVE_LINUX</span><br><span class="line">    vlx_nand_boot(BOOT_PART, CONFIG_BOOTARGS, BACKLIGHT_ON);</span><br><span class="line">#else</span><br><span class="line">    vlx_nand_boot(BOOT_PART, NULL, BACKLIGHT_ON);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vlx_nand_boot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ property/normal_emc_mode.c</span><br><span class="line"></span><br><span class="line">void vlx_nand_boot(char * kernel_pname, char * cmdline, int backlight_set) &#123;</span><br><span class="line">    _boot_display_logo(dev, backlight_set);    //(1)</span><br><span class="line">    set_vibrator(FALSE);</span><br><span class="line">    _boot_load_kernel_ramdisk_image(dev, kernel_pname, hdr);</span><br><span class="line">    _boot_secure_check();</span><br><span class="line">    sipc_addr_reset();</span><br><span class="line">    vlx_entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>调用_boot_display_logo，读取logo分区图片内容，并调用lcd_display_logo，重点关注。</p></li><li><p>关闭马达;</p></li><li><p>从存储器读取kernel、ramdisk、dtb image，保存相关内存地址。</p></li><li><p>secure boot校验流程，根据产品定义，可能会对DSP、Modem、SIMLOCK等image进行校验。</p></li><li><p>sipc 内存区域清零，这部分由展讯自己实现，用于AP和Modem之间的通信交换，后面有文章会涉及。</p></li><li><p>跳转到内核启动</p></li></ul><ol start="3"><li><p>_boot_display_logo<br>从logo分区中读取图片信息，存放到缓存中，调用<code>lcd_display_logo</code>刷新显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LOCAL __inline void _boot_display_logo(block_dev_desc_t *dev, int backlight_set)</span><br><span class="line">&#123;</span><br><span class="line">        size_t size;</span><br><span class="line">#if defined(CONFIG_LCD_720P) || defined(CONFIG_LCD_HD) //LiWei add CONFIG_LCD_HD</span><br><span class="line">        size = 1&lt;&lt;20;</span><br><span class="line">#else</span><br><span class="line">        size = 1&lt;&lt;19;</span><br><span class="line">#endif</span><br><span class="line">        uint8 * bmp_img = malloc(size);</span><br><span class="line">        if(!bmp_img)&#123;</span><br><span class="line">            debugf(&quot;%s: malloc for splash image failed!\n&quot;,__FUNCTION__);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!_boot_partition_read(dev, L&quot;logo&quot;, 0, size, bmp_img))</span><br><span class="line">        &#123;</span><br><span class="line">                debugf(&quot;%s: read logo partition failed!\n&quot;,__FUNCTION__);</span><br><span class="line">                goto end;</span><br><span class="line">        &#125;</span><br><span class="line">        lcd_display_logo(backlight_set,(ulong)bmp_img,size);</span><br><span class="line">end:</span><br><span class="line">        free(bmp_img);</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lcd_display_logo<br>因为是bmp格式图片，需要调用 lcd_display_bitmap 进行格式转换后才能在lcd上显示；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void lcd_display_logo(int backlight_set,ulong bmp_img,size_t size)</span><br><span class="line">&#123;</span><br><span class="line">#define mdelay(t)     (&#123;unsigned long msec=(t); while (msec--) &#123; udelay(1000);&#125;&#125;)</span><br><span class="line">    if(backlight_set == BACKLIGHT_ON)&#123;</span><br><span class="line">        lcd_display_bitmap((ulong)bmp_img, 0, 0);</span><br><span class="line">        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);</span><br><span class="line">        lcd_display();</span><br><span class="line">        mdelay(50);</span><br><span class="line">        set_backlight(255);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);</span><br><span class="line">        lcd_display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lcd_display<br>参考前面的内容，refresh函数指针等同于<code>sprdfb_dispc_refresh</code>，定义在 <code>drivers/video/sprdfb_dispc.c</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c</span><br><span class="line">void lcd_display(void)</span><br><span class="line">&#123;</span><br><span class="line">    real_refresh(&amp;s_sprdfb_dev);</span><br><span class="line">&#125;</span><br><span class="line">static int real_refresh(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    dev-&gt;ctrl-&gt;refresh(dev);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sprdfb_dispc_refresh<br>这里针对mipi lcd模组，可以简单理解为cmd mode和video mode不同方式刷新显示，这里不再详细分析操作寄存器的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb_dispc.c</span><br><span class="line">static int32_t sprdfb_dispc_refresh (struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    if(SPRDFB_PANEL_IF_DPI == dev-&gt;panel_if_type) &#123;    //cmd mode</span><br><span class="line">        dispc_set_bits((1&lt;&lt;5), DISPC_DPI_CTRL);</span><br><span class="line">        if(is_first_frame)&#123;</span><br><span class="line">            udelay(30);</span><br><span class="line">            dispc_clear_bits((1&lt;&lt;4), DISPC_DPI_CTRL);</span><br><span class="line">            dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);</span><br><span class="line">            is_first_frame = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;    //video mode</span><br><span class="line">        dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);</span><br><span class="line">        ...</span><br><span class="line">        dispc_set_bits((1&lt;&lt;0), DISPC_INT_CLR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此，uboot lcd的初始化和刷新显示已经分析完成了。</p><h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><p>lcd 相关代码如下图：<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd.png" alt="sprdfb kernel code"></p><p>和 uboot 代码架构基本相似，下面以 <code>lcd_nt35516_mipi.c</code>为例进行分析</p><h2 id="lcd模组配置"><a href="#lcd模组配置" class="headerlink" title="lcd模组配置"></a>lcd模组配置</h2><p>驱动文件放置路径:  <code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code></p><ul><li><p>drivers/video/sprdfb/lcd/Makefile<br>包含编译该屏驱动的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_FB_LCD_NT35516_MIPI)  += lcd_nt35516_mipi.o=</span><br></pre></td></tr></table></figure></li><li><p>drivers/video/sprdfb/Kconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config FB_LCD_NT35516_MIPI</span><br><span class="line">        boolean &quot;support NT35516 mipi panel&quot;</span><br><span class="line">        depends on FB_SC8825 || FB_SCX35 || FB_SCX30G</span><br><span class="line">        default n</span><br></pre></td></tr></table></figure></li><li><p>arch/arm/configs/sp7731gea-dt_defconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FB_LCD_NT35516_MIPI=y</span><br></pre></td></tr></table></figure></li><li><p>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c<br>这个文件配置了该模组的基本信息和操作方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">.panel_init = nt35516_mipi_init,</span><br><span class="line">.panel_readid = nt35516_readid,</span><br><span class="line">.panel_enter_sleep = nt35516_enter_sleep,</span><br><span class="line">.panel_esd_check = nt35516_check_esd,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">.hfp = 20,  /* unit: pixel */</span><br><span class="line">.hbp = 20,</span><br><span class="line">.hsync = 20,//4,</span><br><span class="line">.vfp = 10, /*unit: line*/</span><br><span class="line">.vbp = 10,</span><br><span class="line">.vsync = 6,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">.work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">.video_bus_width = 24, /*18,16*/</span><br><span class="line">.lan_number = 3,</span><br><span class="line">.phy_feq = 500*1000,</span><br><span class="line">.h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">.v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">.de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">.te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">.color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">.shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">.timing = &amp;lcd_nt35516_mipi_timing,</span><br><span class="line">.ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">.display_width = 480,</span><br><span class="line">.display_height = 854,</span><br><span class="line">#endif</span><br><span class="line">.width = 540,</span><br><span class="line">.height = 960,</span><br><span class="line">.fps = 60,</span><br><span class="line">.type = LCD_MODE_DSI,</span><br><span class="line">.direction = LCD_DIRECT_NORMAL,</span><br><span class="line">.is_clean_lcd = true,</span><br><span class="line">.info = &#123;</span><br><span class="line">.mipi = &amp;lcd_nt35516_mipi_info</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;lcd_nt35516_mipi_operations,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct panel_cfg lcd_nt35516_mipi = &#123;</span><br><span class="line">/* this panel can only be main lcd */</span><br><span class="line">.dev_id = SPRDFB_MAINLCD_ID,</span><br><span class="line">.lcd_id = 0x16,</span><br><span class="line">.lcd_name = &quot;lcd_nt35516_mipi&quot;,</span><br><span class="line">.panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init lcd_nt35516_mipi_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return sprdfb_panel_register(&amp;lcd_nt35516_mipi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(lcd_nt35516_mipi_init);</span><br></pre></td></tr></table></figure></li></ul><p><strong>subsys_initcall</strong> 是一个内核中的一个宏，定义特殊的init段，在内核启动过程中会依次调用这些函数，基本和<strong>module_init</strong>类似，但优先级更高。</p><p><strong>sprdfb_panel_register</strong> 定义在 <code>drivers/video/sprdfb/sprdfb_panel.c</code>，会把该模组对应的 panel_cfg 添加到维护的全局链表<code>panel_list_main</code> 中。</p><h2 id="lcd-模组初始化流程-1"><a href="#lcd-模组初始化流程-1" class="headerlink" title="lcd 模组初始化流程"></a>lcd 模组初始化流程</h2><ul><li><p>arch/arm/configs/sp7731gea-native_defconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MACH_SP7731GEA=y</span><br></pre></td></tr></table></figure></li><li><p>arch/arm/boot/dts/Makefile </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch/arm/boot/dts/sprd-scx35_sp7731gea.dts</span><br><span class="line">226:dtb-$(CONFIG_MACH_SP7731GEA) += sprd-scx35_sp7731gea.dtb</span><br><span class="line">227:dtb-$(CONFIG_MACH_SP7731GEA_LM) += sprd-scx35_sp7731gea_lm.dtb</span><br><span class="line">228:dtb-$(CONFIG_MACH_SP7731GEA_FWVGA) += sprd-scx35_sp7731gea_fwvga.dtb</span><br><span class="line">229:dtb-$(CONFIG_MACH_SP7731GEAOPENPHONE) += sprd-scx35_sp7731geaopenphone.dtb</span><br></pre></td></tr></table></figure></li><li><p>sprd-scx35_sp7731gea.dts<br>其中lcd controller配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">serial0 = &amp;uart0;</span><br><span class="line">serial1 = &amp;uart1;</span><br><span class="line">serial2 = &amp;uart2;</span><br><span class="line">serial3 = &amp;uart3;</span><br><span class="line">i2c0 = &amp;i2c0;</span><br><span class="line">i2c1 = &amp;i2c1;</span><br><span class="line">i2c2 = &amp;i2c2;</span><br><span class="line">i2c3 = &amp;i2c3;</span><br><span class="line">lcd0 = &amp;fb0;</span><br><span class="line">spi0 = &amp;spi0;</span><br><span class="line">spi1 = &amp;spi1;</span><br><span class="line">spi2 = &amp;spi2;</span><br><span class="line">hwspinlock0 = &amp;hwspinlock0;</span><br><span class="line">hwspinlock1 = &amp;hwspinlock1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fb0: fb@20800000 &#123;</span><br><span class="line">compatible = &quot;sprd,sprdfb&quot;;</span><br><span class="line">reg = &lt;0xf5122000 0x1000&gt;,&lt;0xf5146000 0x1000&gt;;</span><br><span class="line">interrupts = &lt;0 46 0x0&gt;,&lt;0 48 0x0&gt;, &lt;0 49 0x0&gt;;</span><br><span class="line">clock-names = &quot;dispc_clk_parent&quot;, &quot;dispc_dbi_clk_parent&quot;, &quot;dispc_dpi_clk_parent&quot;, &quot;dispc_emc_clk_parent&quot;, &quot;dispc_clk&quot;, &quot;dispc_dbi_clk&quot;, &quot;dispc_dpi_clk&quot;, &quot;dispc_emc_clk&quot;, &quot;fb_spi_clock&quot;, &quot;fb_spi_clock_parent&quot;;</span><br><span class="line">clocks = &lt;&amp;clk_256m&gt;, &lt;&amp;clk_256m&gt;, &lt;&amp;clk_384m&gt;, &lt;&amp;clk_aon_apb&gt;, &lt;&amp;clk_dispc0&gt;, &lt;&amp;clk_dispc0_dbi&gt;, &lt;&amp;clk_dispc0_dpi&gt;, &lt;&amp;clk_disp_emc&gt;, &lt;&amp;clk_spi2&gt;, &lt;&amp;ext_26m&gt;;</span><br><span class="line">clock-src = &lt;256000000 256000000 384000000&gt;;</span><br><span class="line">dpi_clk_div = &lt;7&gt;;</span><br><span class="line">sprd,fb_use_reservemem;</span><br><span class="line">sprd,fb_mem = &lt;0x9F311000 0x5EF000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>drivers/video/sprdfb/sprdfb_main.c<br>与之相匹配的lcd控制器驱动位于 <code>drivers/video/sprdfb/sprdfb_main.c</code>，当设备节点device_node被解析为platform_device注册到系统时，会和这个驱动进行匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_OF</span><br><span class="line">static const struct of_device_id sprdfb_dt_ids[] = &#123;</span><br><span class="line">        &#123; .compatible = &quot;sprd,sprdfb&quot;, &#125;,</span><br><span class="line">        &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line">static struct platform_driver sprdfb_driver = &#123;</span><br><span class="line">        .probe = sprdfb_probe,</span><br><span class="line">#ifndef CONFIG_HAS_EARLYSUSPEND</span><br><span class="line">        .suspend = sprdfb_suspend,</span><br><span class="line">        .resume = sprdfb_resume,</span><br><span class="line">#endif</span><br><span class="line">        .remove = sprdfb_remove,</span><br><span class="line">        .driver = &#123;</span><br><span class="line">                .name = &quot;sprd_fb&quot;,</span><br><span class="line">                .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">                .of_match_table = of_match_ptr(sprdfb_dt_ids),</span><br><span class="line">#endif</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">static int __init sprdfb_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        return platform_driver_register(&amp;sprdfb_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>驱动加载流程大致如下图：<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd_init.png" alt="sprd kernel lcd probe"></p><p><strong>sprdfb_probe</strong> 函数的定义如下，简单分析下代码流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static int sprdfb_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct fb_info *fb = NULL;</span><br><span class="line">    struct sprdfb_device *dev = NULL;</span><br><span class="line">    struct resource r;</span><br><span class="line"></span><br><span class="line">    fb = framebuffer_alloc(sizeof(struct sprdfb_device), &amp;pdev-&gt;dev);    //(1)分布帧缓冲使用空间</span><br><span class="line">    dev = fb-&gt;par;</span><br><span class="line">    dev-&gt;fb = fb;</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">    dev-&gt;of_dev = &amp;(pdev-&gt;dev);</span><br><span class="line">    dev-&gt;dev_id = of_alias_get_id(pdev-&gt;dev.of_node, &quot;lcd&quot;);    //(2)读取设备树中lcd id</span><br><span class="line">    printk(&quot;sprdfb: [%s] id = %d\n&quot;, __FUNCTION__, dev-&gt;dev_id);</span><br><span class="line">#else</span><br><span class="line">    dev-&gt;dev_id = pdev-&gt;id;</span><br><span class="line">#endif</span><br><span class="line">    switch(SPRDFB_IN_DATA_TYPE)&#123;</span><br><span class="line">    case SPRD_IN_DATA_TYPE_ABGR888:</span><br><span class="line">        dev-&gt;bpp = 32;</span><br><span class="line">        break;</span><br><span class="line">    case SPRD_IN_DATA_TYPE_BGR565:</span><br><span class="line">        dev-&gt;bpp = 16;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        dev-&gt;bpp = 32;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(SPRDFB_MAINLCD_ID == dev-&gt;dev_id)&#123;    //确认是主屏显示</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(3) </span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">        if(0 != of_address_to_resource(pdev-&gt;dev.of_node, 0, &amp;r))&#123;    //(4)</span><br><span class="line">            printk(KERN_ERR &quot;sprdfb: sprdfb_probe fail. (can&apos;t get register base address)\n&quot;);</span><br><span class="line">            goto err0;</span><br><span class="line">        &#125;</span><br><span class="line">        g_dispc_base_addr = r.start;</span><br><span class="line">        printk(&quot;sprdfb: set g_dispc_base_addr = 0x%x\n&quot;, g_dispc_base_addr);</span><br><span class="line">#endif</span><br><span class="line">    dev-&gt;logo_buffer_addr_v = 0;</span><br><span class="line">    if(sprdfb_panel_get(dev))&#123;    //(5) </span><br><span class="line">        dev-&gt;panel_ready = true;</span><br><span class="line">        dev-&gt;ctrl-&gt;logo_proc(dev);  //(6)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dev-&gt;panel_ready = false;</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;ctrl-&gt;early_init(dev); //(7)</span><br><span class="line">    if(!dev-&gt;panel_ready)&#123;</span><br><span class="line">        if (!sprdfb_panel_probe(dev)) &#123;</span><br><span class="line">            ret = -EIO;</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = setup_fb_mem(dev, pdev);  //(8)</span><br><span class="line">    setup_fb_info(dev); //(9)</span><br><span class="line">    /* register framebuffer device */</span><br><span class="line">    ret = register_framebuffer(fb); //(10)</span><br><span class="line">    platform_set_drvdata(pdev, dev);</span><br><span class="line">    sprdfb_create_sysfs(dev);</span><br><span class="line">    dev-&gt;ctrl-&gt;init(dev);   //(11)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>(1) 为lcd控制器分配 framebuffer 结构体 fb_info；</p></li><li><p>(2) 读取设备树中lcd id，从前面设备树的信息lcd0来看，id = 0；</p></li><li><p>(3) <code>sprdfb_dispc_ctrl</code> 保存为Soc显示控制器的操作接口；</p></li><li><p>(4) 获取设备树中配置的寄存器地址信息。</p></li><li><p>(5) <code>sprdfb_panel_get</code> 会调用<code>adapt_panel_from_uboot</code>遍历模组链表 <code>panel_list_main</code> 中 panel_cfg，将lcd_id 和 uboot中读取的模组芯片id进行对比，如果匹配则返回对应的panel_cfg；如果没有匹配，会再后续的流程中调用<code>sprdfb_panel_probe</code>重新加载模组驱动。这期间会设置 <strong>DISPC</strong> 的dsi硬件配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct panel_spec *adapt_panel_from_readid(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct panel_cfg *cfg;</span><br><span class="line">    struct list_head *panel_list;</span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(6) <code>sprdfb_dispc_logo_proc</code> 按照panel_cfg的尺寸申请缓存区，并从uboot lcd_base中拷贝logo数据；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void sprdfb_dispc_logo_proc(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">uint32_t kernel_fb_size = 0;</span><br><span class="line">uint32_t logo_src_v = 0;</span><br><span class="line">uint32_t logo_dst_v = 0;//use the second frame buffer,virtual</span><br><span class="line">uint32_t logo_dst_p = 0;//use the second frame buffer ,physical</span><br><span class="line">uint32_t logo_size = 0;// should be rgb565</span><br><span class="line"></span><br><span class="line">if(dev == NULL) &#123;</span><br><span class="line">printk(&quot;sprdfb: %s[%d]: dev == NULL, return without process logo!!\n&quot;,__func__,__LINE__);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(lcd_base_from_uboot == 0) &#123;</span><br><span class="line">printk(&quot;sprdfb: %s[%d]: lcd_base_from_uboot == 0, return without process logo!!\n&quot;,__func__,__LINE__);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(SPRDFB_PANEL_IF_DPI != dev-&gt;panel_if_type)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">    logo_size = dev-&gt;panel-&gt;width * dev-&gt;panel-&gt;height * 2;// should be rgb565</span><br><span class="line"></span><br><span class="line">dev-&gt;logo_buffer_size = logo_size;</span><br><span class="line">dev-&gt;logo_buffer_addr_v = __get_free_pages(GFP_ATOMIC | __GFP_ZERO , get_order(logo_size));</span><br><span class="line"></span><br><span class="line">logo_dst_v = dev-&gt;logo_buffer_addr_v;</span><br><span class="line">logo_dst_p = __pa(dev-&gt;logo_buffer_addr_v);</span><br><span class="line"></span><br><span class="line">    logo_src_v =  (uint32_t)ioremap(lcd_base_from_uboot, logo_size);</span><br><span class="line"></span><br><span class="line">memcpy(logo_dst_v, logo_src_v, logo_size);</span><br><span class="line">dma_sync_single_for_device(dev, logo_dst_p, logo_size, DMA_TO_DEVICE);</span><br><span class="line"></span><br><span class="line">iounmap(logo_src_v);</span><br><span class="line">    </span><br><span class="line">dispc_write(logo_dst_p, DISPC_OSD_BASE_ADDR);</span><br><span class="line">sprdfb_dispc_refresh_logo(dev);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int32_t sprdfb_dispc_refresh_logo (struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">dispc_clear_bits(0x1f, DISPC_INT_EN);//disable all interrupt</span><br><span class="line">dispc_set_bits(0x1f, DISPC_INT_CLR);// clear all interruption</span><br><span class="line">dispc_set_bits(BIT(5), DISPC_DPI_CTRL);//update</span><br><span class="line"></span><br><span class="line">//wait for update- done interruption</span><br><span class="line">for(i=0; i&lt;500; i++) &#123;</span><br><span class="line">if(!(dispc_read(DISPC_INT_RAW) &amp; (0x10)))&#123;</span><br><span class="line">udelay(1000);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    if(i &gt;= 500) &#123;</span><br><span class="line">        printk(&quot;sprdfb: [%s] wait dispc done int time out!! (0x%x)\n&quot;, __func__, dispc_read(DISPC_INT_RAW));</span><br><span class="line">    &#125;</span><br><span class="line">dispc_set_bits((1&lt;&lt;5), DISPC_INT_CLR);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(7) sprdfb_dispc_early_init 恢复使能 <strong>DISPC</strong> 模组；</p></li><li><p>(8) setup_fb_mem 解析设备树“sprd,fb_mem”配置 fb_info screen_base等参数</p></li><li><p>(9) setup_fb_info 进一步配置 fb_info，设置固定参数和可变参数；   </p></li><li><p>(10) register_framebuffer 向内核注册帧缓冲区；</p></li><li><p>(11) sprdfb_dispc_init 设置 <strong>DISPC</strong> 的dithering 和 osd layer blending功能。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>针对lcd驱动调试的一些总结：</p><ul><li>背光不亮</li></ul><blockquote><p>通常直接排查硬件，检查背光电压，pwm波形输出等</p></blockquote><ul><li>白屏显示</li></ul><blockquote><p>1.优先检查电压，一般液晶模组在完成初始化后，VGH/VGL经过charge pump，基本能够达到正负15v左右。</p></blockquote><blockquote><p>2.读取模组id，优先检查硬件接口是否有误，然后排查软件接口的设置，可通过示波器辅助快速定位。</p></blockquote><blockquote><p>3.检查是否初始化代码有误，存在模组代码不匹配的情况。</p></blockquote><ul><li>显示异常</li></ul><blockquote><p>1.优先排查硬件，曾经有遇到过BB的VDD输出2.8V，DVDD输出1.8v，但是模组内部将VDD/DVDD相连，直接导致初始化升压不够，显示异常。</p></blockquote><blockquote><p>2.检查分辨率、像素、时序配置和proch设定是否存在问题。</p></blockquote><blockquote><p>3.画面撕裂问题，一般需要开启TE，BB会在每帧数据开始前发送信号同步。</p></blockquote><blockquote><p>4.画面翻转问题，一般修改模组初始化代码，修改显示刷新方向解决。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。&lt;/p&gt;
&lt;p&gt;本文基于Android 4.4代码分析sc7731 lcd的基本流程。&lt;/p&gt;
&lt;h1 id=&quot;显示系统&quot;&gt;&lt;a href=&quot;#显示系统&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="android" scheme="http://tinylaker.github.io/categories/android/"/>
    
    
      <category term="lcd" scheme="http://tinylaker.github.io/tags/lcd/"/>
    
  </entry>
  
  <entry>
    <title>terminal for microcontrol</title>
    <link href="http://tinylaker.github.io/2019/09/30/terminal-for-microcontrol/"/>
    <id>http://tinylaker.github.io/2019/09/30/terminal-for-microcontrol/</id>
    <published>2019-09-30T08:05:40.000Z</published>
    <updated>2019-10-06T07:34:16.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>此前的嵌入式项目开发过程中，因为硬件资源紧张，硬件工程师在进行原理图设计的时候没有使用芯片的串口，导致软件开发和调试极为困难。后来考虑使用USB CDC虚拟串口搭配命令行控制台进行调试，在gayhub上发现了这个开源的命令行控制项目 <a href="git@github.com:JingoC/terminal.git">Terminal</a></p><h1 id="Terminal简介"><a href="#Terminal简介" class="headerlink" title="Terminal简介"></a>Terminal简介</h1><p><code>Terminal</code> 支持跨平台、可选配置、日志命令、指令中断、回车和删除等常用按键配置，最大耗费系统内存不到10KB。</p><p>代码的目录结构如下，</p><ul><li><code>lib</code> 中包含自定义的字符串和队列操作。</li><li><code>module</code> 中包含对input解析和log的相关操作。</li><li><code>terminal.h</code> 和 <code>terminal.c</code> 实现了命令行控制台的基本功能，包括初始化、命令添加、命令执行、命令解析等API，供用户直接使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terminal # ls </span><br><span class="line">LICENSE    README.md  def_config examples   lib        module     terminal.c terminal.h</span><br><span class="line">terminal # ls def_config</span><br><span class="line">terminal_config.h</span><br><span class="line">terminal # ls lib</span><br><span class="line">cli_queue.c  cli_queue.h  cli_string.c cli_string.h</span><br><span class="line">terminal #</span><br><span class="line">terminal # ls module</span><br><span class="line">cli_input.c cli_input.h cli_log.c   cli_log.h   cli_time.c  cli_time.h</span><br></pre></td></tr></table></figure><h1 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h1><p>参考 <code>examples/Coocox_stm32f4</code>的工程代码和<code>README.md</code>，对当前工程添加自定义配置文件 <code>terminal_config.h</code>。</p><ul><li>使能 <code>TERM_TX_RX_EN</code> 开启输入输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TERM_TX_RX_EN  (1)    // Terminal Printf (without this don,t work)</span><br></pre></td></tr></table></figure><ul><li>复写 <code>CLI_Printf</code> 和 <code>CLI_PutChar</code> 输出函数，实现输出重定向</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#if (TERM_TX_RX_EN == 1)</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define COM_Printf(...)     printf(__VA_ARGS__)</span><br><span class="line">#define CLI_Printf          COM_Printf</span><br><span class="line">#if (ECHO_EN == 1)</span><br><span class="line">#define CLI_PutChar     putchar</span><br><span class="line">#else   // ECHO_EN != 1</span><br><span class="line">#define CLI_PutChar</span><br><span class="line">#endif  // ECHO_EN == 1</span><br><span class="line"></span><br><span class="line">#else   // TERM_TX_RX_EN != 1</span><br><span class="line">#define CLI_Printf</span><br><span class="line">#define CLI_PutChar</span><br><span class="line">#endif  // TERM_TX_RX_EN == 1</span><br></pre></td></tr></table></figure><ul><li>设置基本参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define TERM_SIZE_TASK        (20)    // Max number of commands</span><br><span class="line">#define TERM_CMD_BUF_SIZE     (60)    // Max number of character buffer string command</span><br><span class="line">#define TERM_CMD_LOG_SIZE     (10)    // Max number of loging command</span><br><span class="line">#define TERM_ARGS_BUF_SIZE    (10)    // Max number of arguments in one command</span><br><span class="line">#define TERM_ARG_SIZE         (15)    // Max number character of one arguments</span><br></pre></td></tr></table></figure></li></ul><p>另外可以使用 <code>CLI_AddCmd</code> 接口添加自定义命令，<code>CLI_GetArg</code>接口获取参数，参考<code>my_test_commands</code>目录下的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static uint8_t _t1_cmd();</span><br><span class="line">static uint8_t _t2_cmd();</span><br><span class="line"></span><br><span class="line">void MyTestCmds_Init()</span><br><span class="line">&#123;</span><br><span class="line">    CLI_AddCmd(&quot;t1&quot;, _t1_cmd, 1, TMC_PrintStartTime | TMC_PrintStopTime, &quot;t1 - description command&quot;);</span><br><span class="line">    CLI_AddCmd(&quot;t2&quot;, _t2_cmd, 0, TMC_PrintDiffTime, &quot;t2 - description command&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ***************** implementation commands ****************</span><br><span class="line"></span><br><span class="line">uint8_t _t1_cmd()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t a = 0x01;</span><br><span class="line">    uint32_t b = 0x10;</span><br><span class="line">    uint32_t c = 7;</span><br><span class="line"></span><br><span class="line">    // be sure arguments</span><br><span class="line">    c = CLI_GetArgDec(0);</span><br><span class="line"></span><br><span class="line">    // optional arguments</span><br><span class="line">    CLI_GetArgHexByFlag(&quot;-a&quot;, &amp;a);</span><br><span class="line">    CLI_GetArgHexByFlag(&quot;-b&quot;, &amp;b);</span><br><span class="line"></span><br><span class="line">    CLI_Printf(&quot;\r\na: 0x%08X\r\nb: 0x%08X\r\nc: %d&quot;, (int) a, (int) b, (int) c);</span><br><span class="line"></span><br><span class="line">    return TE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t _t2_cmd()</span><br><span class="line">&#123;</span><br><span class="line">    CLI_Printf(&quot;\r\nPress ESC&quot;);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        CLI_CheckAbort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>已经移植好的固件，在PC上枚举出虚拟串口，使用minicom打开对应串口设备，能够看到如下的相关打印信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ minicom -D /dev/tty.usbmodem3079385933364</span><br><span class="line"></span><br><span class="line">Welcome to minicom 2.7.1</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">Compiled on Aug 20 2018, 10:22:42.</span><br><span class="line">Port /dev/tty.usbmodem3079385933364, 11:38:42</span><br><span class="line"></span><br><span class="line">Press Meta-Z for help on special keys</span><br><span class="line"></span><br><span class="line">****************************************************</span><br><span class="line">|                                                  |</span><br><span class="line">|                   Terminal v1.4                  |</span><br><span class="line">|           sw ver.: Sep 10 2018 22:13:54          |</span><br><span class="line">|                                                  |</span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">Count base command: 4</span><br><span class="line">Max command: 20</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; help</span><br><span class="line">Count command: 4</span><br><span class="line">[] - mandatory argument</span><br><span class="line">&lt;&gt; - optional argument</span><br><span class="line">| - choice between arguments</span><br><span class="line">~          - reset cpu</span><br><span class="line">settime    - set current time</span><br><span class="line">        settime [h] [m] [s]</span><br><span class="line">gettime    - print current time</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;此前的嵌入式项目开发过程中，因为硬件资源紧张，硬件工程师在进行原理图设计的时候没有使用芯片的串口，导致软件开发和调试极为困难
      
    
    </summary>
    
    
      <category term="第三方库" scheme="http://tinylaker.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="Terminal" scheme="http://tinylaker.github.io/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>libusb的使用</title>
    <link href="http://tinylaker.github.io/2019/09/16/libusb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://tinylaker.github.io/2019/09/16/libusb的使用/</id>
    <published>2019-09-16T11:53:55.000Z</published>
    <updated>2019-09-29T14:54:28.338Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅从libusb api-1.0版本的使用方面解读，不详细介绍usb的基本知识和传输协议。</p><h1 id="libusb简介"><a href="#libusb简介" class="headerlink" title="libusb简介"></a>libusb简介</h1><p><strong>libusb</strong> 是一个用来访问usb设备的应用库，可以跨平台使用，支持Linux、Mac、Windows等主流操作系统，当然Andorid上也有libusb身影。</p><p>libusb相关网站：</p><p><strong>github</strong>: <a href="https://github.com/libusb/libusb" target="_blank" rel="noopener">https://github.com/libusb/libusb</a></p><p><strong>homepage</strong>: <a href="https://libusb.info/" target="_blank" rel="noopener">https://libusb.info/</a></p><p><strong>api-1.0</strong>: <a href="http://libusb.sourceforge.net/api-1.0/" target="_blank" rel="noopener">http://libusb.sourceforge.net/api-1.0/</a> </p><p>当产品需要添加自定义协议时，以hid协议为例，usb的固件代码比较容易实现。与此同时，主机也需要对应的协议来正确解析，这里通常有2种实现方式，第一种是在主机编写usb设备驱动解析协议，另一种是应用通过libusb解析协议，显然后一种方法更通用。</p><h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>libusb_init</strong><br>必须最先被执行，完成libusb的初始化。libusb_context代表libusb的会话，如果参数为NULL，会默认创建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_init(libusb_context** context);</span><br></pre></td></tr></table></figure><p><strong>libusb_exit</strong><br>取消libusb初始化，通常在程序结束时调用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_exit(struct libusb_context* ctx)</span><br></pre></td></tr></table></figure><h2 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h2><p><strong>libusb_open</strong><br>打开usb设备，获取设备句柄dev_handle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_open(libusb_device *dev, libusb_device_handle **dev_handle);</span><br></pre></td></tr></table></figure><p><strong>libusb_open_device_with_vid_pid</strong><br>方便快速打开对应pid/vid的设备，可以指定libusb会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libusb_device_handle* libusb_open_device_with_vid_pid(libusb_context *ctx, </span><br><span class="line">    unit16_t vendor_id, uint16_t product_id);</span><br></pre></td></tr></table></figure><p><strong>libusb_close</strong><br>指定设备句柄关闭设备，在程序完成前调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_close(libusb_device_handle *dev_handle);</span><br></pre></td></tr></table></figure><p><strong>libusb_get_device_list</strong><br>获得系统当前所有的usb设备的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t libusb_get_device_list（libusb_context *ctx, libusb_device ***list);</span><br></pre></td></tr></table></figure><p><strong>libusb_free_device_list</strong><br>释放前面使用的设备列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_free_device_list(libusb_device **list, int unref_devices)</span><br></pre></td></tr></table></figure><p><strong>libusb_get_configuration</strong><br>获得当前设备的配置模式，usb设备可能包含多个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int usb_get_configuration(libusb_device_handle *dev_handle, int *config);</span><br></pre></td></tr></table></figure><p><strong>libusb_set_configuration</strong><br>重新设置usb设备的配置模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int usb_set_configuration(libusb_device_handle *dev_handle, int configuration);</span><br></pre></td></tr></table></figure><p><strong>libusb_claim_interface</strong><br>获得usb设备对应接口的所有权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_claim_interface(libusb_device_handle *dev_handle, int interface_number);</span><br></pre></td></tr></table></figure><p><strong>libusb_release_interface</strong><br>释放获取usb设备接口的所有权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_release_interface(libusb_device_handle *dev_handle, int interface_number);</span><br></pre></td></tr></table></figure><p><strong>libusb_set_interface_alt_setting</strong><br>激活某个接口的交替配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_set_interface_alt_setting(libusb_device_handle *dev_handle, int interface_number, int alternate_config);</span><br></pre></td></tr></table></figure><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p><strong>libusb_control_transfer</strong><br>控制传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_control_transfer (libusb_device_handle *dev_handle, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, unsigned char *data, uint16_t wLength, unsigned int timeout);</span><br></pre></td></tr></table></figure><p><strong>libusb_bulk_transfer</strong><br>批量传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_bulk_transfer (struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout);</span><br></pre></td></tr></table></figure><p><strong>libusb_interrupt_transfer</strong><br>中断传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_interrupt_transfer (struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout);</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面的例子，是打开vid = 1234， pid = 5678的usb设备，同时检查是否有接口0的驱动，如果有直接卸载这个驱动，并获取这个接口的所有权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">libusb_context *ctx;</span><br><span class="line">libusb_device_handle* handle = NULL;  /* handle for USB device */</span><br><span class="line"></span><br><span class="line">/* Initialise libusb. */</span><br><span class="line">ret = libusb_init(&amp;ctx);</span><br><span class="line">if (ret != 0)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Error initialising libusb.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /* Open device with vid and pid */</span><br><span class="line">handle = libusb_open_device_with_vid_pid(0, 1234, 5678);</span><br><span class="line">if (!handle)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Unable to open device.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Check whether a kernel driver is attached to interface #0. If so, we&apos;ll</span><br><span class="line">* need to detach it.</span><br><span class="line">*/</span><br><span class="line">if (libusb_kernel_driver_active(handle, 0)) &#123;</span><br><span class="line">ret = libusb_detach_kernel_driver(handle, 0);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">fprintf(stderr, &quot;Error detaching kernel driver.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Claim interface #0. */</span><br><span class="line">ret = libusb_claim_interface(handle, 0);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">fprintf(stderr, &quot;Error claiming interface.\n&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅从libusb api-1.0版本的使用方面解读，不详细介绍usb的基本知识和传输协议。&lt;/p&gt;
&lt;h1 id=&quot;libusb简介&quot;&gt;&lt;a href=&quot;#libusb简介&quot; class=&quot;headerlink&quot; title=&quot;libusb简介&quot;&gt;&lt;/a&gt;libusb简
      
    
    </summary>
    
    
      <category term="第三方库" scheme="http://tinylaker.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="libusb" scheme="http://tinylaker.github.io/tags/libusb/"/>
    
  </entry>
  
  <entry>
    <title>cJSON的使用</title>
    <link href="http://tinylaker.github.io/2019/09/15/cJSON%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://tinylaker.github.io/2019/09/15/cJSON的使用/</id>
    <published>2019-09-14T17:41:47.000Z</published>
    <updated>2019-09-16T08:30:36.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JSON格式"><a href="#1-JSON格式" class="headerlink" title="1. JSON格式"></a>1. JSON格式</h1><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。同时也易于机器解析和生成。</p><p>JSON建构于两种结构：<br><strong>键值对的集合（A collection of name/value pairs）</strong><br><strong>值的有序列表（An ordered list of values）</strong></p><h1 id="2-cJSON"><a href="#2-cJSON" class="headerlink" title="2. cJSON"></a>2. cJSON</h1><p>c语言中处理json格式的数据，可以借助于cJSON函数库，简单且效率高。</p><p>cJSON的开源仓库地址： <a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="noopener">https://github.com/DaveGamble/cJSON</a></p><p>cJSON.h定义了结构体cJSON来描述JSON对象，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct cJSON</span><br><span class="line">&#123;</span><br><span class="line">    /* 对象或数组链表的前后节点 */</span><br><span class="line">    struct cJSON *next;</span><br><span class="line">    struct cJSON *prev;</span><br><span class="line">    /* 对象火数组链表的子节点 */</span><br><span class="line">    struct cJSON *child;</span><br><span class="line"></span><br><span class="line">    /* 键值的类型 */</span><br><span class="line">    int type;</span><br><span class="line"></span><br><span class="line">    /* 保存键值字符串 */</span><br><span class="line">    char *valuestring;</span><br><span class="line"></span><br><span class="line">    int valueint;</span><br><span class="line">    double valuedouble;</span><br><span class="line"></span><br><span class="line">    /* 保存键值的名字 */</span><br><span class="line">    char *string;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure><h2 id="2-1-cJSON-API"><a href="#2-1-cJSON-API" class="headerlink" title="2.1 cJSON API"></a>2.1 cJSON API</h2><h3 id="2-1-1-cJSON-Parse"><a href="#2-1-1-cJSON-Parse" class="headerlink" title="2.1.1 cJSON_Parse"></a>2.1.1 cJSON_Parse</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 解析JSON格式数据，按照cJSON结构进行序列化</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_Parse(const char *value)</span><br></pre></td></tr></table></figure><h3 id="2-1-2-cJSON-Print"><a href="#2-1-2-cJSON-Print" class="headerlink" title="2.1.2 cJSON_Print"></a>2.1.2 cJSON_Print</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 解析cJSON格式数据，转换成JSON格式的字符串</span><br><span class="line"> * @ret: 成功返回指向内存块中JSON字符串的地址，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(char *) cJSON_Print(const cJSON *item)</span><br></pre></td></tr></table></figure><h3 id="2-1-3-cJSON-Delete"><a href="#2-1-3-cJSON-Delete" class="headerlink" title="2.1.3 cJSON_Delete"></a>2.1.3 cJSON_Delete</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * @func: 删除释放cJSON及其子节点。</span><br><span class="line"> * @ret:</span><br><span class="line"> */</span><br><span class="line">(void) cJSON_Delete(cJSON *item)</span><br></pre></td></tr></table></figure><h3 id="2-1-4-cJSON-CreateObject"><a href="#2-1-4-cJSON-CreateObject" class="headerlink" title="2.1.4 cJSON_CreateObject"></a>2.1.4 cJSON_CreateObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 创建新的cJSON对象</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_CreateObject(void)</span><br></pre></td></tr></table></figure><h3 id="2-1-5-cJSON-GetObjectItem"><a href="#2-1-5-cJSON-GetObjectItem" class="headerlink" title="2.1.5 cJSON_GetObjectItem"></a>2.1.5 cJSON_GetObjectItem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 获取JSON字符串字段值</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)</span><br></pre></td></tr></table></figure><h2 id="2-2-如何解析JSON格式"><a href="#2-2-如何解析JSON格式" class="headerlink" title="2.2 如何解析JSON格式"></a>2.2 如何解析JSON格式</h2><p>以github仓库README.md中JSON数据为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Awesome 4K&quot;,</span><br><span class="line">    &quot;resolutions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 1280,</span><br><span class="line">            &quot;height&quot;: 720</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 1920,</span><br><span class="line">            &quot;height&quot;: 1080</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 3840,</span><br><span class="line">            &quot;height&quot;: 2160</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-转换JSON格式为cJSON"><a href="#2-2-1-转换JSON格式为cJSON" class="headerlink" title="2.2.1 转换JSON格式为cJSON"></a>2.2.1 转换JSON格式为cJSON</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cJSON *monitor_json = cJSON_Parse(monitor);</span><br><span class="line">if (monitor_json == NULL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-解析字符串数据"><a href="#2-2-2-解析字符串数据" class="headerlink" title="2.2.2 解析字符串数据"></a>2.2.2 解析字符串数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = cJSON_GetObjectItemCaseSensitive(monitor_json, &quot;name&quot;);</span><br><span class="line">if (cJSON_IsString(name) &amp;&amp; (name-&gt;valuestring != NULL))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-解析数组数据"><a href="#2-2-3-解析数组数据" class="headerlink" title="2.2.3 解析数组数据"></a>2.2.3 解析数组数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolutions = cJSON_GetObjectItemCaseSensitive(monitor_json, &quot;resolutions&quot;);</span><br><span class="line">cJSON_ArrayForEach(resolution, resolutions)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *width = cJSON_GetObjectItemCaseSensitive(resolution, &quot;width&quot;);</span><br><span class="line">    cJSON *height = cJSON_GetObjectItemCaseSensitive(resolution, &quot;height&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-释放内存"><a href="#2-2-4-释放内存" class="headerlink" title="2.2.4 释放内存"></a>2.2.4 释放内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_Delete(monitor_json);</span><br></pre></td></tr></table></figure><h2 id="2-3-如何生成JSON格式"><a href="#2-3-如何生成JSON格式" class="headerlink" title="2.3 如何生成JSON格式"></a>2.3 如何生成JSON格式</h2><h3 id="2-3-1-创建cJSON结构体"><a href="#2-3-1-创建cJSON结构体" class="headerlink" title="2.3.1 创建cJSON结构体"></a>2.3.1 创建cJSON结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON *monitor = cJSON_CreateObject();</span><br></pre></td></tr></table></figure><h3 id="2-3-2-添加字符串数据"><a href="#2-3-2-添加字符串数据" class="headerlink" title="2.3.2 添加字符串数据"></a>2.3.2 添加字符串数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_AddStringToObject(monitor, &quot;name&quot;, &quot;Awesome 4K&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-3-3-添加数组数据"><a href="#2-3-3-添加数组数据" class="headerlink" title="2.3.3 添加数组数据"></a>2.3.3 添加数组数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resolutions = cJSON_AddArrayToObject(monitor, &quot;resolutions&quot;);</span><br><span class="line"></span><br><span class="line">for (index = 0; index &lt; (sizeof(resolution_numbers) / (2 * sizeof(int))); ++index)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *resolution = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line">    if (cJSON_AddNumberToObject(resolution, &quot;width&quot;, resolution_numbers[index][0]) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cJSON_AddNumberToObject(resolution, &quot;height&quot;, resolution_numbers[index][1]) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cJSON_AddItemToArray(resolutions, resolution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-格式化JSON数据"><a href="#2-3-4-格式化JSON数据" class="headerlink" title="2.3.4 格式化JSON数据"></a>2.3.4 格式化JSON数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *string = cJSON_Print(monitor);</span><br></pre></td></tr></table></figure><h3 id="2-3-5-释放内存"><a href="#2-3-5-释放内存" class="headerlink" title="2.3.5 释放内存"></a>2.3.5 释放内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cJSON_free(string);</span><br><span class="line">cJSON_Delete(monitor);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-JSON格式&quot;&gt;&lt;a href=&quot;#1-JSON格式&quot; class=&quot;headerlink&quot; title=&quot;1. JSON格式&quot;&gt;&lt;/a&gt;1. JSON格式&lt;/h1&gt;&lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换
      
    
    </summary>
    
    
      <category term="第三方库" scheme="http://tinylaker.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="cJSON" scheme="http://tinylaker.github.io/tags/cJSON/"/>
    
  </entry>
  
</feed>
