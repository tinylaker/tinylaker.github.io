<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tinylaker blog</title>
  
  <subtitle>stay hungry stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tinylaker.github.io/"/>
  <updated>2019-12-06T14:26:43.203Z</updated>
  <id>http://tinylaker.github.io/</id>
  
  <author>
    <name>tinylaker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gtest测试框架使用</title>
    <link href="http://tinylaker.github.io/2019/12/06/gtest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://tinylaker.github.io/2019/12/06/gtest测试框架使用/</id>
    <published>2019-12-06T12:44:52.000Z</published>
    <updated>2019-12-06T14:26:43.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实际项目开发过程中，需要进行必要的单元测试，以保证代码开发阶段的功能性。这里简单介绍下 google 跨平台的c++单元测试框架 gtest。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>gtest 编译需要 cmake 支持，安装步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/google/googletest.git</span><br><span class="line">$ cd googletest/</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build/</span><br><span class="line">$ cmake ..</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>gtest 提供了TEST()宏，用来定义测试函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEST(test_suite_name, test_case_name) </span><br><span class="line">&#123;</span><br><span class="line">    // test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试函数中，gtest 提供了EXPECT_和ASSERT_两种风格的断言。如果ASSERT_执行失败了，会导致测试函数立即返回；但EXPECT_如果执行失败了，并不会导致测试函数返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEST(MyTest, Add) </span><br><span class="line">&#123;</span><br><span class="line">    EXPECT_EQ(1 + 1, 2);</span><br><span class="line">    ASSERT_EQ(1 + 1, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写简单的测试用例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;gtest/gtest.h&gt;</span><br><span class="line"></span><br><span class="line">int add(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(Demo, add) &#123;</span><br><span class="line">    EXPECT_EQ(add(1, 2), 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    testing::InitGoogleTest(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">    return RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CMakeLists.txt</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 3.2)</span><br><span class="line"></span><br><span class="line">project(mytest)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -std=c++11 -Wall&quot;)</span><br><span class="line"></span><br><span class="line">find_package(GTest REQUIRED)</span><br><span class="line">find_package(Threads REQUIRED)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;GTEST_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(mytest test.cpp)</span><br><span class="line">target_link_libraries(mytest $&#123;GTEST_BOTH_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(mytest $&#123;CMAKE_THREAD_LIBS_INIT&#125;)</span><br><span class="line"></span><br><span class="line">add_test(Test mytest)</span><br><span class="line">enable_testing()</span><br></pre></td></tr></table></figure><ul><li><p>执行测试用例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ make test</span><br><span class="line">Running tests...</span><br><span class="line">Test project /work/temp/gtest-demo/build</span><br><span class="line">    Start 1: Test</span><br><span class="line">1/1 Test #1: Test .............................   Passed    0.00 sec</span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 1</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.00 sec</span><br></pre></td></tr></table></figure></li><li><p>samples</p></li></ul><p>gtest 的源码中包含很多测试 samples，并且在 docs 中有简短的说明，以 sample1 为例，实现了阶乘和质数的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.</span><br><span class="line">int Factorial(int n) &#123;</span><br><span class="line">  int result = 1;</span><br><span class="line">  for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    result *= i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应阶乘方法的单元测试用例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Tests factorial of negative numbers.</span><br><span class="line">TEST(FactorialTest, Negative) &#123;</span><br><span class="line">  EXPECT_EQ(1, Factorial(-5));</span><br><span class="line">  EXPECT_EQ(1, Factorial(-1));</span><br><span class="line">  EXPECT_GT(Factorial(-10), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Tests factorial of 0.</span><br><span class="line">TEST(FactorialTest, Zero) &#123;</span><br><span class="line">  EXPECT_EQ(1, Factorial(0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Tests factorial of positive numbers.</span><br><span class="line">TEST(FactorialTest, Positive) &#123;</span><br><span class="line">  EXPECT_EQ(1, Factorial(1));</span><br><span class="line">  EXPECT_EQ(2, Factorial(2));</span><br><span class="line">  EXPECT_EQ(6, Factorial(3));</span><br><span class="line">  EXPECT_EQ(40320, Factorial(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 samples 需要指定编译选项 <code>cmake -Dgtest_build_samples=ON ${GTEST_DIR}</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./sample1_unittest</span><br><span class="line">Running main() from /work/googletest/googletest/src/gtest_main.cc</span><br><span class="line">[==========] Running 6 tests from 2 test suites.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 3 tests from FactorialTest</span><br><span class="line">[ RUN      ] FactorialTest.Negative</span><br><span class="line">[       OK ] FactorialTest.Negative (0 ms)</span><br><span class="line">[ RUN      ] FactorialTest.Zero</span><br><span class="line">[       OK ] FactorialTest.Zero (0 ms)</span><br><span class="line">[ RUN      ] FactorialTest.Positive</span><br><span class="line">[       OK ] FactorialTest.Positive (0 ms)</span><br><span class="line">[----------] 3 tests from FactorialTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] 3 tests from IsPrimeTest</span><br><span class="line">[ RUN      ] IsPrimeTest.Negative</span><br><span class="line">[       OK ] IsPrimeTest.Negative (0 ms)</span><br><span class="line">[ RUN      ] IsPrimeTest.Trivial</span><br><span class="line">[       OK ] IsPrimeTest.Trivial (0 ms)</span><br><span class="line">[ RUN      ] IsPrimeTest.Positive</span><br><span class="line">[       OK ] IsPrimeTest.Positive (0 ms)</span><br><span class="line">[----------] 3 tests from IsPrimeTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 6 tests from 2 test suites ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 6 tests.</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用 gtest 可以快速进行单元测试编写，验证软件开发过程中的问题，是软件开发中不可缺少的环节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在实际项目开发过程中，需要进行必要的单元测试，以保证代码开发阶段的功能性。这里简单介绍下 google 跨平台的c++单元测试框架 gtes
      
    
    </summary>
    
    
      <category term="tools" scheme="http://tinylaker.github.io/categories/tools/"/>
    
    
      <category term="gtest" scheme="http://tinylaker.github.io/tags/gtest/"/>
    
  </entry>
  
  <entry>
    <title>Android图像系统之一</title>
    <link href="http://tinylaker.github.io/2019/12/05/Android%E5%9B%BE%E5%83%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80/"/>
    <id>http://tinylaker.github.io/2019/12/05/Android图像系统之一/</id>
    <published>2019-12-05T04:06:23.000Z</published>
    <updated>2019-12-06T12:44:05.822Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于Android P源码分析，深入理解Android GUI的框架。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android图像系统框架比较复杂，涉及WindowManager、SurfaceFlinger、ActivityManager、InputManager等模块。因为笔者此前从事过底层显示驱动相关工作，期望通过梳理Android显示系统的框架构建完整的知识体系。</p><p>它们之间的关系如下：<br><img src="//tinylaker.github.io/2019/12/05/Android图像系统之一/GUI.png" alt="GUI"></p><h1 id="图形框架"><a href="#图形框架" class="headerlink" title="图形框架"></a>图形框架</h1><blockquote><p>参考 <a href="https://source.android.com/devices/graphics" target="_blank" rel="noopener">https://source.android.com/devices/graphics</a></p></blockquote><p>Android框架提供各种 2D 和 3D 图形渲染的 API，应用开发者可以通过 Canvas、OpenGL ES 和 Vulkan 三种方式将图像绘制到屏幕上。但无论开发者使用什么渲染 API，最终都会渲染到 Surface。Surface 表示缓冲队列中的生产者，每个 Window 都对应者一个或多个 Surface，而缓冲队列的消费者通常是 SurfaceFlinger，用以合成到显示部分，比如自身屏幕或者扩展屏幕。</p><p><img src="//tinylaker.github.io/2019/12/05/Android图像系统之一/Surface.png" alt="Surface"></p><ul><li><p>IMAGE STREAM PRODUCERS: 可以生成图形缓冲区以供消耗的任何内容，比如OpenGL ES、Canvas 2D 和 mediaserver 视频解码器。</p></li><li><p>IMAGE STREAM CONSUMERS: 最常见的消费者就是 SurfaceFlinger，它是可以修改所显示部分内容的唯一服务，使用 OpenGL 和 Hardware Composer 来合成一组 Surface. 还有其他应用也可以作为消费者，比如相机应用和 ImageReader.</p></li><li><p>Hardware Composer: 作为显示子系统的硬件抽象层，完成SurfaceFlinger 合成显示的部分任务，以分担 OpenGL 和 GPU 的消耗。同时需要支持 Vsync Event 和 HDMI 的热插拔。</p></li><li><p>Gralloc HAL: 用来分配图像生产者所请求的内存。</p></li></ul><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><p><img src="//tinylaker.github.io/2019/12/05/Android图像系统之一/BufferQueue.png" alt="BufferQueue"></p><p>左侧黄色部分为图像缓冲区的生产者，比如状态栏、菜单栏和主界面等。SurfaceFlinger 完成 Surface 的合成，Hardware Composer 操作硬件控制器显示。</p><h2 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h2><p>BufferQueue 是 Android 图像系统的重要组成部分，是缓冲区和队列结合的数据结构，通过Binder IPC在进程间传递。</p><p><img src="//tinylaker.github.io/2019/12/05/Android图像系统之一/BufferQueue2.png" alt="BufferQueue2"></p><p>上图描述了图像生产者和消费者的操作流程：</p><ul><li>生产者请求队列中空闲的缓冲区：dequeueBuffer()</li><li>生产者填充缓冲区并添加到队列：queueBuffer()</li><li>消费者从队列中获取缓冲区：acquireBuffer()</li><li>消费者使用完毕返回给队列：releaseBuffer()</li></ul><p>对应类图的关系如下：<br><img src="//tinylaker.github.io/2019/12/05/Android图像系统之一/BufferQueue3.png" alt="BufferQueue3"></p><h1 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h1><p>SurfaceFlinger 是一个本地系统服务，用来合成应用绘制的 Surface，借助 Hardware Composer 显示到屏幕上。</p><p>[surfaceflinger.rc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    class core animation</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc readproc</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/stune/foreground/tasks</span><br><span class="line">    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0       socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0</span><br><span class="line">    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s</span><br></pre></td></tr></table></figure><p>[main_surfaceflinger.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int main(int, char**) &#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    hardware::configureRpcThreadpool(1 /* maxThreads */,</span><br><span class="line">            false /* callerWillJoin */);</span><br><span class="line"></span><br><span class="line">    startGraphicsAllocatorService();</span><br><span class="line"></span><br><span class="line">    // When SF is launched in its own process, limit the number of</span><br><span class="line">    // binder threads to 4.</span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);</span><br><span class="line"></span><br><span class="line">    // start the thread pool</span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    // instantiate surfaceflinger</span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = new SurfaceFlinger();</span><br><span class="line"></span><br><span class="line">    setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    set_sched_policy(0, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    // Put most SurfaceFlinger threads in the system-background cpuset</span><br><span class="line">    // Keeps us from unnecessarily using big cores</span><br><span class="line">    // Do this after the binder thread pool init</span><br><span class="line">    if (cpusets_enabled()) set_cpuset_policy(0, SP_SYSTEM);</span><br><span class="line"></span><br><span class="line">    // initialize before clients can connect</span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    // publish surface flinger</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false,</span><br><span class="line">                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line"></span><br><span class="line">    // publish GpuService</span><br><span class="line">    sp&lt;GpuService&gt; gpuservice = new GpuService();</span><br><span class="line">    sm-&gt;addService(String16(GpuService::SERVICE_NAME), gpuservice, false);</span><br><span class="line"></span><br><span class="line">    startDisplayService(); // dependency on SF getting registered above</span><br><span class="line"></span><br><span class="line">    struct sched_param param = &#123;0&#125;;</span><br><span class="line">    param.sched_priority = 2;</span><br><span class="line">    if (sched_setscheduler(0, SCHED_FIFO, &amp;param) != 0) &#123;</span><br><span class="line">        ALOGE(&quot;Couldn&apos;t set SCHED_FIFO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // run surface flinger in this thread</span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger 类继承于 BnSurfaceComposer，实现 ISurfaceComposer 本地接口。Android P 版本从 SurfaceFlinger 类中拆分出 SurfaceFlingerBE，实现前后端分离，前端和上层进行交互，后端 SurfaceFlingerBE 和底层硬件合成进行交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SurfaceFlinger : public BnSurfaceComposer,</span><br><span class="line">                       public PriorityDumper,</span><br><span class="line">                       private IBinder::DeathRecipient,</span><br><span class="line">                       private HWC2::ComposerCallback</span><br></pre></td></tr></table></figure><p>具体的类图关系如下图：</p><p>后面我们将以 SurfaceFlinger 为主线，结合源代码进行情景分析，梳理整个图像系统。</p><ul><li>WindowManager: 首先需要知道 Surface 是由谁创建的？是如何绘制和更新的，窗口的动画切换是怎样做的？窗口的显示和隐藏是如何控制的？</li><li>SurfaceFlinger: Surface 使用的图像缓冲区是什么时候创建、管理和销毁的？多个 Surface 是如何合成的？如何实现多屏显示的？</li><li>Activity: Activity 的生命周期是怎样的？</li><li>InputManager: 底层按键事件是如何上报到Android系统的，又是如何到具体的窗口进行处理的？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于Android P源码分析，深入理解Android GUI的框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://tinylaker.github.io/categories/Android/"/>
    
    
      <category term="GUI" scheme="http://tinylaker.github.io/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>Android智能指针</title>
    <link href="http://tinylaker.github.io/2019/11/27/Android%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://tinylaker.github.io/2019/11/27/Android智能指针/</id>
    <published>2019-11-27T14:31:14.000Z</published>
    <updated>2019-12-05T13:07:53.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于Android P源码分析，加深对RefBase、sp、wp的理解。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android源码中存在大量C++代码，里面涉及智能指针的使用，除了标准库的std::shared_ptr和std::weak_ptr，还有sp/wp搭配RefBase通过强弱引用计数实现对c++对象回收机制的管理。</p><p>相关代码位于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system/core/libutils/include/utils/RefBase.h</span><br><span class="line">/system/core/libutils/include/util/StrongPointer.h</span><br><span class="line">system/core/libutils/RefBase.cpp</span><br><span class="line">system/core/libutils/StrongPointer.cpp</span><br></pre></td></tr></table></figure><p>类图关系如下：<br><img src="//tinylaker.github.io/2019/11/27/Android智能指针/Surface.png" alt="Surface"></p><h1 id="sp模板类"><a href="#sp模板类" class="headerlink" title="sp模板类"></a>sp模板类</h1><p>[ StrongPointer.h ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class sp &#123;</span><br><span class="line">public:</span><br><span class="line">    inline sp() : m_ptr(0) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    sp(T* other);  // NOLINT(implicit)</span><br><span class="line">    sp(const sp&lt;T&gt;&amp; other);</span><br><span class="line">    sp(sp&lt;T&gt;&amp;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; sp(U* other);  // NOLINT(implicit)</span><br><span class="line">    template&lt;typename U&gt; sp(const sp&lt;U&gt;&amp; other);  // NOLINT(implicit)</span><br><span class="line">    template&lt;typename U&gt; sp(sp&lt;U&gt;&amp;&amp; other);  // NOLINT(implicit)</span><br><span class="line"></span><br><span class="line">    ~sp();</span><br><span class="line"></span><br><span class="line">    // Assignment</span><br><span class="line">    sp&amp; operator = (T* other);</span><br><span class="line">    sp&amp; operator = (const sp&lt;T&gt;&amp; other);</span><br><span class="line">    sp&amp; operator = (sp&lt;T&gt;&amp;&amp; other);</span><br><span class="line"></span><br><span class="line">    template&lt;typename U&gt; sp&amp; operator = (const sp&lt;U&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; sp&amp; operator = (sp&lt;U&gt;&amp;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; sp&amp; operator = (U* other);</span><br><span class="line"></span><br><span class="line">    //! Special optimization for use by ProcessState (and nobody else).</span><br><span class="line">    void force_set(T* other);</span><br><span class="line"></span><br><span class="line">    // Reset</span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    //指针访问重载</span><br><span class="line">    inline T&amp;       operator* () const     &#123; return *m_ptr; &#125;</span><br><span class="line">    inline T*       operator-&gt; () const    &#123; return m_ptr;  &#125;</span><br><span class="line">    inline T*       get() const            &#123; return m_ptr; &#125;</span><br><span class="line">    inline explicit operator bool () const &#123; return m_ptr != nullptr; &#125;</span><br><span class="line"></span><br><span class="line">    //操作符重载</span><br><span class="line">    COMPARE(==)</span><br><span class="line">    COMPARE(!=)</span><br><span class="line">    COMPARE(&gt;)</span><br><span class="line">    COMPARE(&lt;)</span><br><span class="line">    COMPARE(&lt;=)</span><br><span class="line">    COMPARE(&gt;=)</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    template&lt;typename Y&gt; friend class sp;</span><br><span class="line">    template&lt;typename Y&gt; friend class wp;</span><br><span class="line">    void set_pointer(T* ptr);</span><br><span class="line">    T* m_ptr;   //对应类的指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="sp构造函数和赋值函数"><a href="#sp构造函数和赋值函数" class="headerlink" title="sp构造函数和赋值函数"></a>sp构造函数和赋值函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">sp&lt;T&gt;::sp(T* other)</span><br><span class="line">        : m_ptr(other) &#123;</span><br><span class="line">    if (other)</span><br><span class="line">        other-&gt;incStrong(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">sp&lt;T&gt;::sp(const sp&lt;T&gt;&amp; other)</span><br><span class="line">        : m_ptr(other.m_ptr) &#123;</span><br><span class="line">    if (m_ptr)</span><br><span class="line">        m_ptr-&gt;incStrong(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">sp&lt;T&gt;&amp; sp&lt;T&gt;::operator =(const sp&lt;T&gt;&amp; other) &#123;</span><br><span class="line">    // Force m_ptr to be read twice, to heuristically check for data races.</span><br><span class="line">    T* oldPtr(*const_cast&lt;T* volatile*&gt;(&amp;m_ptr));</span><br><span class="line">    T* otherPtr(other.m_ptr);</span><br><span class="line">    if (otherPtr) otherPtr-&gt;incStrong(this);</span><br><span class="line">    if (oldPtr) oldPtr-&gt;decStrong(this);</span><br><span class="line">    if (oldPtr != *const_cast&lt;T* volatile*&gt;(&amp;m_ptr)) sp_report_race();</span><br><span class="line">    m_ptr = otherPtr;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">sp&lt;T&gt;&amp; sp&lt;T&gt;::operator =(T* other) &#123;</span><br><span class="line">    T* oldPtr(*const_cast&lt;T* volatile*&gt;(&amp;m_ptr));</span><br><span class="line">    if (other) other-&gt;incStrong(this);</span><br><span class="line">    if (oldPtr) oldPtr-&gt;decStrong(this);</span><br><span class="line">    if (oldPtr != *const_cast&lt;T* volatile*&gt;(&amp;m_ptr)) sp_report_race();</span><br><span class="line">    m_ptr = other;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以surfaceflinger服务为例，main_surfaceflinger.cpp中有以下代码，这里既有sp构造函数，又有sp赋值构造函数。其中ProcessState继承于RefBase，所以初始化过程会初始化其父类RefBase。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int, char**) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // start the thread pool</span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RefBase构造函数"><a href="#RefBase构造函数" class="headerlink" title="RefBase构造函数"></a>RefBase构造函数</h1><p>RefBase的构造函数，首先构造weakref_impl对象，这里的this指向当前对象的指针，该对象应该继承于RefBase。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RefBase::RefBase()</span><br><span class="line">    : mRefs(new weakref_impl(this))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weakref-impl"><a href="#weakref-impl" class="headerlink" title="weakref_impl"></a>weakref_impl</h2><p>weakref_impl的成员变量mBase为ProcessState指针，最终会调用目标对象的incStrong()方法，这里是RefBase::incStrong()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">weakref_impl(RefBase* base)</span><br><span class="line">    : mStrong(INITIAL_STRONG_VALUE) //强引用计数 0x10000000</span><br><span class="line">    , mWeak(0)  //弱引用计数为0</span><br><span class="line">    , mBase(base)   //继承类对象的指针</span><br><span class="line">    , mFlags(0)</span><br><span class="line">    , mStrongRefs(NULL)</span><br><span class="line">    , mWeakRefs(NULL)</span><br><span class="line">    , mTrackEnabled(!!DEBUG_REFS_ENABLED_BY_DEFAULT)</span><br><span class="line">    , mRetain(false)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="incStrong"><a href="#incStrong" class="headerlink" title="incStrong"></a>incStrong</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void RefBase::incStrong(const void* id) const</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* const refs = mRefs;</span><br><span class="line">    refs-&gt;incWeak(id);</span><br><span class="line"></span><br><span class="line">    refs-&gt;addStrongRef(id);</span><br><span class="line">    const int32_t c = refs-&gt;mStrong.fetch_add(1, std::memory_order_relaxed);</span><br><span class="line">    ALOG_ASSERT(c &gt; 0, &quot;incStrong() called on %p after last strong ref&quot;, refs);</span><br><span class="line">#if PRINT_REFS</span><br><span class="line">    ALOGD(&quot;incStrong of %p from %p: cnt=%d\n&quot;, this, id, c);</span><br><span class="line">#endif</span><br><span class="line">    if (c != INITIAL_STRONG_VALUE)  &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t old __unused = refs-&gt;mStrong.fetch_sub(INITIAL_STRONG_VALUE, std::memory_order_relaxed);</span><br><span class="line">    // A decStrong() must still happen after us.</span><br><span class="line">    ALOG_ASSERT(old &gt; INITIAL_STRONG_VALUE, &quot;0x%x too small&quot;, old);</span><br><span class="line">    refs-&gt;mBase-&gt;onFirstRef();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用weakref_impl的incWeak()增加的指针弱引用计数，同时增加mStrong指针强引用计数；当首次引用该对象时，回调目标对象的onFirstRef()方法。</p><h2 id="incWeak"><a href="#incWeak" class="headerlink" title="incWeak"></a>incWeak</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void RefBase::weakref_type::incWeak(const void* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);</span><br><span class="line">    impl-&gt;addWeakRef(id);</span><br><span class="line">    const int32_t c __unused = impl-&gt;mWeak.fetch_add(1,</span><br><span class="line">            std::memory_order_relaxed);</span><br><span class="line">    ALOG_ASSERT(c &gt;= 0, &quot;incWeak called on %p after last weak ref&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addWeakRef(const void* id) &#123;</span><br><span class="line">    addRef(&amp;mWeakRefs, id, mWeak.load(std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weakref_impl是weakref_type的子类，首先增加weakref_impl中mWeak的弱引用计数，所以此时mWeak和mStrong引用计数都为1。当sp对象ProcessState退出作用域时，就会调用对应析构函数释放该对象。</p><h1 id="RefBase析构函数"><a href="#RefBase析构函数" class="headerlink" title="RefBase析构函数"></a>RefBase析构函数</h1><h2 id="sp析构函数"><a href="#sp析构函数" class="headerlink" title="sp析构函数"></a>sp析构函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">sp&lt;T&gt;::~sp() &#123;</span><br><span class="line">    if (m_ptr)</span><br><span class="line">        m_ptr-&gt;decStrong(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m_ptr保存对象，该对象继承于RefBase，所以析构函数会调用RefBase::decStrong()方法。</p><h2 id="decStrong"><a href="#decStrong" class="headerlink" title="decStrong"></a>decStrong</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void RefBase::decStrong(const void* id) const</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* const refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    const int32_t c = refs-&gt;mStrong.fetch_sub(1, std::memory_order_release);</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(BAD_STRONG(c), &quot;decStrong() called on %p too many times&quot;,</span><br><span class="line">            refs);</span><br><span class="line">    if (c == 1) &#123;</span><br><span class="line">        std::atomic_thread_fence(std::memory_order_acquire);</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        int32_t flags = refs-&gt;mFlags.load(std::memory_order_relaxed);</span><br><span class="line">        if ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            delete this;</span><br><span class="line">            // The destructor does not delete refs in this case.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对mStrong强引用计数执行减1操作，如果操作之前mStrong就是1，回调目标对象的onLastStrongRef()方法。如果当前flags设置对象的生命周期由强引用计数决定，那么就会释放该目标对象，最后调用decWeak()减少弱引用计数。</p><h2 id="decWeak"><a href="#decWeak" class="headerlink" title="decWeak"></a>decWeak</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void RefBase::weakref_type::decWeak(const void* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);</span><br><span class="line">    impl-&gt;removeWeakRef(id);</span><br><span class="line">    //mWeak执行减1操作</span><br><span class="line">    const int32_t c = impl-&gt;mWeak.fetch_sub(1, std::memory_order_release);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(BAD_WEAK(c), &quot;decWeak called on %p too many times&quot;,</span><br><span class="line">            this);</span><br><span class="line">    if (c != 1) return;</span><br><span class="line">    atomic_thread_fence(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">    int32_t flags = impl-&gt;mFlags.load(std::memory_order_relaxed);</span><br><span class="line">    if ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">        if (impl-&gt;mStrong.load(std::memory_order_relaxed)</span><br><span class="line">                == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            ALOGW(&quot;RefBase: Object at %p lost last weak reference &quot;</span><br><span class="line">                    &quot;before it had a strong reference&quot;, impl-&gt;mBase);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delete impl;    //释放weakref_impl对象</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        delete impl-&gt;mBase;     //释放实际目标对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对mWeak执行减1操作，如果操作前mWeak不等于1，表示还有其他wp引用，这里直接返回；如果mWeak等于1，表示没有其他wp引用，这里需要释放目标对象和weakref_impl对象。如果flags设定目标对象的生命周期由强引用计数决定，则释放weakref_impl对象，目标对象已经在调用decWeak()方法前被释放；如果flags设定目标对象的生命周期由弱引用计数决定，则调用目标对象的onLastWeakRef()方法，然后释放目标对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RefBase::~RefBase()</span><br><span class="line">&#123;</span><br><span class="line">    int32_t flags = mRefs-&gt;mFlags.load(std::memory_order_relaxed);</span><br><span class="line">    if ((flags &amp; OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;</span><br><span class="line">        if (mRefs-&gt;mWeak.load(std::memory_order_relaxed) == 0) &#123;</span><br><span class="line">            delete mRefs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (mRefs-&gt;mStrong.load(std::memory_order_relaxed)</span><br><span class="line">            == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(mRefs-&gt;mWeak.load() != 0,</span><br><span class="line">                &quot;RefBase: Explicit destruction with non-zero weak &quot;</span><br><span class="line">                &quot;reference count&quot;);</span><br><span class="line">        delete mRefs;</span><br><span class="line">    &#125;</span><br><span class="line">    const_cast&lt;weakref_impl*&amp;&gt;(mRefs) = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在释放目标对象时，会调用到父类的析构函数，如果flags设定目标对象的生命周期由弱引用计数决定，并且mWeak计数为0，则删除weakref_impl对象；如果没有sp引用该目标对象，释放weakref_impl对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RefBase是Android C++类的父类，有一个成员变量mRefs为weakref_impl类型指针，weakref_impl是weakref_type的子类，用来管理引用计数。</p><p>首次调用对象incStrong()，则会调用该对象的onFirstRef()；调用decStrong()的最后一次，则调用该对象的onLastStrongRef()。</p><p>弱引用不能直接操作目标对象，因为wp模版类没有实现指针引用的重载，而sp模版类则实现了指针引用的重载，但是可以通过promote()函数将弱引用提升为强引用对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">sp&lt;T&gt; wp&lt;T&gt;::promote() const</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;T&gt; result;</span><br><span class="line">    if (m_ptr &amp;&amp; m_refs-&gt;attemptIncStrong(&amp;result)) &#123;</span><br><span class="line">        result.set_pointer(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于Android P源码分析，加深对RefBase、sp、wp的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p
      
    
    </summary>
    
    
      <category term="Android" scheme="http://tinylaker.github.io/categories/Android/"/>
    
    
      <category term="智能指针" scheme="http://tinylaker.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>sc770x-稳定性问题分析</title>
    <link href="http://tinylaker.github.io/2019/11/14/sc770x-%E7%A8%B3%E5%AE%9A%E6%80%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/</id>
    <published>2019-11-14T13:03:01.000Z</published>
    <updated>2019-12-05T03:30:42.690Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录总结了笔者曾经参与的sc770x项目，基于 Trace32 Simulator 定位系统稳定性问题，这是 Lauterbach 公司推出的一款嵌入式系统调试工具，支持多种 CPU 和 RTOS 调试，拥有很强的扩展性，支持CMM脚本扩展。</p><h1 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h1><p>一般死机会保存对应的 ass 和 mem文件，打开 Trace32 Simulator ，导入 sc770x_simulator.cmm 脚本，加载当前系统版本对应的 axf 符号表文件。此时会提示输入 mem 地址，根据死机时保存的 ass 文件确定为0，然后再选择对应的 mem 文件，一般直接能够看到从 thread_entry 到死机现场的函数回调。如果不幸没有看到完整的回调，那么就需要自己进行推导，类似下面的情况。</p><p>查看死机状态时 _tx_thread_current_ptr 的值，根据 tx_thread_name 得知当前是 T_MIDI Task 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_tx_thread_current_ptr = 0x01D8FADC -&gt; (</span><br><span class="line">  tx_thread_id = 1414025796,</span><br><span class="line">  tx_run_count = 20,</span><br><span class="line">  tx_stack_ptr = 0x027D6E88,</span><br><span class="line">  tx_stack_start = 0x027D68B8,</span><br><span class="line">  tx_stack_end = 0x027D7CB3,</span><br><span class="line">  tx_stack_size = 5116,</span><br><span class="line">  tx_time_slice = 0,</span><br><span class="line">  tx_new_time_slice = 0,</span><br><span class="line">  tx_ready_next = 0x01D8FADC,</span><br><span class="line">  tx_ready_previous = 0x01D8FADC,</span><br><span class="line">  tx_thread_name = 0x080467A8 -&gt; &quot;T_MIDI&quot;,</span><br><span class="line">  tx_priority = 74,</span><br><span class="line">  tx_state = 0,</span><br><span class="line">  tx_delayed_suspend = 0,</span><br><span class="line">  tx_suspending = 0,</span><br><span class="line">  tx_preempt_threshold = 74,</span><br><span class="line">  tx_priority_bit = (0, 0, 1024, 0, 0, 0, 0, 0),</span><br><span class="line">  tx_thread_entry = 0x0035B4F7,</span><br><span class="line">  tx_entry_parameter = 66011532,</span><br><span class="line">  tx_thread_timer = (tx_remaining_ticks = 0, tx_re_initialize_ticks = 0, tx_timeout_function =</span><br><span class="line">  tx_suspend_cleanup = 0x0,</span><br><span class="line">  tx_suspend_control_block = 0x0,</span><br><span class="line">  tx_suspended_next = 0x0,</span><br><span class="line">  tx_suspended_previous = 0x0,</span><br><span class="line">  tx_suspend_info = 0,</span><br><span class="line">  tx_additional_suspend_info = 0x0,</span><br><span class="line">  tx_suspend_option = 0,</span><br><span class="line">  tx_suspend_status = 0,</span><br><span class="line">  tx_created_next = 0x00C1BBA4,</span><br><span class="line">  tx_created_previous = 0x01D8F884,</span><br><span class="line">  tx_filex_ptr = 0x0,</span><br><span class="line">  time = 0,</span><br><span class="line">  tx_thread_stack_highest_ptr = 0x027D6CF8)</span><br></pre></td></tr></table></figure><p>当前 Task 的栈的起始地址是 0x027D68B8，结束地址是 0x027D7CB3 ，查看对应地址的 data.dump 内存窗口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tx_stack_start = 0x027D68B8,</span><br><span class="line">tx_stack_end = 0x027D7CB3,</span><br><span class="line">tx_stack_size = 5116,</span><br></pre></td></tr></table></figure><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/1.png" alt></p><p>从 ass 文件中查看死机前 SVC 模式下寄存器的值，以 R13_SVC 为起始地址，按照函数调用的堆栈原则推导。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SVC mode:</span><br><span class="line">R13 = 0x027d6f70    R14  = 0xfffffffc</span><br><span class="line">SPSR = 0x20000033</span><br></pre></td></tr></table></figure><p>找到以0x08开头的函数地址，将其作为 R14，函数压栈结束地址作为 R13，正向推栈的方法是 <code>tx_stack_end -&gt; R13_SVC</code>，反向推栈的方法是 <code>R13_SVC -&gt; tx_stack_end</code>。当我们按照这个方法，就能获得完整的 callback 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">-001|MIDI_Core_Calculation_dls_stereo(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    sample_pool_ptr = 0x027D95D6,</span><br><span class="line">    |    sample_pool_r_ptr = 0x027D9716,</span><br><span class="line">    |    spn = 0)</span><br><span class="line">    |  pContext = 0x027D9478</span><br><span class="line">    |  VoiceChnPtr = 0x027DA52C</span><br><span class="line">    |  pcm_count = 74</span><br><span class="line">    |  temp_pcm_l = 0x027DBD94</span><br><span class="line">    |  temp_pcm_r = 0x027DC014</span><br><span class="line">    |  update = 1</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-002|MIDI_Core_Generate_Samples(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  pContext = 0x027D9478</span><br><span class="line">    |  samples_num = 640</span><br><span class="line">    |  cur_samples = 160</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-003|midi_decode(inline)</span><br><span class="line">-003|midi_play(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    midi_dataPtr = 0x027D7634)</span><br><span class="line">    |  pContext = 0x027D9478</span><br><span class="line">    |  midi_event = ((start_time = 0, event_type = 255, isReady = 0, sub_event_type = 47, pa</span><br><span class="line">    |  midi_event_to_play = 0x027D7060</span><br><span class="line">    |  bytes_processed = 1</span><br><span class="line">    |  result = 0</span><br><span class="line">    |  cur_midi_event = (start_time = 35, event_type = 144, isReady = 0, sub_event_type = 0,</span><br><span class="line">    |  min_time = 18</span><br><span class="line">    |  track_end_num = 1</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-004|MIDI_PlayMidi(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    mididata = 0x00CD5A58,</span><br><span class="line">    |    file_length = 5656)</span><br><span class="line">    |  pContext = 0x027D9478</span><br><span class="line">    |  midi_track_data = (track = ((file_start = 22, length = 37, buffer_addr = 0x00CD5A6E,</span><br><span class="line">    |  PPQN = 120</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-005|MidiPlayFile(inline)</span><br><span class="line">-005|MIDI_Thread_Entry(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  audio_obj = 0x0278E944</span><br><span class="line">    |  sig_in_ptr = 0x0</span><br><span class="line">    |  sig_out_ptr = 0x0</span><br><span class="line">    |  ptMidiProcRes = 0x03F8FD80</span><br><span class="line">    |  time_offset = 0</span><br><span class="line">    |  samples_offset = 0</span><br><span class="line">    |  result = 0</span><br><span class="line">    |  midi_res_ptr = 0x03F8FD80</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-006|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x08046340, argc = 41478468, argv = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-007|tx_thread_shell_entry()</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>我们可以根据 callback 获得死机步骤场景和参数（但参数并不一定准确），推导时如果无法推进就进行参数代入试验和猜测再反向验证的方法，以便使到 callback 向更深推进，以达到死机现场，便于进一步的分析问题。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>一般根据 ass 文件提示的 assert 信息，能够大概了解死机的原因。</p><ul><li>最基本的 assert 信息，根据打印信息可以知道问题代码，直接分析原因。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File:nfc_drv_v1.c Line:  501 PASSERT(0) &gt; NFC timeout happened!f=4,e=0</span><br></pre></td></tr></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>一般是使用 SCI_ALLOC 申请内存后，却没有调用 SCI_FREE 释放对应内存，导致内存泄漏。</p><p>Threadx 在内存管理中定义了 block pool 和 byte pool 两种概念，byte pool 设置固定大小的内存池，支持可变的内存申请释放，但是会存在碎片化问题，而block pool 设定不同大小的 block，方便快速申请释放，不会存在碎片化问题，性能上比 byte pool 会更有效率。</p><p>笔者曾根据 byte pool 和 block pool 分配的规则，编写了 mocor_byte_pool_list.cmm 和 mocor_block_pool_list.cmm 脚本，用来检查 heap 和 pool 两种内存空间的分配是否存在异常，有助于分析内存覆盖等问题。</p><ul><li>通过 ArmLogel trace 定位</li></ul><ol><li><p>手机连接 ArmLogel 工具，通过 ［SysInfo］-&gt;[Memory Status] 和［SysInfo］-&gt;[Memory Allocated Status] 将内存池信息和内存分配情况打印出来。</p></li><li><p>打开应用测试，然后通过相同方式保存内存信息。</p></li><li><p>如此重复多次，对比保存文件中的内存信息差异，确定是否有规律可循。如果存在内存泄漏，可通过<code>Allocated memory info</code> 信息对比查找泄漏源。</p></li></ol><ul><li>通过工具 Assert 定位</li></ul><p>出现内存问题时，查看 Assert 后的 ass 文件，打印的 Assert 信息的过程实际上是对当前系统处于 Assert 状态时的 Pool 内存和 Heap 内存信息检查的过程，通过观察内存信息输出的完整性检查，基本可以看出来系统的内存是否正常。</p><ol><li>Assert 后弹出界面有如下信息：</li></ol><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/2.png" alt="assert"></p><ol start="2"><li>按5输出内存池 Pool 和 Heap 使用情况，如果有大批内存池耗光（Avail_Num 为0），有可能是内存泄漏问题。</li></ol><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/3.png" alt="memory"><br><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/4.png" alt="memory"></p><ol start="3"><li>按4输出内存池的详细分配信息，可以查找哪些文件在大量申请内存，观察规律是否存在内存泄漏。</li></ol><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/5.png" alt="memory"></p><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/6.png" alt="memory"></p><h2 id="内存越界"><a href="#内存越界" class="headerlink" title="内存越界"></a>内存越界</h2><p>内存越界是由于编程不当导致的内存越界覆盖，实际使用的内存空间大于申请的内存范围，比较常见的是 memcpy 时，数据源太长，导致内存end_flag被覆盖。此类问题需要找到发生内存越界之前的内存块，仔细分析该内存块的使用序列，是否有可能造成内存越界访问。</p><h3 id="block-pool"><a href="#block-pool" class="headerlink" title="block pool"></a>block pool</h3><p>比如下面这种 block pool 越界的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">-000|TXAS_SaveMainReg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    cur_lr = 0x0108D1C2,</span><br><span class="line">    |    cur_pc = 0x80)</span><br><span class="line">-001|TXAS_SystemAssert(</span><br><span class="line">    |    exp = 0x0021229C,</span><br><span class="line">    |    file = 0x00212224,</span><br><span class="line">    |    line = 118,</span><br><span class="line">    |    assert_info_ptr = 0x0)</span><br><span class="line">    |  assert_mode = 1</span><br><span class="line">    |  cur_sp = 36771216</span><br><span class="line">    |  cur_lr = 3422259</span><br><span class="line">    |  cur_pc = 7799016</span><br><span class="line">    |  i = 0</span><br><span class="line">-002|system_fatal_error_handler(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-003|osa_fatal_error_handler_info(</span><br><span class="line">    |    error_message_ptr = 0x0021229C,</span><br><span class="line">    |    error_code = OSA_ERROR_BUFFMNGR_ISVALID_FAILED,</span><br><span class="line">    |    os_error_code = 101,</span><br><span class="line">    |    file = 0x00212224,</span><br><span class="line">    |    line = 118)</span><br><span class="line">-004|osa_validate_buff_footer(</span><br><span class="line">    |    usr_buff = 0x03FD908C,</span><br><span class="line">    |    curr_alloc_size = 1052)</span><br><span class="line">-005|osa_int_release_buffer(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |    dealloc_file = 0,</span><br><span class="line">    |    dealloc_line = 1050)</span><br><span class="line">    |  buff_hdr_p = 0x03FD906C</span><br><span class="line">-006|SCI_Release_Buffer(</span><br><span class="line">    |    buff_ptr = 0x03FD908C,</span><br><span class="line">    |    entity_id = 3,</span><br><span class="line">    |    dealloc_file = 0,</span><br><span class="line">    |    dealloc_line = 1050)</span><br><span class="line">    |  debug_buff_ptr = 0x03FD908C</span><br><span class="line">-007|SCI_Free(</span><br><span class="line">    |    memory_ptr = 0x03FD908C)</span><br><span class="line">    |  free_ptr = 0x00345A95</span><br><span class="line">-008|SendMultiPicByBt()</span><br><span class="line">    |  pic_info = (filename = (68, 58, 92, 80, 104, 111, 116, 111, 115, 92, 68, 83, 67, 95</span><br><span class="line">    |  send_file_info = 0x03FD9090</span><br><span class="line">    |  list_ctrl_id = 2359329</span><br><span class="line">    |  send_file_num = 2</span><br><span class="line">    |  i = 3</span><br><span class="line">    |  total_num = 3</span><br><span class="line">-009|HandleShareItemsPiclistOptWinMsg(</span><br><span class="line">    |    win_id = 2359302,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  title_str = (wstr_ptr = 0x0, wstr_len = 0)</span><br><span class="line">    |  result = 1</span><br><span class="line">    |  ctrl_id = 2359331</span><br><span class="line">    |  list_ctrl_id = 2359329</span><br><span class="line">    |  menu_id = 2359331</span><br><span class="line">    |  group_id = 2359299</span><br><span class="line">    |  kstring = (wstr_ptr = 0x0, wstr_len = 0)</span><br><span class="line">-010|MMK_RunWinProc(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 57345,</span><br><span class="line">    |    param = 0x03E983C8)</span><br><span class="line">-011|MMK_DispatchToHandle(</span><br><span class="line">    |    handle = 1103560803,</span><br><span class="line">    |    msg_id = 57345,</span><br><span class="line">    |    param_ptr = 0x03E983C8)</span><br><span class="line">    |  openwin_handle_result = 0</span><br><span class="line">    |  old_handle = 16711680</span><br><span class="line">-012|MMK_DispatchWinMSG(</span><br><span class="line">    |    mmi_msg_ptr = 0x03FA1300)</span><br><span class="line">-013|MMK_DispatchMSGQueue(</span><br><span class="line">    |  ?)</span><br><span class="line">-014|thread_entry_P_APP(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  receiveSignal = 0x0</span><br><span class="line">    |  mmi_msg = 0x03FA1300</span><br><span class="line">    |  ticks1 = 0</span><br><span class="line">    |  ticks2 = 0</span><br><span class="line">    |  is_log_on = 0</span><br><span class="line">    |  time_period = 4294967295</span><br><span class="line">    |  watchdog_ptr = 0x03ECF2EC</span><br><span class="line">-015|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x0833AF73, argc = 0, argv = 0x0)</span><br><span class="line">-016|tx_thread_shell_entry()</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>在释放 0x03FD908C 内存地址空间时，函数 osa_validate_buff_footer 检查 block pool 的时候发现找不到 end flag 导致 assert。</p><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/7.png" alt="memory"></p><p>根据 threadx 内存分配原则，0x03FD94A8 地址内存的值应该是 0xF2F2F2F2，但是实际上是 0x003A0044。分析这个代码逻辑，发现原因是 SendMultiPicByBt 中 send_file_num 和 total_num 不相等导致内存越界。</p><h3 id="byte-pool"><a href="#byte-pool" class="headerlink" title="byte pool"></a>byte pool</h3><p>还有一种 byte pool 越界情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">-000|tx_byte_pool_search_ex(</span><br><span class="line">    |    pool_ptr = 0x00B68A14,</span><br><span class="line">    |    memory_size = 552)</span><br><span class="line">    |  interrupt_save = 536870912</span><br><span class="line">    |  current_ptr = 0x80818081</span><br><span class="line">    |  examine_blocks = 119</span><br><span class="line">    |  alloc_ptr = 0x025F385C</span><br><span class="line">    |  min_size = 32</span><br><span class="line">    |  section_limit_space_addr = 0x0</span><br><span class="line">    |  section_limit_space_size = 4294967295</span><br><span class="line">    |  section_high_space_addr = 0x0</span><br><span class="line">    |  section_high_space_size = 4294967295</span><br><span class="line">    |  search_cnt = 484</span><br><span class="line">-001|tx_byte_allocate(</span><br><span class="line">    |    pool_ptr = 0x00B68A14,</span><br><span class="line">    |    memory_ptr = 0x02320998,</span><br><span class="line">    |  ?,</span><br><span class="line">    |    wait_option = 2863311530)</span><br><span class="line">    |  thread_ptr = 0x01CBAAD8</span><br><span class="line">-002|txe_byte_allocate(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-003|SCI_MallocEx(</span><br><span class="line">    |    size = 520,</span><br><span class="line">    |    type = 1145324612,</span><br><span class="line">    |    file = 0x08652448,</span><br><span class="line">    |    line = 143)</span><br><span class="line">    |  memory_ptr = 0x0</span><br><span class="line">    |  num_free_buffs = 0</span><br><span class="line">    |  cur_pool_inx = 14</span><br><span class="line">    |  alloc_size = 549</span><br><span class="line">    |  byte_mem_header_ptr = 0x0</span><br><span class="line">-004|allocatePName(</span><br><span class="line">    |    pName = 0x023210EC)</span><br><span class="line">-005|SFS_CreateFileInternal(</span><br><span class="line">    |    file_name = 0x023210EC,</span><br><span class="line">    |    access_mode = 49,</span><br><span class="line">    |    share_mode = 0,</span><br><span class="line">    |    file_attri = 0)</span><br><span class="line">    |  __func__ = (83, 70, 83, 95, 67, 114, 101, 97, 116, 101, 70, 105, 108, 101</span><br><span class="line">    |  handle = 0</span><br><span class="line">-006|DrmParseDCF(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  ret_val = 0</span><br><span class="line">-007|DrmCheckIsDRM(</span><br><span class="line">    |    file_name_ptr = 0x023210EC)</span><br><span class="line">    |  ret_val = 0</span><br><span class="line">-008|DRM_CreateFile(</span><br><span class="line">    |    file_name_ptr = 0x023210EC,</span><br><span class="line">    |    access_mode = 49,</span><br><span class="line">    |    share_mode = 0,</span><br><span class="line">    |    file_attribute = 0)</span><br><span class="line">    |  drm_handle_f = 2555905</span><br><span class="line">    |  drm_file_ptr = 0x014D1904</span><br><span class="line">    |  drm_io_handle = 0</span><br><span class="line">-009|SFS_CreateFile(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-010|MMIFILE_CreateFile(</span><br><span class="line">    |    file_name = 0x023210EC,</span><br><span class="line">    |    access_mode = 49,</span><br><span class="line">    |    share_mode = 0,</span><br><span class="line">    |    file_attri = 0)</span><br><span class="line">    |  handle = 0</span><br><span class="line">-011|MMIPICVIEW_IsSend(</span><br><span class="line">    |    is_sms = 0,</span><br><span class="line">    |    file_data_ptr = 0x023210EC)</span><br><span class="line">    |  result = 0</span><br><span class="line">    |  file_info = (file_name = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |  send_file_info = (filepath_name = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">-012|SendMultiPicByBt()</span><br><span class="line">    |  pic_info = (filename = (69, 58, 92, 86, 105, 100, 101, 111, 92, 77, 79, 8</span><br><span class="line">    |  send_file_info = 0x0268B9D0</span><br><span class="line">    |  list_ctrl_id = 2359329</span><br><span class="line">    |  send_file_num = 5</span><br><span class="line">    |  i = 6</span><br><span class="line">    |  total_num = 7</span><br><span class="line">-013|HandleShareItemsPiclistOptWinMsg(</span><br><span class="line">    |    win_id = 2359302,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  title_str = (wstr_ptr = 0x0, wstr_len = 0)</span><br><span class="line">    |  result = 1</span><br><span class="line">    |  ctrl_id = 2359331</span><br><span class="line">    |  list_ctrl_id = 2359329</span><br><span class="line">    |  menu_id = 2359331</span><br><span class="line">    |  group_id = 2359299</span><br><span class="line">    |  kstring = (wstr_ptr = 0x0, wstr_len = 0)</span><br><span class="line">-014|MMK_RunWinProc(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 57345,</span><br><span class="line">    |    param = 0x03E9BB08)</span><br><span class="line">-015|MMK_DispatchToHandle(</span><br><span class="line">    |    handle = 2632974468,</span><br><span class="line">    |    msg_id = 57345,</span><br><span class="line">    |    param_ptr = 0x03E9BB08)</span><br><span class="line">    |  openwin_handle_result = 0</span><br><span class="line">    |  old_handle = 16711680</span><br><span class="line">-016|MMK_DispatchWinMSG(</span><br><span class="line">    |    mmi_msg_ptr = 0x03FA14E0)</span><br><span class="line">-017|MMK_DispatchMSGQueue(</span><br><span class="line">    |  ?)</span><br><span class="line">-018|thread_entry_P_APP(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  receiveSignal = 0x0</span><br><span class="line">    |  mmi_msg = 0x03FA14E0</span><br><span class="line">    |  ticks1 = 0</span><br><span class="line">    |  ticks2 = 0</span><br><span class="line">    |  is_log_on = 0</span><br><span class="line">    |  time_period = 4294967295</span><br><span class="line">    |  watchdog_ptr = 0x03ECF298</span><br><span class="line">-019|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x08650E7B, argc = 0, argv = 0x0)</span><br><span class="line">-020|tx_thread_shell_entry()</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>从死机处代码逻辑和 callback 中并没有看出问题，但是却在申请内存过程中，遍历 byte pool 出错。那么怀疑内存区域中存在异常，可能存在被覆盖的情况。使用 mocor_block_pool_list.cmm 脚本检查 byte pool 内存空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">byte_static_heap:       0x0B68984</span><br><span class="line">byte_dynamic_base_heap: 0x0B689CC</span><br><span class="line">byte_dynamic_app_heap:  0x0B68A14</span><br><span class="line">pool start address:     0x24FF4D4</span><br><span class="line">pool end address:       0x3E878FC</span><br><span class="line">pool addr: 0x24FF4D4</span><br><span class="line">     size: 0x888</span><br><span class="line"></span><br><span class="line">～～～</span><br><span class="line">pool addr: 0x268B9AC</span><br><span class="line">     size: 0x0A64</span><br><span class="line">pool addr: 0x268C410</span><br><span class="line">pool memory end: 0x56005C</span><br><span class="line">pool count: 0x1E1</span><br></pre></td></tr></table></figure><p>0x268B9AC 处的内存节点正常，但是 0x268C410 处的内存节点已经异常，end_flag:0xAA 已经丢失，变成了一片非法数据。</p><p>按照函数 tx_byte_pool_search_ex 代码逻辑，最终会导致 0 地址访问，<code>R5=0x80818081</code>，然后执行 <code>ldr r0,[r5,#04]</code> ，导致4字节对齐异常死机 (这个和 assert 文件中的错误提示也是匹配的：Fault address :0x80818085 )。</p><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/8.png" alt="memory"></p><p>查看 0x268B9AC 地址空间的内存分配情况，如下：</p><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/9.png" alt="memory"></p><p>分析 mmipicview_wintab.c 文件中内存分配和使用的代码，发现是 SendMultiPicByBT 函数中针对 send_file_info 分配的内存使用时存在越界操作，从而引发了上面的问题。</p><h2 id="内存覆盖"><a href="#内存覆盖" class="headerlink" title="内存覆盖"></a>内存覆盖</h2><p>导致内存覆盖原因很多，空指针的操作会操作 0 地址，相对比较容易检查，因为 0 地址一般是 DSP code 区域，可以通过BUSMonitor 辅助监控 code 区域，定位到覆盖代码段的源头。</p><p>野指针的操作比较复杂，可以利用 pool_list.cmm 脚本检查内存分配的完整性，也可以通过 dump memory 内容进行比对，寻找覆盖来源。</p><p>死机现场：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File:  tx_byta.c</span><br><span class="line">Line:  240</span><br><span class="line">ASSERT(current_ptr != (*((CHAR_PTR *) current_ptr)))</span><br></pre></td></tr></table></figure><p>推导出 callback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">-000|TXAS_SaveMainReg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    cur_lr = 0x0108D1CE,</span><br><span class="line">    |    cur_pc = 0x80)</span><br><span class="line">-001|TXAS_SystemAssert(</span><br><span class="line">    |    exp = 0x00215CAC,</span><br><span class="line">    |    file = 0x00215C5C,</span><br><span class="line">    |    line = 240,</span><br><span class="line">    |    assert_info_ptr = 0x0)</span><br><span class="line">    |  assert_mode = 1</span><br><span class="line">    |  cur_sp = 38244696</span><br><span class="line">    |  cur_lr = 3672209</span><br><span class="line">    |  cur_pc = 8536932</span><br><span class="line">    |  i = 12387240</span><br><span class="line">-002|SCI_Assert(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-003|tx_byte_pool_search_ex(</span><br><span class="line">    |    pool_ptr = 0x00C35B3C,</span><br><span class="line">    |    memory_size = 307776)</span><br><span class="line">    |  interrupt_save = 536870912</span><br><span class="line">    |  examine_blocks = 85</span><br><span class="line">    |  alloc_ptr = 0x0</span><br><span class="line">    |  min_size = 4294967295</span><br><span class="line">    |  section_limit_space_addr = 0x0</span><br><span class="line">    |  section_limit_space_size = 4294967295</span><br><span class="line">    |  section_high_space_addr = 0x0</span><br><span class="line">    |  section_high_space_size = 4294967295</span><br><span class="line">    |  search_cnt = 150</span><br><span class="line">-004|tx_byte_allocate(</span><br><span class="line">    |    pool_ptr = 0x00C35B3C,</span><br><span class="line">    |    memory_ptr = 0x02479238,</span><br><span class="line">    |  ?,</span><br><span class="line">    |    wait_option = 2863311530)</span><br><span class="line">    |  thread_ptr = 0x01E10380</span><br><span class="line">-005|txe_byte_allocate(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-006|SCI_MallocApp(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    file = 0x0904406C,</span><br><span class="line">    |    line = 5942)</span><br><span class="line">    |  memory_ptr = 0x0</span><br><span class="line">    |  num_free_buffs = 0</span><br><span class="line">    |  cur_pool_inx = -1</span><br><span class="line">    |  alloc_size = 307773</span><br><span class="line">    |  byte_mem_header_ptr = 0x0</span><br><span class="line">-007|BL_MallocEx(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    file = 0x0904406C,</span><br><span class="line">    |    line = 5942)</span><br><span class="line">    |  index = 2</span><br><span class="line">-008|MMI_BL_Malloc(</span><br><span class="line">    |    id = 270,</span><br><span class="line">    |    file = 0x0904406C,</span><br><span class="line">    |    line = 5942)</span><br><span class="line">-009|AllocTrans3DBuf(</span><br><span class="line">    |    old_buf_pptr = 0x024792BC,</span><br><span class="line">    |    new_buf_pptr = 0x024792B8)</span><br><span class="line">    |  result = 0</span><br><span class="line">-010|MMIDEFAULT_SaveOldMoveBuf(</span><br><span class="line">    |    buf_type = SCR_EFFECT_BUF_TYPE_SLIDE_RIPPLE = SCR_EFFECT_BUF_TYPE_WIN_SWITCH)</span><br><span class="line">    |  buf_ptr = 0x0265D100</span><br><span class="line">    |  buf_width = 240</span><br><span class="line">    |  old_buf_ptr = 0x0</span><br><span class="line">    |  new_buf_ptr = 0x0</span><br><span class="line">-011|HandleMenuOkKey(</span><br><span class="line">    |    menu_ctrl_ptr = 0x03FE0420,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  is_handled = 0</span><br><span class="line">    |  is_grayed = 0</span><br><span class="line">    |  is_exist_child = 1</span><br><span class="line">    |  cur_item_top = 0</span><br><span class="line">    |  base_ctrl_ptr = 0x03FE0420</span><br><span class="line">    |  cur_item = (menu_id = 0, tip_id = 0, button_id = (0, 0, 0), text_str_id = 0, select_icon</span><br><span class="line">    |  cur_node_ptr = 0x027DC338</span><br><span class="line">    |  lcd_dev_info = 0x092B5920</span><br><span class="line">    |  lcd_rect = (left = 0, top = 0, right = 239, bottom = 319)</span><br><span class="line">-012|MenuHandleMsg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 64027,</span><br><span class="line">    |    param = 0x02479404)</span><br><span class="line">    |  result = 1</span><br><span class="line">    |  menu_ctrl_ptr = 0x03FE0420</span><br><span class="line">-013|VTLCTRL_HandleMsg(</span><br><span class="line">    |    iguictrl_ptr = 0x03FE0420,</span><br><span class="line">    |    msg_id = 64027,</span><br><span class="line">    |    param_ptr = 0x02479404)</span><br><span class="line">-014|MMK_RunCtrlProc(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 64027,</span><br><span class="line">    |    param = 0x02479404)</span><br><span class="line">    |  me_ptr = 0x03FE0420</span><br><span class="line">-015|MMK_DefaultProcessWinMsg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 64027,</span><br><span class="line">    |    param = 0x02479404)</span><br><span class="line">    |  result = 0</span><br><span class="line">    |  ctrl_handle = 1288896624</span><br><span class="line">-016|MMK_DispatchToHandle(</span><br><span class="line">    |    handle = 1288765504,</span><br><span class="line">    |    msg_id = 64027,</span><br><span class="line">    |    param_ptr = 0x02479404)</span><br><span class="line">    |  bResult = 0</span><br><span class="line">    |  old_handle = 16711680</span><br><span class="line">-017|MMK_DispMsgToFocusWin(</span><br><span class="line">    |    msg_id = 64027,</span><br><span class="line">    |    param_ptr = 0x02479404)</span><br><span class="line">-018|MMK_DispMsgToWin(</span><br><span class="line">    |    msg_id = 64027,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  result = 0</span><br><span class="line">-019|HandleMSGKbd(</span><br><span class="line">    |    keys_status = 64000,</span><br><span class="line">    |    key_code = 27)</span><br><span class="line">    |  multi_key_tp_param = (is_slide = 0, pre_tp_point = (x = 0, y = 0), cur_tp_point = (x = 0</span><br><span class="line">-020|MMK_DispatchMSGKbd(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  keypress_ptr = 0x03EB1488</span><br><span class="line">    |  key_code = 27</span><br><span class="line">    |  is_long_press = 0</span><br><span class="line">-021|MMK_DispatchExtSig(</span><br><span class="line">    |  ?)</span><br><span class="line">-022|thread_entry_P_APP(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  receiveSignal = 0x03EB1488</span><br><span class="line">    |  mmi_msg = 0x03FA0600</span><br><span class="line">    |  ticks1 = 0</span><br><span class="line">    |  ticks2 = 0</span><br><span class="line">    |  is_log_on = 0</span><br><span class="line">    |  time_period = 4294967295</span><br><span class="line">    |  watchdog_ptr = 0x03EBE978</span><br><span class="line">-023|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x0800430F, argc = 0, argv = 0x0)</span><br><span class="line">-024|tx_thread_shell_entry()</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>从 callback 能够看出，是在内存分配过程中出现问题，这里编译内存节点时出现异常，使用 mocor_byte_pool_list.cmm 进行检查：</p><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/10.png" alt="memory"></p><p>根据内存分配器的规则查找，从 0x027DD46C 寻找下一个内存节点时出现问题，这里的内存被 0x21242124覆盖。</p><p>根据对应 assert 文件中的信息，ctrlmenu.c 分配的内存从0x027DC2BC 到 0x027DD46C，但是 0x027DD46C 开始的位置被覆盖了。</p><p>根据log记录，这段内存在死机前先是分配给了jpeg decode使用，通过代码逻辑我们可以看到 APP 发起的 Destroy 立刻返回并释放了内存，并没有等待 Set Event 的动作(解码 IMG_DEC 结束)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2265207-4     37131 [MMIPIC]:HandlePicListWinMsg msg_id =f023</span><br><span class="line">2265207-5     37131 [IMG_DEC_Destroy +] handle = 0x85a0fd17</span><br><span class="line">2265207-6     37131 _IMG_DEC_Get_Caller_Priority: T_P_APP, queue_name: Q_P_APP, priority: 76 </span><br><span class="line">2265207-7     37131 _IMG_DEC_Get_Caller_Priority: T_IMG_DEC, queue_name: T_IMG_DEC_QUEUE, priority: 76 </span><br><span class="line">2265207-8     37131 _IMG_DEC_SendMsg: sig_code = 2</span><br><span class="line">2265207-9     37131 [IMG_DEC_Destroy -] handle = 0x85a0fd17</span><br><span class="line">2265207-10    37131 GUIANIM_DestroyHandle:destroy handle=0x85a0fd17 result is 0!</span><br><span class="line"></span><br><span class="line">  (byte_heap_hdr_struct)0x27dc2c4 = (</span><br><span class="line">    pre = 0x03D47820,</span><br><span class="line">    succ = 0x00C6E1FC,</span><br><span class="line">    file_name = 0x08DB3DB4 -&gt; &quot;ctrlmenu.c&quot;,</span><br><span class="line">    line = 861,</span><br><span class="line">    size = 4493,</span><br><span class="line">    block_num = 572061)</span><br><span class="line"></span><br><span class="line"> &gt; </span><br><span class="line"> 0x27dc2bc    0x27dd46c      0x11b0      ALLOC        ctrlmenu.c(861)</span><br><span class="line"> &gt; </span><br><span class="line"> 0x27dd46c    0x21242124     0x1ea64cb8  ALLOC        (556015908)</span><br><span class="line"> &gt;</span><br></pre></td></tr></table></figure><p>GUIANIM_DestroyHandle 没有等待 decode 执行JPEGDEC_DestoryHandle 停止底层解码的动作，提前释放内存，导致当前 decode 的动作继续使用了之前的内存，如下，通过 T_IMG_DEC task 的信息也可以看出来，target_ptr_=_0x027DC300 依然存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">-000|tx_thread_suspend(</span><br><span class="line">    |  ?)</span><br><span class="line">    |</span><br><span class="line">-001|tx_semaphore_get(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_ptr = 0x01E16F50</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-002|txe_semaphore_get(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-003|SCI_GetSemaphore(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  _sem_ptr = 0x03EBC074</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-004|FreeLock()</span><br><span class="line">    |  sem_count = 0</span><br><span class="line">    |  susp_count = 0</span><br><span class="line">    |  semap_ptr = 0x03EBC074</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-005|JPEGDEC_DestoryHandle(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    exit_type = IMG_DEC_EXIT_HALT)</span><br><span class="line">    |  dec_info_ptr = 0x03F79100 -&gt; (</span><br><span class="line">    |    src_info = (src_ptr = 0x0, src_file_size = 14576, src_file_handle = 150</span><br><span class="line">    |    frame_in_param = (</span><br><span class="line">    |      handle = 66556160,</span><br><span class="line">    |      target_ptr = 0x027DC300,</span><br><span class="line">    |      target_buf_size = 11552,</span><br><span class="line">    |      target_width = 76,</span><br><span class="line">    |      target_height = 76,</span><br><span class="line">    |      img_rect = (left = 0, top = 40, right = 239, bottom = 279),</span><br><span class="line">    |      target_rect = (left = 0, top = 0, right = 75, bottom = 75),</span><br><span class="line">    |      data_format = IMG_DEC_RGB565,</span><br><span class="line">    |      frame_index = 0,</span><br><span class="line">    |      is_dec_thumbnail = 0,</span><br><span class="line">    |      is_exist_background = 0,</span><br><span class="line">    |      padding1 = 0,</span><br><span class="line">    |      padding2 = 0,</span><br><span class="line">    |      alpha_buf_ptr = 0x0,</span><br><span class="line">    |      alpha_buf_size = 0,</span><br><span class="line">    |      write_data = 0x0,</span><br><span class="line">    |      callback = 0x003AE0CB,</span><br><span class="line">    |      app_param_ptr = 38240904,</span><br><span class="line">    |      app_param_size = 12,</span><br><span class="line">    |      quality = JINF_QUALITY_HIGH,</span><br><span class="line">    |      target_buf_width = 0,</span><br><span class="line">    |      target_buf_height = 0,</span><br><span class="line">    |      img_dec_mode = IMG_DEC_TARGET_SIZE_RESIZABLE),</span><br><span class="line">    |    frame_out_param = (is_decode_finished = 0, is_process_alpha = 0, paddin</span><br><span class="line">    |    frame_extra_info = (priority = 77),</span><br><span class="line">    |    dec_buf_ptr = 0x03D4783C,</span><br><span class="line">    |    read_buf_ptr = 0x0,</span><br><span class="line">    |    ret_val = IMG_DEC_RET_SUCCESS,</span><br><span class="line">    |    jpeg_type = JINF_JPEG_TYPE_BASELINE)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-006|IMG_DEC_Destroy_Hal(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    handle = 66556160,</span><br><span class="line">    |    exit_type = IMG_DEC_EXIT_HALT)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-007|IMG_DEC_Remove_Command(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  ret = IMG_DEC_RET_SUCCESS</span><br><span class="line">    |  dec_handle_ptr = 0x03FE0EA0</span><br><span class="line">    |  tmp_cmd_ptr = 0x03EBBFCC</span><br><span class="line">    |  cur_cmd_ptr = 0x03ED1368</span><br><span class="line">    |  next_cmd_ptr = 0x0</span><br><span class="line">    |  pre_cmd_ptr = 0x03EBBFCC</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-008|IMG_DEC_Task_Routine(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  command = 2</span><br><span class="line">    |  param0 = 2241920279</span><br><span class="line">    |  param2 = 0</span><br><span class="line">    |  sig_ptr = 0x03EC8D34</span><br><span class="line">    |  handle = 2241920279</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-009|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x003AE7A9, argc = 0, argv = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-010|tx_thread_shell_entry()</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>通过研究代码发现此问题的原因如下：</p><p>buffer target_ptr 的申请与释放是由应用层所做的，当应用层调用了函数 IMG_DEC_Remove_Handle 后，只是停止发送解码消息的进程，实际解码工作仍在进行，当解码完成后，会调用函数 JPEG_OutputData 将解码后的数据写入 target_ptr 所指内存，但上层应用此时已经释放了此内存，导致非法内存访问。需要修改代码流程，在调用 JPEG_OutputData 函数前，判断该图片是否被强制结束解码，如果是则不调用，否则则调用，从而将解码后的数据传递给上层应用。</p><p>另外发现 JVM callback 在图片解码 task 中调用导致 envent 状态错乱，导致 APP 发起的 Destroy 立刻返回并释放了内存。</p><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>死锁问题一般是因为互斥量的使用不当引发的问题，可能会导致界面不响应或看门狗复位等问题。</p><p>以看门狗复位为例，ass 文件有以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File:  watchdog.c</span><br><span class="line">Line:  353</span><br><span class="line">PASSERT(SCI_FALSE)</span><br><span class="line"> &gt; Task APP timeout</span><br></pre></td></tr></table></figure><p>对应 callback 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-000|TXAS_SaveMainReg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    cur_lr = 0x0108D180,</span><br><span class="line">    |    cur_pc = 0x80)</span><br><span class="line">-001|TXAS_SystemAssert(</span><br><span class="line">    |    exp = 0x003ACD84 -&gt; ,</span><br><span class="line">    |    file = 0x003ACD78 -&gt; ,</span><br><span class="line">    |    line = 353,</span><br><span class="line">    |    assert_info_ptr = 0x00C36215 -&gt; &quot;Task APP timeout&quot;)</span><br><span class="line">    |  assert_mode = 1</span><br><span class="line">    |  cur_sp = 31244224</span><br><span class="line">    |  cur_lr = 3791281</span><br><span class="line">    |  cur_pc = 8534840</span><br><span class="line">    |  i = 12387240</span><br><span class="line">-002|SCI_PAssert(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-003|CheckAllTask()</span><br><span class="line">    |  list = 0x03EBEB2C</span><br><span class="line">    |  curr_tick = 3562772</span><br><span class="line">-004|DoIdle_DoCallback(</span><br><span class="line">    |    param = 5000)</span><br><span class="line">    |  i = 2</span><br><span class="line">-005|DoIdle_Callback(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  assert_mode = 44</span><br><span class="line">    |  dischg = (warning_vol = 64244, shutdown_vol = 1011, deadline_vol = 65369,</span><br><span class="line">-006|osa_timer_routine_wraper(</span><br><span class="line">    |    usr_timer_id = 0x03F3FAF4)</span><br><span class="line">-007|tx_timer_thread_entry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  timeout_function_backup = 0x003BFF59</span><br><span class="line">    |  expired_timers = 0x03F3FAFC</span><br><span class="line">    |  timeout_function = 0x003BFF59</span><br><span class="line">-008|tx_thread_shell_entry()</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>提示死机原因是 <code>Task APP timeout</code> ，那么分析代码是在 mmimain.c 中，函数 <code>void APP_Task(uint32 argc, void *argv)</code> 注册的看门狗没有及时喂狗。</p><p><code>watchdog_ptr = SWDG_RegTask(&quot;APP&quot;, 180000)</code></p><p>分析 APP_Task callback 如下，这里在获取 img_decoder_event 时被挂起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">-000|tx_thread_suspend(?)</span><br><span class="line">    |</span><br><span class="line">-001|tx_event_flags_get(?, ?, ?, ?, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-002|txe_event_flags_get(?, ?, get_option = 1, ?, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-003|SCI_GetEvent(?, ?, get_option = 1, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-004|IMG_DEC_GetEvent(requested_flags = 4, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-005|IMG_DEC_Remove_Handle(?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-006|IMG_DEC_Destroy(handle = 2241919696)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-007|GUIANIM_DestroyHandle(?, img_handle = 2241919696, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-008|HandleAnimLoseFocus(anim_ctrl_ptr = 0x03FDAFD8)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-009|AnimCtrlHandleMsg(?, ?, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-010|VTLCTRL_HandleMsg(iguictrl_ptr = 0x03FDAFD8, msg_id = 61492, param_ptr = 0x</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-011|MMK_RunCtrlProc(?, msg_id = 61492, param = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-012|ControlTreeNodeHandleEvent(?, ?, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-013|MMK_DispatchToAllTreeNode(?, func = 0x09076FEF, msg_id = 61492, param = 0x0</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-014|MMK_DispatchToAllControl(?, msg_id = 61492, param = 0x0, state = 2)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-015|MMK_ProcSpecialWinMsg(win_handle = 89194548, ?, param = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-016|MMK_DispatchToHandle(handle = 89194548, msg_id = 61475, param_ptr = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-017|MMK_SendMsg(?, msg_id = 61475, param_ptr = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-018|MMK_OpenWin(win_handle = 90570798, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-019|AppletCreateWindow(?, is_win_table = 1)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-020|MMK_CreateWinTable(create_ptr = 0x02477A24)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-021|MMK_CreateWin(win_table_ptr = 0x082A4600, add_data_ptr = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-022|HandlePicListWinMsg(?, ?, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-023|MMK_RunWinProc(?, msg_id = 57345, param = 0x03E9BC88)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-024|MMK_DispatchToHandle(handle = 89194548, msg_id = 57345, param_ptr = 0x03E9B</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-025|MMK_DispatchWinMSG(mmi_msg_ptr = 0x03FA06C0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-026|MMK_DispatchMSGQueue(?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-027|thread_entry_P_APP(?, ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-028|ThreadEntry(?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-029|tx_thread_shell_entry()</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>而 img_decoder_event 应该在 T_IMG_DEC Task 中被释放，但是这个 Task 被信号量 JPEG_FREE_RES_SEMAP 挂起，参考下面的 callback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">-000|tx_thread_suspend(</span><br><span class="line">    |  ?)</span><br><span class="line">    |</span><br><span class="line">-001|tx_semaphore_get(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_ptr = 0x01E15D10 -&gt; (</span><br><span class="line">    |    tx_thread_id = 1414025796,</span><br><span class="line">    |    tx_run_count = 265,</span><br><span class="line">    |    tx_stack_ptr = 0x026A7F38,</span><br><span class="line">    |    tx_stack_start = 0x026A70F4,</span><br><span class="line">    |    tx_stack_end = 0x026A80EF,</span><br><span class="line">    |    tx_stack_size = 4092,</span><br><span class="line">    |    tx_time_slice = 0,</span><br><span class="line">    |    tx_new_time_slice = 0,</span><br><span class="line">    |    tx_ready_next = 0x01E15D10,</span><br><span class="line">    |    tx_ready_previous = 0x01E15D10,</span><br><span class="line">    |    tx_thread_name = 0x003AD978 -&gt; &quot;T_IMG_DEC&quot;,</span><br><span class="line">    |    tx_priority = 76,</span><br><span class="line">    |    tx_state = 6,</span><br><span class="line">    |    tx_delayed_suspend = 0,</span><br><span class="line">    |    tx_suspending = 0,</span><br><span class="line">    |    tx_preempt_threshold = 76,</span><br><span class="line">    |    tx_priority_bit = (0, 0, 4096, 0, 0, 0, 0, 0),</span><br><span class="line">    |    tx_thread_entry = 0x003B234F,</span><br><span class="line">    |    tx_entry_parameter = 65588616,</span><br><span class="line">    |    tx_thread_timer = (tx_remaining_ticks = 4294967295, tx_re_initialize_ti</span><br><span class="line">    |    tx_suspend_cleanup = 0x002162D1,</span><br><span class="line">    |    tx_suspend_control_block = 0x03EBC074,</span><br><span class="line">    |    tx_suspended_next = 0x01E15D10,</span><br><span class="line">    |    tx_suspended_previous = 0x01E15D10,</span><br><span class="line">    |    tx_suspend_info = 1,</span><br><span class="line">    |    tx_additional_suspend_info = 0x026A808C,</span><br><span class="line">    |    tx_suspend_option = 1,</span><br><span class="line">    |    tx_suspend_status = 0,</span><br><span class="line">    |    tx_created_next = 0x01E15E3C,</span><br><span class="line">    |    tx_created_previous = 0x01E146CC,</span><br><span class="line">    |    tx_filex_ptr = 0x0,</span><br><span class="line">    |    time = 0,</span><br><span class="line">    |    tx_thread_stack_highest_ptr = 0x026A7B58)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-002|txe_semaphore_get(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-003|SCI_GetSemaphore(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  _sem_ptr = 0x03EBC074 -&gt; (</span><br><span class="line">    |    sem_id = (</span><br><span class="line">    |      tx_semaphore_id = 1397050689,</span><br><span class="line">    |      tx_semaphore_name = 0x003DDCB4 -&gt; &quot;JPEG_FREE_RES_SEMAP&quot;,</span><br><span class="line">    |      tx_semaphore_count = 0,</span><br><span class="line">    |      tx_semaphore_suspension_list = 0x01E15D10,</span><br><span class="line">    |      tx_semaphore_suspended_count = 1,</span><br><span class="line">    |      tx_semaphore_created_next = 0x03EBC218,</span><br><span class="line">    |      tx_semaphore_created_previous = 0x03EBC020),</span><br><span class="line">    |    sem_stat = 0x03E8CE48)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-004|FreeLock()</span><br><span class="line">    |  sem_count = 0</span><br><span class="line">    |  susp_count = 0</span><br><span class="line">    |  semap_ptr = 0x03EBC074</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-005|IMGJPEG_FreeRes()</span><br><span class="line">    |  pContext = 0x01250CDC</span><br><span class="line">    |  ret_value = 255</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-006|JPEGDEC_DestoryHandle(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    exit_type = IMG_DEC_EXIT_HALT)</span><br><span class="line">    |  dec_info_ptr = 0x03F75488</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-007|IMG_DEC_Destroy_Hal(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    handle = 66540680,</span><br><span class="line">    |    exit_type = IMG_DEC_EXIT_HALT)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-008|IMG_DEC_Remove_Command(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  ret = IMG_DEC_RET_SUCCESS</span><br><span class="line">    |  dec_handle_ptr = 0x03FDD4E0</span><br><span class="line">    |  tmp_cmd_ptr = 0x03EBBFCC</span><br><span class="line">    |  cur_cmd_ptr = 0x03EC0700</span><br><span class="line">    |  next_cmd_ptr = 0x0</span><br><span class="line">    |  pre_cmd_ptr = 0x03EBBFCC</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-009|IMG_DEC_Task_Routine(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  command = 2</span><br><span class="line">    |  param0 = 2241919696</span><br><span class="line">    |  param2 = 0</span><br><span class="line">    |  sig_ptr = 0x03EC0604</span><br><span class="line">    |  handle = 2241919696</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-010|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x003AD589, argc = 0, argv = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-011|tx_thread_shell_entry()</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>通过 ass 文件，也能够看出 T_IMG_DEC Task 被 JPEG_FREE_RES_SEMAP 挂起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; JPEG_FREE_RES_SEMAP                    0          </span><br><span class="line"> &gt; Suspend Task_Name :  T_IMG_DEC</span><br></pre></td></tr></table></figure><p>根据这些 callback 继续分析代码，得到如下的结论：<br>应用窗体在丢失焦点时会发消息让 T_IMG_DEC 执行销毁流程，而 T_IMG_DEC拿到锁执行 JPEGDEC_DestroyHandle 销毁流程，这个执行过程中会释放 JPEG_FREE_RES_SEMAP；此时 T_JPEG_DECODER 从挂起状态解除，但是因为在 JPEGDEC_DestroyHandle 前面被销毁了，导致不能执行。两个 task 都不能执行，所以导致 timeout。 </p><h2 id="Task-Queue-Full问题"><a href="#Task-Queue-Full问题" class="headerlink" title="Task Queue Full问题"></a>Task Queue Full问题</h2><p>消息队列满现象为Assert提示：ASSERT: Error 0xb (The queue was full !)，直接原因为接收消息的Task得不到执行，导致消息队列满，而在发送消息的任务检测到无法发送消息，直接报告消息队列满错误。</p><p>可能原因如下：<br>1.Task优先级太低，一直无法得到执行。<br>2.Task因为某些原因（比如死锁或信号量等）无法处理消息，可以分析代码逻辑。<br>3.中断处理太多，导致Task得不到执行，可以通过通过TaskAnalyzer工具分析中断原因。<br>4.关中断时间太长，导致Task得不到执行，尽量减少关中断的时间。<br>5.消息队列长度设置不正确，可以增加Queue Size。</p><p>此问题分析关键：首先找到无法处理消息的Task，而后逐条分析，包括当前Task队列的消息检查，也可以在Assert窗口输入命令“6”，输出Task的各项信息，寻找可用Queue数目为0的Task，这个Task就是问题点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">-000|TXAS_SaveMainReg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    cur_lr = 0x0108D1CE,</span><br><span class="line">    |    cur_pc = 0x80 -&gt; 0)</span><br><span class="line">-001|TXAS_SystemAssert(</span><br><span class="line">    |    exp = 0x023482FC -&gt; ,</span><br><span class="line">    |    file = 0x00377A80 -&gt; ,</span><br><span class="line">    |    line = 810,</span><br><span class="line">    |    assert_info_ptr = 0x0 -&gt; NULL)</span><br><span class="line">    |  assert_mode = 1</span><br><span class="line">    |  cur_sp = 36994960</span><br><span class="line">    |  cur_lr = 3666785</span><br><span class="line">    |  cur_pc = 7830016</span><br><span class="line">    |  i = 11666952</span><br><span class="line">    |  tem_str = &quot;RTOS/source/src_osa/c/threadx_os.c&quot;</span><br><span class="line">-002|SCI_Assert(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-003|SCI_SendSignal(</span><br><span class="line">    |    signal_ptr = 0x03EB67C8,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  status = 11</span><br><span class="line">-004|MMISRV_CAMERAROLL_Download_Thumbnail()</span><br><span class="line">    |  sig_ptr = 0x03EB67C8 -&gt; (</span><br><span class="line">    |    sig = (SignalCode = 1, SignalSize = 20, Pre = 0x0, Suc = 0x0, Sender = 21),</span><br><span class="line">    |    data_ptr = 0x0)</span><br><span class="line">-005|HandlePicListWinMsg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  result = 1</span><br><span class="line">    |  title_str = (wstr_ptr = 0x0, wstr_len = 0)</span><br><span class="line">    |  query_win_id = 2359321</span><br><span class="line">    |  mark_wstr = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |  mark_num_str = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |  mark_num_wstr = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">    |  data_info = (is_bitmap = 76, is_free_bitmap = 12, is_save_data = 185, data_ptr = 0xF</span><br><span class="line">-006|MMK_RunWinProc(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 53255,</span><br><span class="line">    |    param = 0x026B9D14)</span><br><span class="line">-007|MMK_DispatchToHandle(</span><br><span class="line">    |    handle = 62717996,</span><br><span class="line">    |    msg_id = 53255,</span><br><span class="line">    |    param_ptr = 0x026B9D14)</span><br><span class="line">    |  openwin_handle_result = 0</span><br><span class="line">    |  old_handle = 16711680</span><br><span class="line">-008|MMK_SendMsg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 53255,</span><br><span class="line">    |    param_ptr = 0x026B9D14)</span><br><span class="line">    |  result = 0</span><br><span class="line">-009|MMIAPIPICVIEW_HandleCameraRollSig(</span><br><span class="line">    |    msg_id = 53255,</span><br><span class="line">    |    param = 0x026B9D14)</span><br><span class="line">-010|HandlePsAndRefMsg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 53255,</span><br><span class="line">    |    param = 0x026B9D14)</span><br><span class="line">    |  result = 1</span><br><span class="line">-011|DispatchSysSig(</span><br><span class="line">    |    signal_ptr = 0x026B9D14)</span><br><span class="line">    |  i = 131</span><br><span class="line">    |  regapp_num = 245</span><br><span class="line">-012|MMK_DispatchExtSig(</span><br><span class="line">    |  ?)</span><br><span class="line">-013|thread_entry_P_APP(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  receiveSignal = 0x026B9D14</span><br><span class="line">    |  mmi_msg = 0x03FA1410</span><br><span class="line">    |  ticks1 = 0</span><br><span class="line">    |  ticks2 = 0</span><br><span class="line">    |  is_log_on = 0</span><br><span class="line">    |  time_period = 4294967295</span><br><span class="line">    |  watchdog_ptr = 0x03EBE534</span><br><span class="line">-014|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x08EFC94B, argc = 0, argv = 0x0)</span><br><span class="line">-015|tx_thread_shell_entry()</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>结合代码能够看到，函数 <code>MMISRV_CAMERAROLL_Download_Thumbnail()</code> 发送消息给 T_P_APP_CAMERAROLL_TASK 时，发现该Task消息队列满。</p><p>查看ASS文件，发现 T_P_APP_CAMERAROLL_TASK 消息队列确实已满：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task_ID Name Tcb_Addr Current_PC  Queue_All Queue_Avail </span><br><span class="line">0xaf T_P_APP_CAMERAR 0x01ceaf800 x002127d0 20 0     </span><br><span class="line">TX_READY 206</span><br></pre></td></tr></table></figure><p>查看T_P_APP_CAMERAROLL_TASK callback，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-000|tx_thread_suspend(</span><br><span class="line">    |  ?)</span><br><span class="line">    |</span><br><span class="line">-001|tx_queue_receive(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_ptr = 0x01CEAF88</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-002|txe_queue_receive(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-003|SCI_GetSignal(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  item = 66974816</span><br><span class="line">    |  thread_block = 0x01CEAF80</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-004|CAMERAROLL_Task(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-005|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x08074DD5, argc = 0, argv = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">-006|tx_thread_shell_entry()</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>通过TaskAnalyzer内存打点信息可以看出，T_P_APP以及网络相关高优先级的Task被频繁调度，导致低优先级的 T_P_APP_CAMERAROLL_TASK 得不到调度，通过分析T_P_APP_CAMERAROLL_TASK 消息类型，发现是T_P_APP一直在重复频繁发送如下三个消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xAD14:HTTP_SIG_GET_CNF</span><br><span class="line">0XAD18:HTTP_SIG_HEADER_IND</span><br><span class="line">0xAD1A:HTTP_SIG_DATA_IND</span><br></pre></td></tr></table></figure><p><img src="//tinylaker.github.io/2019/11/14/sc770x-稳定性问题分析/11.png" alt="queue"></p><p>分析代码问题原因：CAMERAROLL_TASK 并发使用了12个Http，但是对应的Queue只有20个，并不能支持场景使用。最优解是增加Queue个数，同时降低Http并发个数。</p><h2 id="栈溢出问题"><a href="#栈溢出问题" class="headerlink" title="栈溢出问题"></a>栈溢出问题</h2><p>栈溢出的可能原因如下：<br>1.栈空间分配太小，不足以满足大量局部变量的使用场景，应尽量使用堆区动态内存。<br>2.函数调用层次过多，或者陷入递归死循环当中。<br>3.栈空间内存异常，可能发生内存覆盖导致栈空间数据异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">-000|TXAS_SaveMainReg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    cur_lr = 0x0108D1CE,</span><br><span class="line">    |    cur_pc = 0x80)</span><br><span class="line">-001|TXAS_SystemAssert(</span><br><span class="line">    |    exp = 0x0021873C,</span><br><span class="line">    |    file = 0x00218710,</span><br><span class="line">    |    line = 763,</span><br><span class="line">    |    assert_info_ptr = 0x00C35F3D -&gt; &quot;Stack Overflow,thread:0x1e00dd8,sp overflow addr:0x2459928,thread ID:0x15,Tx Name:T_P_APP&quot;)</span><br><span class="line">    |  assert_mode = 1</span><br><span class="line">    |  cur_sp = 66875528</span><br><span class="line">    |  cur_lr = 3778945</span><br><span class="line">    |  cur_pc = 8533360</span><br><span class="line">    |  i = 12387240</span><br><span class="line">-002|SCI_PAssert(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-003|prod_thread_stack_overflow_handle(</span><br><span class="line">    |  ?)</span><br><span class="line">-004|tx_thread_stack_error_handler(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  interrupt_save = 128</span><br><span class="line">-005|tx_thread_suspend(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  interrupt_save = 536870912</span><br><span class="line">-006|tx_event_flags_get(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_ptr = 0x01E07050</span><br><span class="line">-007|txe_event_flags_get(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |    get_option = 1,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">-008|SCI_GetEvent(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?,</span><br><span class="line">    |    get_option = 1,</span><br><span class="line">    |  ?)</span><br><span class="line">-009|mta_ex_trace_task(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  actual_flag = 2</span><br><span class="line">    |  request_flag = 2</span><br><span class="line">-010|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x003C76EB, argc = 0, argv = 0x0)</span><br><span class="line">-011|tx_thread_shell_entry()</span><br><span class="line"> ---|end of frame</span><br></pre></td></tr></table></figure><p>根据上面callback的提示信息，T_P_APP Task存在栈溢出，<code>tx_stack_ptr = 0x2459928</code> 超出了进程的栈帧起始地址 <code>tx_stack_start_=_0x02462728</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  (TX_THREAD*)0x1E00DE0 = 0x01E00DE0 -&gt; (</span><br><span class="line">    tx_thread_id = 1414025796,</span><br><span class="line">    tx_run_count = 3138736,</span><br><span class="line">    tx_stack_ptr = 0x02459928,</span><br><span class="line">    tx_stack_start_=_0x02462728,</span><br><span class="line">    tx_stack_end = 0x02469F23,</span><br><span class="line">    tx_stack_size = 30716,</span><br><span class="line">    tx_time_slice = 0,</span><br><span class="line">    tx_new_time_slice = 0,</span><br><span class="line">    tx_ready_next = 0x01E00DE0,</span><br><span class="line">    tx_ready_previous = 0x01E00DE0,</span><br><span class="line">    tx_thread_name = 0x00202A60 -&gt; &quot;T_P_APP&quot;,</span><br><span class="line">    tx_priority = 76,</span><br><span class="line">    tx_state = 0,</span><br><span class="line">    tx_delayed_suspend = 0,</span><br><span class="line">    tx_suspending = 0,</span><br><span class="line">    tx_preempt_threshold = 76,</span><br><span class="line">    tx_priority_bit = (0, 0, 4096, 0, 0, 0, 0, 0),</span><br><span class="line">    tx_thread_entry = 0x003B1FF7,</span><br><span class="line">    tx_entry_parameter = 65597768,</span><br><span class="line">    tx_thread_timer = (tx_remaining_ticks = 0, tx_re_initialize_ticks = 0, tx_ti</span><br><span class="line">    tx_suspend_cleanup = 0x0,</span><br><span class="line">    tx_suspend_control_block = 0x01E00ED4,</span><br><span class="line">    tx_suspended_next = 0x01E00DE0,</span><br><span class="line">    tx_suspended_previous = 0x01E00DE0,</span><br><span class="line">    tx_suspend_info = 4,</span><br><span class="line">    tx_additional_suspend_info = 0x02469570,</span><br><span class="line">    tx_suspend_option = 1,</span><br><span class="line">    tx_suspend_status = 0,</span><br><span class="line">    tx_created_next = 0x01E01290,</span><br><span class="line">    tx_created_previous = 0x01DFFFD0,</span><br><span class="line">    tx_filex_ptr = 0x0,</span><br><span class="line">    time = 0,</span><br><span class="line">tx_thread_stack_highest_ptr = 0x02459928)</span><br></pre></td></tr></table></figure><p>手动推导T_P_APP Task callback发现，存在000～003死循环导致栈溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">-000|HandlePicListWinMsg(</span><br><span class="line">    |    win_id = 2359300,</span><br><span class="line">    |    msg_id = 64004,</span><br><span class="line">    |    param = 0xFA04)</span><br><span class="line">    |  title_str = (wstr_ptr = 0x0, wstr_len = 0)</span><br><span class="line">    |  query_win_id = 2359321</span><br><span class="line">    |  mark_wstr = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |  mark_num_str = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |  mark_num_wstr = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |</span><br><span class="line">-001|MMK_RunWinProc(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 64004,</span><br><span class="line">    |    param = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-002|MMK_DispatchToHandle(</span><br><span class="line">    |    handle = 3217293358,</span><br><span class="line">    |    msg_id = 64004,</span><br><span class="line">    |    param_ptr = 0x0)</span><br><span class="line">    |  openwin_handle_result = 0</span><br><span class="line">    |  old_handle = 3217293358</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-003|MMK_SendMsg(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 64004,</span><br><span class="line">    |    param_ptr = 0x0)</span><br><span class="line">    |  result = 0</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-004|HandlePicListWinMsg(</span><br><span class="line">    |    win_id = 2359300,</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  result = 1</span><br><span class="line">    |  title_str = (wstr_ptr = 0x0, wstr_len = 0)</span><br><span class="line">    |  query_win_id = 2359321</span><br><span class="line">    |  mark_wstr = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |  mark_num_str = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |  mark_num_wstr = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">    |  data_info = (is_bitmap = 0, is_free_bitmap = 0, is_save_data = 0, data_pt</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-005|MMK_RunWinProc(</span><br><span class="line">    |  ?,</span><br><span class="line">    |    msg_id = 64004,</span><br><span class="line">    |    param = 0x02469E64)</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-006|MMK_DispatchToHandle(</span><br><span class="line">    |    handle = 3217293358,</span><br><span class="line">    |    msg_id = 64004,</span><br><span class="line">    |    param_ptr = 0x02469E64)</span><br><span class="line">    |  openwin_handle_result = 0</span><br><span class="line">    |  old_handle = 16711680</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-007|MMK_DispMsgToFocusWin(</span><br><span class="line">    |    msg_id = 64004,</span><br><span class="line">    |    param_ptr = 0x02469E64)</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-008|MMK_DispMsgToWin(</span><br><span class="line">    |    msg_id = 64004,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  result = 0</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-009|HandleMSGKbd(</span><br><span class="line">    |    keys_status = 64000,</span><br><span class="line">    |    key_code = 4)</span><br><span class="line">    |  multi_key_tp_param = (is_slide = 0, pre_tp_point = (x = 0, y = 0), cur_tp</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-010|MMK_DispatchMSGKbd(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  keypress_ptr = 0x03EAE9C8</span><br><span class="line">    |  key_code = 4</span><br><span class="line">    |  is_long_press = 0</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-011|MMK_DispatchExtSig(</span><br><span class="line">    |  ?)</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-012|thread_entry_P_APP(</span><br><span class="line">    |  ?,</span><br><span class="line">    |  ?)</span><br><span class="line">    |  receiveSignal = 0x03EAE9C8</span><br><span class="line">    |  mmi_msg = 0x03FA0650</span><br><span class="line">    |  ticks1 = 0</span><br><span class="line">    |  ticks2 = 0</span><br><span class="line">    |  is_log_on = 0</span><br><span class="line">    |  time_period = 4294967295</span><br><span class="line">    |  watchdog_ptr = 0x03EBE978</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-013|ThreadEntry(</span><br><span class="line">    |  ?)</span><br><span class="line">    |  thread_entry = (entry = 0x08004393, argc = 0, argv = 0x0)</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line">-014|tx_thread_shell_entry()</span><br><span class="line">    |</span><br><span class="line">    |                                                                           </span><br><span class="line"> ---|end of frame</span><br><span class="line">    |</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过MTBF和Monkey测试会暴露出各种问题，需要借助于丰富的调试方法进行分析定位。当然除了常规的调试手法，我们也借助AMBA Bus Monitor监控指定的代码段，包括boot、kernel、dsp等区域，以定位内存区域复写的异常情况。</p><p>1.MTBF测试明确了平均故障间隔时间，可以反映出产品的时间质量。<br>2.Monkey压力测试，保证产品的软硬件稳定性。<br>3.EUT Release版本测试，此时大部分问题已经收敛，该阶段问题不易复现，可能安排各种专项测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录总结了笔者曾经参与的sc770x项目，基于 Trace32 Simulator 定位系统稳定性问题，这是 Lauterbach 公司推出的一款嵌入式系统调试工具，支持多种 CPU 和 RTOS 调试，拥有很强的扩展性，支持CMM脚本扩展。&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="Product" scheme="http://tinylaker.github.io/categories/Product/"/>
    
    
      <category term="performance" scheme="http://tinylaker.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>Android GUI框架简介</title>
    <link href="http://tinylaker.github.io/2019/11/11/Android-GUI%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
    <id>http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/</id>
    <published>2019-11-11T12:28:05.000Z</published>
    <updated>2019-12-05T13:41:21.740Z</updated>
    
    <content type="html"><![CDATA[<p>在谈及 Android GUI 框架前，先从底层视角梳理一下显示的流程。在 Android 系统中，引入了状态栏、导航栏、壁纸和背景的图层概念，需要把这些图层进行 alpha blending 后显示。</p><p>在嵌入式 linux 系统下显示界面，可以直接操作 framebuffer 的内存；但 Android 应用并不能直接操作 framebuffer，应用需要借助 SurfaceFlinger。</p><p>SurfaceFlinger 通过 Gralloc HAL 向 ashmem 申请内存，供应用使用。同时使用 OpenGL 和 HardwareComposer 来合成 Surface。</p><h1 id="SurfaceFlinger内部机制"><a href="#SurfaceFlinger内部机制" class="headerlink" title="SurfaceFlinger内部机制"></a>SurfaceFlinger内部机制</h1><p>可以把应用理解为客户端，SurfaceFlinger 理解为服务端，在 SurfaceFlinger 中用 Client 对象表示应用，有多少个应用就有多少个 Client 对象。</p><p>Client 对象中包含了 Layer 对象，用来对应应用层的 SurfaceControl ；其中 Layer 对象包含消费者 mSurfaceFlingerConsumer 和 生产者 mBufferQueue 成员变量，并在 onFirstRef() 方法中构建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceFlingerConsumer&gt; mSurfaceFlingerConsumer;</span><br><span class="line">sp&lt;BufferQueue&gt; mBufferQueue;</span><br></pre></td></tr></table></figure><p>与之对应的， Surface 对象中包含生产者 mGraphicBufferProducer 和 BufferSlot ，后者是 Surface 内部存储 buffer 的地方，最多有32个，仅当 dequeueBuffer 时才会分配真正的空间。这里基本可以看出 Surface 对象是通过 mGraphicBufferProducer 来获取 buffer ，并将它记录在 mSlots 数组中供后续使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferProducer&gt; mGraphicBufferProducer;</span><br><span class="line">BufferSlot mSlots[NUM_BUFFER_SLOTS];</span><br><span class="line"></span><br><span class="line">struct BufferSlot &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">    Region dirtyRegion;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过系统的测试用例 resize 了解应用的基本流程，追踪代码分析 SurfaceFlinger 的工作方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/tests/resize/resize.cpp</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    // set up the thread-pool</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    // create a client to surfaceflinger</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient(); //&lt;1&gt;</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;createSurface(String8(&quot;resize&quot;), 160, 240, PIXEL_FORMAT_RGB_565, 0);    //&lt;2&gt;</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;getSurface(); //&lt;3&gt;</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    surfaceControl-&gt;setLayer(100000);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    surface-&gt;lock(&amp;outBuffer, NULL);    //&lt;4&gt;</span><br><span class="line">    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    android_memset16((uint16_t*)outBuffer.bits, 0xF800, bpr*outBuffer.height);</span><br><span class="line">    surface-&gt;unlockAndPost();   &lt;5&gt;</span><br><span class="line"></span><br><span class="line">    surface-&gt;lock(&amp;outBuffer);</span><br><span class="line">    android_memset16((uint16_t*)outBuffer.bits, 0x07E0, bpr*outBuffer.height);</span><br><span class="line">    surface-&gt;unlockAndPost();</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    surfaceControl-&gt;setSize(320, 240);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的流程图如下：</p><p><img src="//tinylaker.github.io/2019/11/11/Android-GUI框架简介/surface.png" alt="SurfaceFlinger"></p><h2 id="SurfaceComposerClient"><a href="#SurfaceComposerClient" class="headerlink" title="SurfaceComposerClient"></a>SurfaceComposerClient</h2><p>当应用程序请求 SurfaceFlinger 服务时，首先需要构造 SurfaceComposerClient 对象，通过 SurfaceComposerClient 对象访问 SurfaceFlinger 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/include/gui/SurfaceComposerClient.h</span><br><span class="line"></span><br><span class="line">class SurfaceComposerClient : public RefBase</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    virtual void onFirstRef();</span><br><span class="line">    Composer&amp; getComposer();</span><br><span class="line"></span><br><span class="line">    mutable     Mutex                       mLock;</span><br><span class="line">                status_t                    mStatus;</span><br><span class="line">                sp&lt;ISurfaceComposerClient&gt;  mClient;</span><br><span class="line">                Composer&amp;                   mComposer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 SurfaceComposerClient 继承于 RefBase 类，在创建 SurfaceComposerClient 对象后，第一次引用对象时，调用 onFirstRef() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">    : mStatus(NO_INIT), mComposer(Composer::getInstance())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line">    //获取 BpSurfaceComposer 的实例化对象</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());</span><br><span class="line">    if (sm != 0) &#123;</span><br><span class="line">        //获取 BpSurfaceComposerClient 实例化对象</span><br><span class="line">        sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">        if (conn != 0) &#123;</span><br><span class="line">            mClient = conn;</span><br><span class="line">            mStatus = NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onFirstRef() 方法首先调用 ComposerService 类的 getComposerService() 方法获取 SurfaceFlinger 的代理对象 BpSurfaceComposer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">/*static*/ sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();</span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    if (instance.mComposerService == NULL) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != NULL);</span><br><span class="line">        ALOGD(&quot;ComposerService reconnected&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance.mComposerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过单例模式调用 getInstance() 方法构造 ComposerService 对象，期间会调用 connectLocked() 方法获取 BpServiceComposer 服务的代理对象 ，并保存到成员变量 mComposerService 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">ANDROID_SINGLETON_STATIC_INSTANCE(ComposerService);</span><br><span class="line"></span><br><span class="line">ComposerService::ComposerService()</span><br><span class="line">: Singleton&lt;ComposerService&gt;() &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    connectLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ComposerService::connectLocked() &#123;</span><br><span class="line">    const String16 name(&quot;SurfaceFlinger&quot;);</span><br><span class="line">    while (getService(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        usleep(250000);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(mComposerService != NULL);</span><br><span class="line"></span><br><span class="line">    // Create the death listener.</span><br><span class="line">    class DeathObserver : public IBinder::DeathRecipient &#123;</span><br><span class="line">        ComposerService&amp; mComposerService;</span><br><span class="line">        virtual void binderDied(const wp&lt;IBinder&gt;&amp; who) &#123;</span><br><span class="line">            ALOGW(&quot;ComposerService remote (surfaceflinger) died [%p]&quot;,</span><br><span class="line">                  who.unsafe_get());</span><br><span class="line">            mComposerService.composerServiceDied();</span><br><span class="line">        &#125;</span><br><span class="line">     public:</span><br><span class="line">        DeathObserver(ComposerService&amp; mgr) : mComposerService(mgr) &#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mDeathObserver = new DeathObserver(*const_cast&lt;ComposerService*&gt;(this));</span><br><span class="line">    mComposerService-&gt;asBinder()-&gt;linkToDeath(mDeathObserver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经获取到 BpSurfaceComposer 对象，调用它的 createConnection() 方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="line"></span><br><span class="line">class BpSurfaceComposer : public BpInterface&lt;ISurfaceComposer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BpSurfaceComposer(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;ISurfaceComposer&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">virtual sp&lt;ISurfaceComposerClient&gt; createConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        uint32_t n;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(BnSurfaceComposer::CREATE_CONNECTION, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;ISurfaceComposerClient&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createConnection() 方法中调用 <code>remote()-&gt;transact</code> 会导致 SurfaceFlinger 类的 onTransact()方法被调用，进而调用 BnSurfaceComposer::onTransact() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case CREATE_CONNECTION:</span><br><span class="line">        case CREATE_DISPLAY:</span><br><span class="line">        case SET_TRANSACTION_STATE:</span><br><span class="line">        case BOOT_FINISHED:</span><br><span class="line">        case BLANK:</span><br><span class="line">        case UNBLANK:</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = BnSurfaceComposer::onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="line"></span><br><span class="line">status_t BnSurfaceComposer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_CONNECTION: &#123;</span><br><span class="line">            CHECK_INTERFACE(ISurfaceComposer, data, reply);</span><br><span class="line">            sp&lt;IBinder&gt; b = createConnection()-&gt;asBinder();</span><br><span class="line">            reply-&gt;writeStrongBinder(b);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        default: &#123;</span><br><span class="line">            return BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger 继承 BnSurfaceComposer，作为 Binder 的服务端，复写了 createConnection()方法，该方法会构造 Client 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.h</span><br><span class="line"></span><br><span class="line">class SurfaceFlinger : public BnSurfaceComposer,</span><br><span class="line">                        private IBinder::DeathRecipient,</span><br><span class="line">                        private HWComposer::EventHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/include/gui/ISurfaceComposer.h</span><br><span class="line"></span><br><span class="line">class BnSurfaceComposer: public BnInterface&lt;ISurfaceComposer&gt;                        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line">    sp&lt;Client&gt; client(new Client(this));</span><br><span class="line">    status_t err = client-&gt;initCheck();</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        bclient = client;</span><br><span class="line">    &#125;</span><br><span class="line">    return bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client 继承 BnSurfaceComposerClient ，保存 SurfaceFlinger 对象的引用到成员变量 mFlinger。最终应用程序通过 <code>ISurfaceComposer::createConnection()</code> 方法获得 BpSurfaceComposerClient 代理对象，并将其保存在成员变量 mClient 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"></span><br><span class="line">Client::Client(const sp&lt;SurfaceFlinger&gt;&amp; flinger)</span><br><span class="line">    : mFlinger(flinger)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：应用程序创建 SurfaceFlinger Client，需要首先获取 SurfaceFlinger 服务，通过 SurfaceFlinger::createConnection() 方法建立应用程序和 SurfaceFlinger 的连接。SurfaceFlinger 会创建一个 BnSurfaceComposerClient 本地对象，同时应用程序会得到一个 BpSurfaceComposerClient 代理类对象，后面会通过这个代理类对象创建 Surface。</p><h2 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a>SurfaceControl</h2><p>根据 SurfaceComposerClient 对象创建 SurfafeControl 对象，其实就是通过 SurfaceFlinger 创建 Layer，下面分析代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        uint32_t w,</span><br><span class="line">        uint32_t h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    if (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">        status_t err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">                &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, &quot;SurfaceComposerClient::createSurface error %s&quot;, strerror(-err));</span><br><span class="line">        if (err == NO_ERROR) &#123;</span><br><span class="line">            sur = new SurfaceControl(this, handle, gbp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remote()-&gt;transact</code> 根据 Binder 机制，调用 BnSurfaceComposerClient::onTransact() 本地方法，进而调用到 Client::createSurface() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ISurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">class BpSurfaceComposerClient : public BpInterface&lt;ISurfaceComposerClient&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    virtual status_t createSurface(const String8&amp; name, uint32_t w,</span><br><span class="line">                uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp) &#123;</span><br><span class="line">          Parcel data, reply;</span><br><span class="line">          data.writeInterfaceToken(ISurfaceComposerClient::getInterfaceDescriptor());</span><br><span class="line">          data.writeString8(name);</span><br><span class="line">          data.writeInt32(w);</span><br><span class="line">          data.writeInt32(h);</span><br><span class="line">          data.writeInt32(format);</span><br><span class="line">          data.writeInt32(flags);</span><br><span class="line">          remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">          *handle = reply.readStrongBinder();</span><br><span class="line">          *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">          return reply.readInt32();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BnSurfaceComposerClient::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_SURFACE: &#123;</span><br><span class="line">            CHECK_INTERFACE(ISurfaceComposerClient, data, reply);</span><br><span class="line">            String8 name = data.readString8();</span><br><span class="line">            uint32_t w = data.readInt32();</span><br><span class="line">            uint32_t h = data.readInt32();</span><br><span class="line">            PixelFormat format = data.readInt32();</span><br><span class="line">            uint32_t flags = data.readInt32();</span><br><span class="line">            sp&lt;IBinder&gt; handle;</span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">            status_t result = createSurface(name, w, h, format, flags,</span><br><span class="line">                    &amp;handle, &amp;gbp);</span><br><span class="line">            reply-&gt;writeStrongBinder(handle);</span><br><span class="line">            reply-&gt;writeStrongBinder(gbp-&gt;asBinder());</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createSurface() 方法定义了一个消息类 MessageCreateLayer ，然后把它的对象通过 postMessageSync() 方法发送出去，这个消息是以同步的方式发送，因此函数结束后可以直接返回结果。所以会调用到消息处理方法 handler()，直接调用 <code>SurfaceFlinger::createLayer()</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"></span><br><span class="line">status_t Client::createSurface(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    class MessageCreateLayer : public MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        status_t result;</span><br><span class="line">        const String8&amp; name;</span><br><span class="line">        uint32_t w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">    public:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                const String8&amp; name, Client* client,</span><br><span class="line">                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">            handle(handle), gbp(gbp),</span><br><span class="line">            name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        status_t getResult() const &#123; return result; &#125;</span><br><span class="line">        virtual bool handler() &#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, this, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createLayer() 方法根据 flags 参数选择创建不同类型的 Layer ( NormalLayer 和 DimLayer )，这里以 createNormalLayer 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::createLayer(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    //ALOGD(&quot;createLayer for (%d x %d), name=%s&quot;, w, h, name.string());</span><br><span class="line">    if (int32_t(w|h) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;createLayer() failed, w or h is negative (w=%d, h=%d)&quot;,</span><br><span class="line">                int(w), int(h));</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line"></span><br><span class="line">    switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceNoDisp:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            break;</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result == NO_ERROR) &#123;</span><br><span class="line">        addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">        if(!(flags &amp; ISurfaceComposerClient::eFXSurfaceNoDisp)) &#123;</span><br><span class="line">            setTransactionFlags(eTransactionNeeded);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ALOGD(&quot;%s flags=%x&quot;, __FUNCTION__, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createNormalLayer() 方法根据 format 参数不同创建 Layer 对象 outLayer ，调用 Layer::getHandle() 方法赋值给 handle，调用 Layer::getBufferQueue() 方法赋值给 gbp 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span><br><span class="line">&#123;</span><br><span class="line">    // initialize the surfaces</span><br><span class="line">    switch (format) &#123;</span><br><span class="line">    case PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    case PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">        break;</span><br><span class="line">    case PIXEL_FORMAT_OPAQUE:</span><br><span class="line">#ifdef NO_RGBX_8888</span><br><span class="line">        format = PIXEL_FORMAT_RGB_565;</span><br><span class="line">#else</span><br><span class="line">        format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">#endif</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef NO_RGBX_8888</span><br><span class="line">    if (format == PIXEL_FORMAT_RGBX_8888)</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    *outLayer = new Layer(this, client, name, w, h, flags);</span><br><span class="line">    status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">        *gbp = (*outLayer)-&gt;getBufferQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE_IF(err, &quot;createNormalLayer() failed (%s)&quot;, strerror(-err));</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下 Layer 类的构造方法和 onFirstRef() 方法的实现，这里会构造图像缓冲区队列 BufferQueue ，同时创建消费者对象 SurfaceFlingerConsumer 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Layer::Layer(SurfaceFlinger* flinger, const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags)</span><br><span class="line">    :   contentDirty(false),</span><br><span class="line">        sequence(uint32_t(android_atomic_inc(&amp;sSequence))),</span><br><span class="line">        mFlinger(flinger),</span><br><span class="line">        mTextureName(-1U),</span><br><span class="line">        mPremultipliedAlpha(true),</span><br><span class="line">        mName(&quot;unnamed&quot;),</span><br><span class="line">        mDebug(false),</span><br><span class="line">        mFormat(PIXEL_FORMAT_NONE),</span><br><span class="line">        mOpaqueLayer(true),</span><br><span class="line">        mTransactionFlags(0),</span><br><span class="line">        mQueuedFrames(0),</span><br><span class="line">        mCurrentTransform(0),</span><br><span class="line">        mCurrentScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),</span><br><span class="line">        mCurrentOpacity(true),</span><br><span class="line">        mRefreshPending(false),</span><br><span class="line">        mFrameLatencyNeeded(false),</span><br><span class="line">        mFiltering(false),</span><br><span class="line">        mNeedsFiltering(false),</span><br><span class="line">        mMesh(Mesh::TRIANGLE_FAN, 4, 2, 2),</span><br><span class="line">        mSecure(false),</span><br><span class="line">        mProtectedByApp(false),</span><br><span class="line">        mHasSurface(false),</span><br><span class="line">        mClientRef(client),</span><br><span class="line">        mCaptureScreen(false)</span><br><span class="line">&#123;</span><br><span class="line">    mCurrentCrop.makeInvalid();</span><br><span class="line">    mFlinger-&gt;getRenderEngine().genTextures(1, &amp;mTextureName);</span><br><span class="line">    mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line"></span><br><span class="line">    uint32_t layerFlags = 0;</span><br><span class="line">    if (flags &amp; ISurfaceComposerClient::eHidden)</span><br><span class="line">        layerFlags = layer_state_t::eLayerHidden;</span><br><span class="line"></span><br><span class="line">    if (flags &amp; ISurfaceComposerClient::eNonPremultiplied)</span><br><span class="line">        mPremultipliedAlpha = false;</span><br><span class="line"></span><br><span class="line">    mName = name;</span><br><span class="line"></span><br><span class="line">    mCurrentState.active.w = w;</span><br><span class="line">    mCurrentState.active.h = h;</span><br><span class="line">    mCurrentState.active.crop.makeInvalid();</span><br><span class="line">    mCurrentState.z = 0;</span><br><span class="line">    mCurrentState.alpha = 0xFF;</span><br><span class="line">    mCurrentState.layerStack = 0;</span><br><span class="line">    mCurrentState.flags = layerFlags;</span><br><span class="line">    mCurrentState.sequence = 0;</span><br><span class="line">    mCurrentState.transform.set(0, 0);</span><br><span class="line">    mCurrentState.requested = mCurrentState.active;</span><br><span class="line"></span><br><span class="line">    // drawing state &amp; current state are identical</span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    nsecs_t displayPeriod =</span><br><span class="line">            flinger-&gt;getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    mFrameTracker.setDisplayRefreshPeriod(displayPeriod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Layer::onFirstRef() &#123;</span><br><span class="line">    // Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span><br><span class="line">    mBufferQueue = new SurfaceTextureLayer(mFlinger);</span><br><span class="line">    mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(mBufferQueue, mTextureName);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setFrameAvailableListener(this);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"></span><br><span class="line">#ifdef TARGET_DISABLE_TRIPLE_BUFFERING</span><br><span class="line">#warning &quot;disabling triple buffering&quot;</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(2);</span><br><span class="line">#else</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(3);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">    updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferQueue 是 IGraphicBufferProducer 服务端的实现，类的内部有个成员数组 <code>BufferSlot mSlots[NUM_BUFFER_SLOTS]</code>，这与 Surface 类中 BufferSlot 的定义并不一样。这里 mGraphicBuffer 用以记录 BufferSlot 的缓冲区，mBufferState 用来追踪每个缓冲区的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/include/gui/BufferQueue.h</span><br><span class="line"></span><br><span class="line">class BufferQueue : public BnGraphicBufferProducer,</span><br><span class="line">                    public BnGraphicBufferConsumer,</span><br><span class="line">                    private IBinder::DeathRecipient &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t dequeueBuffer(int *buf, sp&lt;Fence&gt;* fence, bool async,</span><br><span class="line">            uint32_t width, uint32_t height, uint32_t format, uint32_t usage);    </span><br><span class="line">    </span><br><span class="line">    virtual status_t queueBuffer(int buf,</span><br><span class="line">            const QueueBufferInput&amp; input, QueueBufferOutput* output);</span><br><span class="line">    </span><br><span class="line">    virtual void cancelBuffer(int buf, const sp&lt;Fence&gt;&amp; fence);</span><br><span class="line"></span><br><span class="line">    virtual status_t acquireBuffer(BufferItem *buffer, nsecs_t presentWhen);</span><br><span class="line"></span><br><span class="line">    virtual status_t releaseBuffer(int buf, uint64_t frameNumber,</span><br><span class="line">            EGLDisplay display, EGLSyncKHR fence,</span><br><span class="line">            const sp&lt;Fence&gt;&amp; releaseFence); </span><br><span class="line"></span><br><span class="line">    struct BufferSlot &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line">        enum BufferState &#123;</span><br><span class="line">            FREE = 0,</span><br><span class="line">            DEQUEUED = 1,</span><br><span class="line">            QUEUED = 2,</span><br><span class="line">            ACQUIRED = 3</span><br><span class="line">        &#125;;</span><br><span class="line">        BufferState mBufferState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BufferSlot mSlots[NUM_BUFFER_SLOTS];</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferAlloc&gt; mGraphicBufferAlloc;</span><br><span class="line"></span><br><span class="line">    sp&lt;IConsumerListener&gt; mConsumerListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着调用 addClientLayer() 方法，把 Layer 对象和 SurfaceFlinger 以及应用程序关联起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; gbc,</span><br><span class="line">        const sp&lt;Layer&gt;&amp; lbc)</span><br><span class="line">&#123;</span><br><span class="line">    // attach this layer to the client</span><br><span class="line">    client-&gt;attachLayer(handle, lbc);</span><br><span class="line"></span><br><span class="line">    // add this layer to the current state list</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    mCurrentState.layersSortedByZ.add(lbc);</span><br><span class="line">    mGraphicBufferProducerList.add(gbc-&gt;asBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attachLayer() 将 handle 和 outLayer 添加到 Client::mLayers 成员变量中; SurfaceFlinger 分别使用成员变量 mCurrentState 和 mGraphicBufferProducerList 保存 outLayer 和 gbp 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"></span><br><span class="line">void Client::attachLayer(const sp&lt;IBinder&gt;&amp; handle, const sp&lt;Layer&gt;&amp; layer)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLayers.add(handle, layer);//添加到client的mLayers变量中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面获取的 handle 和 gbp ，构造 SurfaceControl 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceControl.cpp</span><br><span class="line"></span><br><span class="line">SurfaceControl::SurfaceControl(</span><br><span class="line">        const sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">        const sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; gbp)</span><br><span class="line">      : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：通过 SurfaceFlinger 构造 Layer ，然后创建 surfaceControl 对象。该对象有三个参数，第一个参数是 SurfaceComposerClient 代理对象；第二个参数是 handle ，表示 SurfaceControl 的唯一性；第三个参数是 gbp ,表示 Layer 对象中的 GraphicBufferProducer 的生产者代理类对象。</p><h2 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h2><p>通过 SurfaceControl 对象的 getSurface() 方法构造 Surface 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceControl.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() const</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    if (mSurfaceData == 0) &#123;</span><br><span class="line">        // This surface is always consumed by SurfaceFlinger, so the</span><br><span class="line">        // producerControlledByApp value doesn&apos;t matter; using false.</span><br><span class="line">        mSurfaceData = new Surface(mGraphicBufferProducer, false);</span><br><span class="line">    &#125;</span><br><span class="line">    return mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 mGraphicBufferProducer 代理类对象构造 Surface 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Surface::Surface(</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,</span><br><span class="line">        bool controlledByApp)</span><br><span class="line">    : mGraphicBufferProducer(bufferProducer)</span><br><span class="line">&#123;</span><br><span class="line">    // Initialize the ANativeWindow function pointers.</span><br><span class="line">    ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">    ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">    ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">    ANativeWindow::query            = hook_query;</span><br><span class="line">    ANativeWindow::perform          = hook_perform;</span><br><span class="line"></span><br><span class="line">    ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line">    const_cast&lt;int&amp;&gt;(ANativeWindow::minSwapInterval) = 0;</span><br><span class="line">    const_cast&lt;int&amp;&gt;(ANativeWindow::maxSwapInterval) = 1;</span><br><span class="line"></span><br><span class="line">    mReqWidth = 0;</span><br><span class="line">    mReqHeight = 0;</span><br><span class="line">    mReqFormat = 0;</span><br><span class="line">    mReqUsage = 0;</span><br><span class="line">    mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;</span><br><span class="line">    mCrop.clear();</span><br><span class="line">    mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;</span><br><span class="line">    mTransform = 0;</span><br><span class="line">    mDefaultWidth = 0;</span><br><span class="line">    mDefaultHeight = 0;</span><br><span class="line">    mUserWidth = 0;</span><br><span class="line">    mUserHeight = 0;</span><br><span class="line">    mTransformHint = 0;</span><br><span class="line">    mConsumerRunningBehind = false;</span><br><span class="line">    mConnectedToCpu = false;</span><br><span class="line">    mProducerControlledByApp = controlledByApp;</span><br><span class="line">    mSwapIntervalZero = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：当应用程序构建 Surface 的时候， SurfaceFlinger 会创建对应的图层 Layer， 并且把 Layer 的图像缓冲区的生产者对象赋值给 Surface 对象的成员变量 mGraphicBufferProducer ，这样应用程序就可以通过这个生产者接口更新数据。</p><p>那么缓冲区的消费者呢，Layer::onFirstRef() 方法中创建 SurfaceFlingerConsumer 对象，该类间接继承于 ConsumerBase 消费者基类，所以 <code>mSurfaceFlingerConsumer-&gt;setFrameAvailableListener(this)</code> 实际等于 <code>ConsumerBase::setFrameAvailableListener(const Layer &amp;)</code> ，注册 Layer 为 Listener。</p><p>当缓冲区数据准备好，BufferQueue 就会调用 onFrameAvailable() 方法通知消费者，这里还涉及到很多 Binder 的流程，我们暂不关心，只看 Layer::onFrameAvailable() 方法的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ConsumerBase.cpp</span><br><span class="line"></span><br><span class="line">void ConsumerBase::setFrameAvailableListener(</span><br><span class="line">        const wp&lt;FrameAvailableListener&gt;&amp; listener) &#123;</span><br><span class="line">    CB_LOGV(&quot;setFrameAvailableListener&quot;);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    mFrameAvailableListener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ConsumerBase::onFrameAvailable() &#123;</span><br><span class="line">    CB_LOGV(&quot;onFrameAvailable&quot;);</span><br><span class="line"></span><br><span class="line">    sp&lt;FrameAvailableListener&gt; listener;</span><br><span class="line">    &#123; // scope for the lock</span><br><span class="line">        Mutex::Autolock lock(mMutex);</span><br><span class="line">        listener = mFrameAvailableListener.promote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (listener != NULL) &#123;</span><br><span class="line">        CB_LOGV(&quot;actually calling onFrameAvailable&quot;);</span><br><span class="line">        listener-&gt;onFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会去调用 SurfaceFlinger::signalLayerUpdate() 方法发送图层更新消息，通过 handleMessageInvalidate() 方法处理消息，调用 handlePageFlip() 把有效缓冲区换到前台，等待 SurfaceFlinger 合成显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Layer.cpp</span><br><span class="line"></span><br><span class="line">void Layer::onFrameAvailable() &#123;</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">    mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::onMessageReceived(int32_t what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    switch (what) &#123;</span><br><span class="line">    case MessageQueue::TRANSACTION:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        break;</span><br><span class="line">    case MessageQueue::INVALIDATE:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        handleMessageInvalidate();</span><br><span class="line">        signalRefresh();</span><br><span class="line">        break;</span><br><span class="line">    case MessageQueue::REFRESH:</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::handleMessageInvalidate() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    handlePageFlip();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::handlePageFlip()</span><br><span class="line">&#123;</span><br><span class="line">    Region dirtyRegion;</span><br><span class="line"></span><br><span class="line">    bool visibleRegions = false;</span><br><span class="line">    const LayerVector&amp; layers(mDrawingState.layersSortedByZ);</span><br><span class="line">    const size_t count = layers.size();</span><br><span class="line">    for (size_t i=0 ; i&lt;count ; i++) &#123;</span><br><span class="line">        const sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">        const Region dirty(layer-&gt;latchBuffer(visibleRegions));</span><br><span class="line">        const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">        invalidateLayerStack(s.layerStack, dirty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Surface-lock"><a href="#Surface-lock" class="headerlink" title="Surface::lock()"></a>Surface::lock()</h2><p>这里通过前面代码构建的 Surface，获取图像缓冲区内容，首先调用 Surface::dequeueBuffer() 方法申请  Buffer 进行应用层图像绘制。</p><p>BufferQueue 的流程图如下所示：</p><p><img src="//tinylaker.github.io/2019/11/11/Android-GUI框架简介/BufferQueue.png" alt="BufferQueue"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/Surface.cpp</span><br><span class="line"></span><br><span class="line">status_t Surface::lock(</span><br><span class="line">        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">&#123;</span><br><span class="line">    if (!mConnectedToCpu) &#123;</span><br><span class="line">        int err = Surface::connect(NATIVE_WINDOW_API_CPU);</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">        // we&apos;re intending to do software rendering from this point</span><br><span class="line">        setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ANativeWindowBuffer* out;</span><br><span class="line">    int fenceFd = -1;</span><br><span class="line">    status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));</span><br><span class="line">        sp&lt;Fence&gt; fence(new Fence(fenceFd));</span><br><span class="line"></span><br><span class="line">        err = fence-&gt;waitForever(&quot;Surface::lock&quot;);</span><br><span class="line">    </span><br><span class="line">        void* vaddr;</span><br><span class="line">        status_t res = backBuffer-&gt;lock(</span><br><span class="line">                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">                newDirtyRegion.bounds(), &amp;vaddr);     </span><br><span class="line">        </span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLockedBuffer = backBuffer;</span><br><span class="line">            outBuffer-&gt;width  = backBuffer-&gt;width;</span><br><span class="line">            outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">            outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">            outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">            outBuffer-&gt;bits   = vaddr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;</span><br><span class="line">    //申请buffer</span><br><span class="line">    status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, mSwapIntervalZero,</span><br><span class="line">            reqW, reqH, mReqFormat, mReqUsage);</span><br><span class="line"></span><br><span class="line">    //mSlots 在前面有提到，是 Layer 对象中定义的缓冲队列数组，这里获取队列中的第 buf 项</span><br><span class="line">    sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line"></span><br><span class="line">    if (result &amp; IGraphicBufferProducer::RELEASE_ALL_BUFFERS) &#123;</span><br><span class="line">        freeAllBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == 0) &#123;</span><br><span class="line">        // 因为内存是在 SurfaceFlinger 进程中申请的，这里将内存映射到当前 Surface 所在进程</span><br><span class="line">        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    //返回内存对象的指针</span><br><span class="line">    *buffer = gbuf.get();</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mGraphicBufferProducer-&gt;dequeueBuffer()</code> 进而会去调用 <code>BpGraphicBufferProducer::dequeueBuffer()</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class BpGraphicBufferProducer : public BpInterface&lt;IGraphicBufferProducer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t dequeueBuffer(int *buf, sp&lt;Fence&gt;* fence, bool async,</span><br><span class="line">            uint32_t w, uint32_t h, uint32_t format, uint32_t usage) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(async);</span><br><span class="line">        data.writeInt32(w);</span><br><span class="line">        data.writeInt32(h);</span><br><span class="line">        data.writeInt32(format);</span><br><span class="line">        data.writeInt32(usage);</span><br><span class="line">        //这里通过 BpBinder 将相关参数进行序列化，并发送给 BBinder</span><br><span class="line">        status_t result = remote()-&gt;transact(DEQUEUE_BUFFER, data, &amp;reply);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;BpGraphicBufferProducer::dequeueBuffer binder transact failed, result: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取 BBinder 回复的int数据，这里指的是 mSlots 缓冲区数组的索引</span><br><span class="line">        *buf = reply.readInt32();</span><br><span class="line">        bool nonNull = reply.readInt32();</span><br><span class="line">        if (nonNull) &#123;</span><br><span class="line">            *fence = new Fence();</span><br><span class="line">            reply.read(**fence);</span><br><span class="line">        &#125;</span><br><span class="line">        result = reply.readInt32();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回归到 BnGraphicBufferProducer 实现，这里会调用 BufferQueue::dequeueBuffer() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">status_t BnGraphicBufferProducer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case DEQUEUE_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);</span><br><span class="line">            bool async      = data.readInt32();</span><br><span class="line">            uint32_t w      = data.readInt32();</span><br><span class="line">            uint32_t h      = data.readInt32();</span><br><span class="line">            uint32_t format = data.readInt32();</span><br><span class="line">            uint32_t usage  = data.readInt32();</span><br><span class="line">            int buf;</span><br><span class="line">            sp&lt;Fence&gt; fence;</span><br><span class="line">            int result = dequeueBuffer(&amp;buf, &amp;fence, async, w, h, format, usage);</span><br><span class="line">            reply-&gt;writeInt32(buf);</span><br><span class="line">            reply-&gt;writeInt32(fence != NULL);</span><br><span class="line">            if (fence != NULL) &#123;</span><br><span class="line">                reply-&gt;write(*fence);</span><br><span class="line">            &#125;</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查找 mSlots 数组中 BufferSlot::FREE 状态的缓存区，如果没有找到继续等待消费者；设置找到的缓存区状态为 BufferSlot::DEQUEUED，并检查这个缓冲区的 mGraphicBuffer 内存是否满足使用条件，如果不满足则设置 BUFFER_NEEDS_REALLOCATION 标志，调用 <code>mGraphicBufferAlloc-&gt;createGraphicBuffer()</code> 重新申请内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">status_t BufferQueue::dequeueBuffer(int *outBuf, sp&lt;Fence&gt;* outFence, bool async,</span><br><span class="line">        uint32_t w, uint32_t h, uint32_t format, uint32_t usage) &#123;</span><br><span class="line"></span><br><span class="line">    bool tryAgain = true;</span><br><span class="line">    while (tryAgain) &#123;</span><br><span class="line">        // look for a free buffer to give to the client</span><br><span class="line">        found = INVALID_BUFFER_SLOT;</span><br><span class="line">        int dequeuedCount = 0;</span><br><span class="line">        int acquiredCount = 0;</span><br><span class="line">        for (int i = 0; i &lt; maxBufferCount; i++) &#123;</span><br><span class="line">            const int state = mSlots[i].mBufferState;</span><br><span class="line">            switch (state) &#123;</span><br><span class="line">                case BufferSlot::DEQUEUED:</span><br><span class="line">                    dequeuedCount++;    //统计dequeued buffer数量</span><br><span class="line">                    break;</span><br><span class="line">                case BufferSlot::ACQUIRED:</span><br><span class="line">                    acquiredCount++;</span><br><span class="line">                    break;</span><br><span class="line">                case BufferSlot::FREE:</span><br><span class="line">                    /* We return the oldest of the free buffers to avoid</span><br><span class="line">                    * stalling the producer if possible.  This is because</span><br><span class="line">                    * the consumer may still have pending reads of the</span><br><span class="line">                    * buffers in flight.</span><br><span class="line">                    */</span><br><span class="line">                    if ((found &lt; 0) ||</span><br><span class="line">                            mSlots[i].mFrameNumber &lt; mSlots[found].mFrameNumber) &#123;</span><br><span class="line">                        found = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        // See whether a buffer has been queued since the last</span><br><span class="line">        // setBufferCount so we know whether to perform the min undequeued</span><br><span class="line">        // buffers check below.</span><br><span class="line">        if (mBufferHasBeenQueued) &#123;</span><br><span class="line">            // make sure the client is not trying to dequeue more buffers</span><br><span class="line">            // than allowed.</span><br><span class="line">            const int newUndequeuedCount = maxBufferCount - (dequeuedCount+1);</span><br><span class="line">            const int minUndequeuedCount = getMinUndequeuedBufferCount(async);</span><br><span class="line">            if (newUndequeuedCount &lt; minUndequeuedCount) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: min undequeued buffer count (%d) &quot;</span><br><span class="line">                        &quot;exceeded (dequeued=%d undequeudCount=%d)&quot;,</span><br><span class="line">                        minUndequeuedCount, dequeuedCount,</span><br><span class="line">                        newUndequeuedCount);</span><br><span class="line">                return -EBUSY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If no buffer is found, wait for a buffer to be released or for</span><br><span class="line">        // the max buffer count to change.</span><br><span class="line">        tryAgain = found == INVALID_BUFFER_SLOT;</span><br><span class="line">        if (tryAgain) &#123;</span><br><span class="line">            // return an error if we&apos;re in &quot;cannot block&quot; mode (producer and consumer</span><br><span class="line">            // are controlled by the application) -- however, the consumer is allowed</span><br><span class="line">            // to acquire briefly an extra buffer (which could cause us to have to wait here)</span><br><span class="line">            // and that&apos;s okay because we know the wait will be brief (it happens</span><br><span class="line">            // if we dequeue a buffer while the consumer has acquired one but not released</span><br><span class="line">            // the old one yet -- for e.g.: see GLConsumer::updateTexImage()).</span><br><span class="line">            if (mDequeueBufferCannotBlock &amp;&amp; (acquiredCount &lt;= mMaxAcquiredBufferCount)) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: would block! returning an error instead.&quot;);</span><br><span class="line">                return WOULD_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            mDequeueCondition.wait(mMutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const int buf = found;</span><br><span class="line">    *outBuf = found;</span><br><span class="line">    mSlots[buf].mBufferState = BufferSlot::DEQUEUED;</span><br><span class="line"></span><br><span class="line">    //对找到的Slot进行初始化操作</span><br><span class="line">    const sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[buf].mGraphicBuffer);</span><br><span class="line">    if ((buffer == NULL) ||</span><br><span class="line">        (uint32_t(buffer-&gt;width)  != w) ||</span><br><span class="line">        (uint32_t(buffer-&gt;height) != h) ||</span><br><span class="line">        (uint32_t(buffer-&gt;format) != format) ||</span><br><span class="line">        ((uint32_t(buffer-&gt;usage) &amp; usage) != usage))</span><br><span class="line">    &#123;</span><br><span class="line">        mSlots[buf].mAcquireCalled = false;</span><br><span class="line">        mSlots[buf].mGraphicBuffer = NULL;</span><br><span class="line">        mSlots[buf].mRequestBufferCalled = false;</span><br><span class="line">        mSlots[buf].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">        mSlots[buf].mFence = Fence::NO_FENCE;</span><br><span class="line">        mSlots[buf].mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line"></span><br><span class="line">        returnFlags |= IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (returnFlags &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">        status_t error;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer(</span><br><span class="line">                mGraphicBufferAlloc-&gt;createGraphicBuffer(w, h, format, usage, &amp;error));</span><br><span class="line">        if (graphicBuffer == 0) &#123;</span><br><span class="line">            ST_LOGE(&quot;dequeueBuffer: SurfaceComposer::createGraphicBuffer failed&quot;);</span><br><span class="line">            return error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123; // Scope for the lock</span><br><span class="line">            Mutex::Autolock lock(mMutex);</span><br><span class="line"></span><br><span class="line">            if (mAbandoned) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: BufferQueue has been abandoned!&quot;);</span><br><span class="line">                return NO_INIT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSlots[*outBuf].mFrameNumber = ~0;</span><br><span class="line">            mSlots[*outBuf].mGraphicBuffer = graphicBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BpGraphicBufferAlloc::createGraphicBuffer()</code> 通过 Binder 机制调用 <code>BnGraphicBufferAlloc::onTransact()</code> ，进而调用 <code>GraphicBufferAlloc::createGraphicBuffer()</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/IGraphicBufferAlloc.cpp</span><br><span class="line"></span><br><span class="line">class BpGraphicBufferAlloc : public BpInterface&lt;IGraphicBufferAlloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BpGraphicBufferAlloc(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IGraphicBufferAlloc&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;GraphicBuffer&gt; createGraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">            PixelFormat format, uint32_t usage, status_t* error) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferAlloc::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(w);</span><br><span class="line">        data.writeInt32(h);</span><br><span class="line">        data.writeInt32(format);</span><br><span class="line">        data.writeInt32(usage);</span><br><span class="line">        remote()-&gt;transact(CREATE_GRAPHIC_BUFFER, data, &amp;reply);</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer;</span><br><span class="line">        status_t result = reply.readInt32();</span><br><span class="line">        if (result == NO_ERROR) &#123;</span><br><span class="line">            graphicBuffer = new GraphicBuffer();</span><br><span class="line">            result = reply.read(*graphicBuffer);</span><br><span class="line">            // reply.readStrongBinder();</span><br><span class="line">            // here we don&apos;t even have to read the BufferReference from</span><br><span class="line">            // the parcel, it&apos;ll die with the parcel.</span><br><span class="line">        &#125;</span><br><span class="line">        *error = result;</span><br><span class="line">        return graphicBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">status_t BnGraphicBufferAlloc::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // codes that don&apos;t require permission check</span><br><span class="line"></span><br><span class="line">    /* BufferReference just keeps a strong reference to a</span><br><span class="line">     * GraphicBuffer until it is destroyed (that is, until</span><br><span class="line">     * no local or remote process have a reference to it).</span><br><span class="line">     */</span><br><span class="line">    class BufferReference : public BBinder &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">    public:</span><br><span class="line">        BufferReference(const sp&lt;GraphicBuffer&gt;&amp; buffer) : buffer(buffer) &#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_GRAPHIC_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);</span><br><span class="line">            uint32_t w = data.readInt32();</span><br><span class="line">            uint32_t h = data.readInt32();</span><br><span class="line">            PixelFormat format = data.readInt32();</span><br><span class="line">            uint32_t usage = data.readInt32();</span><br><span class="line">            status_t error;</span><br><span class="line">            sp&lt;GraphicBuffer&gt; result =</span><br><span class="line">                    createGraphicBuffer(w, h, format, usage, &amp;error);</span><br><span class="line">            reply-&gt;writeInt32(error);</span><br><span class="line">            if (result != 0) &#123;</span><br><span class="line">                reply-&gt;write(*result);</span><br><span class="line">                // We add a BufferReference to this parcel to make sure the</span><br><span class="line">                // buffer stays alive until the GraphicBuffer object on</span><br><span class="line">                // the other side has been created.</span><br><span class="line">                // This is needed so that the buffer handle can be</span><br><span class="line">                // registered before the buffer is destroyed on implementations</span><br><span class="line">                // that do not use file-descriptors to track their buffers.</span><br><span class="line">                reply-&gt;writeStrongBinder( new BufferReference(result) );</span><br><span class="line">            &#125;</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">        default:</span><br><span class="line">            return BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据传递的宽度、高度、格式等信息来构造 GraphicBuffer 对象，GraphicBuffer 类的构造函数会调用 initSize() 分配图形缓冲区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/GraphicBufferAlloc.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">        PixelFormat format, uint32_t usage, status_t* error) &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; graphicBuffer(new GraphicBuffer(w, h, format, usage));</span><br><span class="line">    status_t err = graphicBuffer-&gt;initCheck();</span><br><span class="line">    *error = err;</span><br><span class="line">    if (err != 0 || graphicBuffer-&gt;handle == 0) &#123;</span><br><span class="line">        if (err == NO_MEMORY) &#123;</span><br><span class="line">            GraphicBuffer::dumpAllocationsToSystemLog();</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGE(&quot;GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) &quot;</span><br><span class="line">            &quot;failed (%s), handle=%p&quot;,</span><br><span class="line">                w, h, strerror(-err), graphicBuffer-&gt;handle);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return graphicBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">        PixelFormat reqFormat, uint32_t reqUsage)</span><br><span class="line">    : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">    mInitCheck(NO_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">    width  =</span><br><span class="line">    height =</span><br><span class="line">    stride =</span><br><span class="line">    format =</span><br><span class="line">    usage  = 0;</span><br><span class="line">    handle = NULL;</span><br><span class="line">    mInitCheck = initSize(w, h, reqFormat, reqUsage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,</span><br><span class="line">        uint32_t reqUsage)</span><br><span class="line">&#123;</span><br><span class="line">    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();</span><br><span class="line">    status_t err = allocator.alloc(w, h, format, reqUsage, &amp;handle, &amp;stride);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        this-&gt;width  = w;</span><br><span class="line">        this-&gt;height = h;</span><br><span class="line">        this-&gt;format = format;</span><br><span class="line">        this-&gt;usage  = reqUsage;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GraphicBufferAllocator 是作为分配图形缓冲区的工具类，这里使用单例模式获取 GraphicBufferAllocator 对象，加载 Gralloc HAL ，最终调用 gralloc_alloc 实现图形缓冲区的分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/include/ui/GraphicBufferAllocator.h</span><br><span class="line"></span><br><span class="line">class GraphicBufferAllocator : public Singleton&lt;GraphicBufferAllocator&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static inline GraphicBufferAllocator&amp; get() &#123; return getInstance(); &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBufferAllocator.cpp</span><br><span class="line"></span><br><span class="line">GraphicBufferAllocator::GraphicBufferAllocator()</span><br><span class="line">    : mAllocDev(0)</span><br><span class="line">&#123;</span><br><span class="line">    hw_module_t const* module;</span><br><span class="line">    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module);</span><br><span class="line">    ALOGE_IF(err, &quot;FATAL: can&apos;t find the %s module&quot;, GRALLOC_HARDWARE_MODULE_ID);</span><br><span class="line">    if (err == 0) &#123;</span><br><span class="line">        gralloc_open(module, &amp;mAllocDev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在为止 BufferQueue 中已经申请到了内存，返回给 Surface 一个的数组下标，但这时候 Surface 还没有获取到任何图形缓冲区相关的东西。由于申请的内存是在 SurfaceFlinger 所在的进程，接下来调用 <code>mGraphicBufferProducer-&gt;requestBuffer()</code> 将 buffer 映射到 Surface 所在的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">status_t BufferQueue::requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ST_LOGV(&quot;requestBuffer: slot=%d&quot;, slot);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    if (mAbandoned) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: BufferQueue has been abandoned!&quot;);</span><br><span class="line">        return NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (slot &lt; 0 || slot &gt;= NUM_BUFFER_SLOTS) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: slot index out of range [0, %d]: %d&quot;,</span><br><span class="line">                NUM_BUFFER_SLOTS, slot);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125; else if (mSlots[slot].mBufferState != BufferSlot::DEQUEUED) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: slot %d is not owned by the client (state=%d)&quot;,</span><br><span class="line">                slot, mSlots[slot].mBufferState);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    mSlots[slot].mRequestBufferCalled = true;</span><br><span class="line">    *buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 requestBuffer() 方法返回后，调用 <code>reply-&gt;write(*buffer)</code> ，这里经过数据打包处理然后发送到应用程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/binder/Parcel.cpp</span><br><span class="line"></span><br><span class="line">status_t Parcel::write(const FlattenableHelperInterface&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    // size if needed</span><br><span class="line">    const size_t len = val.getFlattenedSize();</span><br><span class="line">    const size_t fd_count = val.getFdCount();</span><br><span class="line"></span><br><span class="line">    err = this-&gt;writeInt32(len);</span><br><span class="line">    if (err) return err;</span><br><span class="line"></span><br><span class="line">    err = this-&gt;writeInt32(fd_count);</span><br><span class="line">    if (err) return err;</span><br><span class="line"></span><br><span class="line">    // payload</span><br><span class="line">    void* const buf = this-&gt;writeInplace(PAD_SIZE(len));</span><br><span class="line">    if (buf == NULL)</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line"></span><br><span class="line">    int* fds = NULL;</span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        fds = new int[fd_count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数据的打包处理</span><br><span class="line">    err = val.flatten(buf, len, fds, fd_count);</span><br><span class="line">    for (size_t i=0 ; i&lt;fd_count &amp;&amp; err==NO_ERROR ; i++) &#123;</span><br><span class="line">        err = this-&gt;writeDupFileDescriptor( fds[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        delete [] fds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::flatten(void*&amp; buffer, size_t&amp; size, int*&amp; fds, size_t&amp; count) const &#123;</span><br><span class="line">    size_t sizeNeeded = GraphicBuffer::getFlattenedSize();</span><br><span class="line">    if (size &lt; sizeNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    size_t fdCountNeeded = GraphicBuffer::getFdCount();</span><br><span class="line">    if (count &lt; fdCountNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    int* buf = static_cast&lt;int*&gt;(buffer);</span><br><span class="line">    buf[0] = &apos;GBFR&apos;;</span><br><span class="line">    buf[1] = width;</span><br><span class="line">    buf[2] = height;</span><br><span class="line">    buf[3] = stride;</span><br><span class="line">    buf[4] = format;</span><br><span class="line">    buf[5] = usage;</span><br><span class="line">    buf[6] = 0;</span><br><span class="line">    buf[7] = 0;</span><br><span class="line"></span><br><span class="line">    if (handle) &#123;</span><br><span class="line">        buf[6] = handle-&gt;numFds;</span><br><span class="line">        buf[7] = handle-&gt;numInts;</span><br><span class="line">        native_handle_t const* const h = handle;</span><br><span class="line">        memcpy(fds,     h-&gt;data,             h-&gt;numFds*sizeof(int));</span><br><span class="line">        memcpy(&amp;buf[8], h-&gt;data + h-&gt;numFds, h-&gt;numInts*sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = reinterpret_cast&lt;void*&gt;(static_cast&lt;int*&gt;(buffer) + sizeNeeded);</span><br><span class="line">    size -= sizeNeeded;</span><br><span class="line">    fds += handle-&gt;numFds;</span><br><span class="line">    count -= handle-&gt;numFds;</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用程序端使用 <code>reply.read(*graphicBuffer)</code> 把数据读取出来，这里使用 Parcel::read() 方法，进而调用 GraphicBufer::unflatten() 方法，这里使用 fd 构造 native_handle 对象，然后调用 <code>GraphicBufferMapper::registerBuffer()</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/binder/Parcel.cpp</span><br><span class="line"></span><br><span class="line">status_t Parcel::read(FlattenableHelperInterface&amp; val) const</span><br><span class="line">&#123;</span><br><span class="line">    // size</span><br><span class="line">    const size_t len = this-&gt;readInt32();</span><br><span class="line">    const size_t fd_count = this-&gt;readInt32();</span><br><span class="line"></span><br><span class="line">    // payload</span><br><span class="line">    void const* const buf = this-&gt;readInplace(PAD_SIZE(len));</span><br><span class="line">    if (buf == NULL)</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line"></span><br><span class="line">    int* fds = NULL;</span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        fds = new int[fd_count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = NO_ERROR;</span><br><span class="line">    for (size_t i=0 ; i&lt;fd_count &amp;&amp; err==NO_ERROR ; i++) &#123;</span><br><span class="line">        fds[i] = dup(this-&gt;readFileDescriptor());</span><br><span class="line">        if (fds[i] &lt; 0) err = BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        err = val.unflatten(buf, len, fds, fd_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        delete [] fds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::unflatten(</span><br><span class="line">        void const*&amp; buffer, size_t&amp; size, int const*&amp; fds, size_t&amp; count) &#123;</span><br><span class="line">    if (size &lt; 8*sizeof(int)) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    int const* buf = static_cast&lt;int const*&gt;(buffer);</span><br><span class="line">    if (buf[0] != &apos;GBFR&apos;) return BAD_TYPE;</span><br><span class="line"></span><br><span class="line">    const size_t numFds  = buf[6];</span><br><span class="line">    const size_t numInts = buf[7];</span><br><span class="line"></span><br><span class="line">    const size_t sizeNeeded = (8 + numInts) * sizeof(int);</span><br><span class="line">    if (size &lt; sizeNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    size_t fdCountNeeded = 0;</span><br><span class="line">    if (count &lt; fdCountNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    if (handle) &#123;</span><br><span class="line">        // free previous handle if any</span><br><span class="line">        free_handle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (numFds || numInts) &#123;</span><br><span class="line">        width  = buf[1];</span><br><span class="line">        height = buf[2];</span><br><span class="line">        stride = buf[3];</span><br><span class="line">        format = buf[4];</span><br><span class="line">        usage  = buf[5];</span><br><span class="line">        native_handle* h = native_handle_create(numFds, numInts);</span><br><span class="line">        memcpy(h-&gt;data,          fds,     numFds*sizeof(int));</span><br><span class="line">        memcpy(h-&gt;data + numFds, &amp;buf[8], numInts*sizeof(int));</span><br><span class="line">        handle = h;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        width = height = stride = format = usage = 0;</span><br><span class="line">        handle = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOwner = ownHandle;</span><br><span class="line"></span><br><span class="line">    if (handle != 0) &#123;</span><br><span class="line">        status_t err = mBufferMapper.registerBuffer(handle);</span><br><span class="line">        if (err != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;unflatten: registerBuffer failed: %s (%d)&quot;,</span><br><span class="line">                    strerror(-err), err);</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际会调用 Gralloc 模块的 registerBuffer() 方法，这里会把申请的 buffer 进行 mmap 映射，然后将 vaddr 数据保存在 handle-&gt;base 中。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/ui/GraphicBufferMapper.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBufferMapper::registerBuffer(buffer_handle_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    err = mAllocMod-&gt;registerBuffer(mAllocMod, handle);</span><br><span class="line"></span><br><span class="line">    ALOGW_IF(err, &quot;registerBuffer(%p) failed %d (%s)&quot;,</span><br><span class="line">            handle, err, strerror(-err));</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dequeueBuffer() 完成之后会调用 backBuffer-&gt;lock()，实际上调用的是 gralloc_lock()，直接返回 handle-&gt;base()。</p><p>总结：真正的申请图形缓冲区是在 SurfaceFlinger 进程中，因为 GraphicBufferAlloc 对象是在 SurfaceFlinger 中构造出来的，然后 BufferQueue 和 Surface 中的图形缓冲区都是通过 GraphicBuffer 的序列化和反序列化新映射出来的。</p><h2 id="Surface-unlockAsndPost"><a href="#Surface-unlockAsndPost" class="headerlink" title="Surface::unlockAsndPost()"></a>Surface::unlockAsndPost()</h2><p>应用绘制完成后，将数据更新入 BufferQueue ，通知 Layer 更新，Layer 从 BufferQueue 中取出数据，通知SurfaceFlinger 进行合成处理。</p><p><code>Surface::unlockAndPost()</code> 调用 <code>Surface::queueBuffer()</code> 方法，而 <code>mGraphicBufferProducer-&gt;queueBuffer()</code> 方法实际上会调用的是本地对象的 BnGraphicBufferProducer::queueBuffer() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/Surface.cpp</span><br><span class="line"></span><br><span class="line">status_t Surface::unlockAndPost()</span><br><span class="line">&#123;</span><br><span class="line">    if (mLockedBuffer == 0) &#123;</span><br><span class="line">        ALOGE(&quot;Surface::unlockAndPost failed, no locked buffer&quot;);</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = mLockedBuffer-&gt;unlock();</span><br><span class="line">    ALOGE_IF(err, &quot;failed unlocking buffer (%p)&quot;, mLockedBuffer-&gt;handle);</span><br><span class="line"></span><br><span class="line">    err = queueBuffer(mLockedBuffer.get(), -1);</span><br><span class="line">    ALOGE_IF(err, &quot;queueBuffer (handle=%p) failed (%s)&quot;,</span><br><span class="line">            mLockedBuffer-&gt;handle, strerror(-err));</span><br><span class="line"></span><br><span class="line">    mPostedBuffer = mLockedBuffer;</span><br><span class="line">    mLockedBuffer = 0;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;Surface::queueBuffer&quot;);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    int64_t timestamp;</span><br><span class="line">    bool isAutoTimestamp = false;</span><br><span class="line">    if (mTimestamp == NATIVE_WINDOW_TIMESTAMP_AUTO) &#123;</span><br><span class="line">        timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        isAutoTimestamp = true;</span><br><span class="line">        ALOGV(&quot;Surface::queueBuffer making up timestamp: %.2f ms&quot;,</span><br><span class="line">            timestamp / 1000000.f);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        timestamp = mTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = getSlotFromBufferLocked(buffer);</span><br><span class="line">    if (i &lt; 0) &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure the crop rectangle is entirely inside the buffer.</span><br><span class="line">    Rect crop;</span><br><span class="line">    mCrop.intersect(Rect(buffer-&gt;width, buffer-&gt;height), &amp;crop);</span><br><span class="line"></span><br><span class="line">    sp&lt;Fence&gt; fence(fenceFd &gt;= 0 ? new Fence(fenceFd) : Fence::NO_FENCE);</span><br><span class="line">    IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">    IGraphicBufferProducer::QueueBufferInput input(timestamp, isAutoTimestamp,</span><br><span class="line">            crop, mScalingMode, mTransform, mSwapIntervalZero, fence);</span><br><span class="line">    status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">    if (err != OK)  &#123;</span><br><span class="line">        ALOGE(&quot;queueBuffer: error queuing buffer to SurfaceTexture, %d&quot;, err);</span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t numPendingBuffers = 0;</span><br><span class="line">    output.deflate(&amp;mDefaultWidth, &amp;mDefaultHeight, &amp;mTransformHint,</span><br><span class="line">            &amp;numPendingBuffers);</span><br><span class="line"></span><br><span class="line">    mConsumerRunningBehind = (numPendingBuffers &gt;= 2);</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mGraphicBufferProducer-&gt;queueBuffer()</code> 会调用  <code>remote()-&gt;transact()</code>，进而调用 <code>BufferQueue::queueBuffer()</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/libs/gui/IGraphicBufferProducer.cpp</span><br><span class="line"></span><br><span class="line">class BpGraphicBufferProducer : public BpInterface&lt;IGraphicBufferProducer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t queueBuffer(int buf,</span><br><span class="line">            const QueueBufferInput&amp; input, QueueBufferOutput* output) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(buf);</span><br><span class="line">        data.write(input);</span><br><span class="line">        status_t result = remote()-&gt;transact(QUEUE_BUFFER, data, &amp;reply);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;BpGraphicBufferProducer::queueBuffer binder transact failed, result: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        memcpy(output, reply.readInplace(sizeof(*output)), sizeof(*output));</span><br><span class="line">        result = reply.readInt32();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BnGraphicBufferProducer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case QUEUE_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);</span><br><span class="line">            int buf = data.readInt32(); //读取Slot序号</span><br><span class="line">            QueueBufferInput input(data);</span><br><span class="line">            QueueBufferOutput* const output =</span><br><span class="line">                    reinterpret_cast&lt;QueueBufferOutput *&gt;(</span><br><span class="line">                            reply-&gt;writeInplace(sizeof(QueueBufferOutput)));</span><br><span class="line">            status_t result = queueBuffer(buf, input, output);</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queueBuffer 调用 <code>listener-&gt;onFrameAvailable()</code> ，父类的构造函数 ConsumerBase 会调用 Layer 的 onFrameAvailable() ，最后调用 signalLayerUpdate() 通知 SurfaceFlinger 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">status_t BufferQueue::queueBuffer(int buf,</span><br><span class="line">        const QueueBufferInput&amp; input, QueueBufferOutput* output) &#123;</span><br><span class="line"></span><br><span class="line">    sp&lt;IConsumerListener&gt; listener;</span><br><span class="line"></span><br><span class="line">    const sp&lt;GraphicBuffer&gt;&amp; graphicBuffer(mSlots[buf].mGraphicBuffer);</span><br><span class="line"></span><br><span class="line">    mSlots[buf].mFence = fence;</span><br><span class="line">    mSlots[buf].mBufferState = BufferSlot::QUEUED;</span><br><span class="line">    mFrameCounter++;</span><br><span class="line">    mSlots[buf].mFrameNumber = mFrameCounter;</span><br><span class="line"></span><br><span class="line">    BufferItem item;</span><br><span class="line">    item.mAcquireCalled = mSlots[buf].mAcquireCalled;</span><br><span class="line">    item.mGraphicBuffer = mSlots[buf].mGraphicBuffer;</span><br><span class="line">    item.mCrop = crop;</span><br><span class="line">    item.mTransform = transform &amp; ~NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY;</span><br><span class="line">    item.mTransformToDisplayInverse = bool(transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);</span><br><span class="line">    item.mScalingMode = scalingMode;</span><br><span class="line">    item.mTimestamp = timestamp;</span><br><span class="line">    item.mIsAutoTimestamp = isAutoTimestamp;</span><br><span class="line">    item.mFrameNumber = mFrameCounter;</span><br><span class="line">    item.mBuf = buf;</span><br><span class="line">    item.mFence = fence;</span><br><span class="line">    item.mIsDroppable = mDequeueBufferCannotBlock || async;</span><br><span class="line"></span><br><span class="line">    mQueue.push_back(item);</span><br><span class="line">    listener = mConsumerListener;</span><br><span class="line"></span><br><span class="line">    mDequeueCondition.broadcast();</span><br><span class="line">    output-&gt;inflate(mDefaultWidth, mDefaultHeight, mTransformHint,</span><br><span class="line">        mQueue.size());</span><br><span class="line"></span><br><span class="line">    listener-&gt;onFrameAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 listener 保存了前面已经分配的 Layer 对象，而 Layer 的成员变量 mFlinger 保存了 SurfaceFlinger 对象，所以调用 signalLayerUpdate() 方法会唤醒其他线程，这部分后面再继续分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">void BufferQueue::ProxyConsumerListener::onFrameAvailable() &#123;</span><br><span class="line">    sp&lt;ConsumerListener&gt; listener(mConsumerListener.promote());</span><br><span class="line">    if (listener != NULL) &#123;</span><br><span class="line">        listener-&gt;onFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/Layer.cpp</span><br><span class="line"></span><br><span class="line">void Layer::onFrameAvailable() &#123;</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">    mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在谈及 Android GUI 框架前，先从底层视角梳理一下显示的流程。在 Android 系统中，引入了状态栏、导航栏、壁纸和背景的图层概念，需要把这些图层进行 alpha blending 后显示。&lt;/p&gt;
&lt;p&gt;在嵌入式 linux 系统下显示界面，可以直接操作 fr
      
    
    </summary>
    
    
      <category term="Android" scheme="http://tinylaker.github.io/categories/Android/"/>
    
    
      <category term="GUI" scheme="http://tinylaker.github.io/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>sc7731 lcd流程分析</title>
    <link href="http://tinylaker.github.io/2019/11/09/sc7731-lcd%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/</id>
    <published>2019-11-09T11:34:45.000Z</published>
    <updated>2019-12-04T09:16:53.919Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。</p><p>本文基于Android 4.4代码分析sc7731 lcd的基本流程。</p><h1 id="显示系统"><a href="#显示系统" class="headerlink" title="显示系统"></a>显示系统</h1><p>这里暂时以7710芯片手册为例，多媒体显示系统包含 LCDC 和 DISPC，其中 LCDC 仅支持 MCU 接口类型，支持 2 路显示；而 DISPC 同时支持 DBI 和 DPI 接口类型。</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png" alt="lcd"></p><ul><li>LCDC</li></ul><p>支持最多6个图层的Alaha Blending，RGB888数据格式到RGB565/RGB666数据格式的Dithering等功能。</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcdc_module.png" alt="lcdc"></p><ul><li>LCM</li></ul><p>LCM接收AHB总线或者LCDC数据，并按照MCU接口格式按照固定的时序传输到显示模组上。<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcm_module.png" alt="lcm"></p><p>MCU支持8080和6080两种传输格式，两者的区别只是在读写控制上。</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/8080.png" alt="8080"></p><ul><li>DISPC</li></ul><p>这里可以看出2种路线，一种直接由LCDC DBI经由DISPC DBI输出；另一种直接由AXI Domain到DISPC DBI/DPI输出。所以如果使用MIPI接口显示模组，是不需要经过LCDC显示模块的，直接由DISPC模块控制。      </p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/DISPC.png" alt="DISPC"></p><h1 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h1><p>lcd相关源码位于 <code>drivers/video/sprdfb</code>，代码文件截图如下:</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sc7731_uboot_lcd.png" alt="uboot source code"></p><p>可以看到代码兼容了多款 Soc，Makefile 中也包含了多个平台的配置。</p><p>头文件 <code>include/configs/sp7731gea.h</code>，里面定义了 <code>CONFIG_SC8830</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SC8830</span><br><span class="line">#define CONFIG_DSIH_VERSION_1P21A</span><br><span class="line">#define CONFIG_FB_LCD_NT35516_MIPI</span><br></pre></td></tr></table></figure><p>这里值得一提的是7731和8830的AP相同，只是Modem存在差异，前者支持WCMDA，后者支持TD_SCMDA。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_SC8830)+= sprdfb_main.o sprdfb_panel.o sprdfb_dispc.o \</span><br><span class="line">    sprdfb_mcu.o sprdfb_rgb.o sprdfb_mipi.o \</span><br><span class="line">     sprdfb_i2c.o sprdfb_spi.o sprdfb_dsi.o \</span><br><span class="line">     sprdfb_chip_common.o sprdfb_chip_8830.o</span><br></pre></td></tr></table></figure><p>能够看出该平台的显示系统支持多种lcd接口，包括mcu、rgb、mipi、i2c、spi。</p><p>这里的mipi dsi有2个不同版本的IP核，参考头文件中的定义，这里使用的是dsi_1_21a中的代码。</p><p>下面以 <code>lcd_nt35516_mipi.c</code> 为例，分析 uboot lcd 的整个流程。</p><h2 id="lcd-模组配置"><a href="#lcd-模组配置" class="headerlink" title="lcd 模组配置"></a>lcd 模组配置</h2><ol><li><p><code>drivers/video/sprdfb/lcd/Makefile</code> 包含编译该屏驱动的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_FB_LCD_NT35516_MIPI) += lcd_nt35516_mipi.o</span><br></pre></td></tr></table></figure></li><li><p><code>drivers/video/sprdfb/sprdfb_panel.c</code> 中包含该屏的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern struct panel_spec lcd_nt35516_mipi_spec;</span><br><span class="line">static struct panel_cfg panel_cfg[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">#ifdef CONFIG_FB_LCD_NT35516_MIPI </span><br><span class="line">    &#123; </span><br><span class="line">        .lcd_id = 0x16, </span><br><span class="line">        .panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">    &#125;,</span><br><span class="line"> #endif</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code> 中详细描述了该模组的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">        //.cap = PANEL_CAP_NOT_TEAR_SYNC,</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">        .display_width = 480,</span><br><span class="line">        .display_height= 854,</span><br><span class="line">#endif</span><br><span class="line">        .width = 540,</span><br><span class="line">        .height = 960,</span><br><span class="line">        .fps = 60,</span><br><span class="line">        .type = LCD_MODE_DSI,</span><br><span class="line">        .direction = LCD_DIRECT_NORMAL,</span><br><span class="line">        .info = &#123;</span><br><span class="line">                .mipi = &amp;lcd_nt35516_mipi_info    //(1) mipi lcd模组的常规配置</span><br><span class="line">        &#125;,</span><br><span class="line">        .ops = &amp;lcd_nt35516_mipi_operations,    //(2) mipi lcd的操作集合</span><br><span class="line">&#125;;</span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">        .work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">        .video_bus_width = 24, /*18,16*/</span><br><span class="line">        .lan_number = 3,</span><br><span class="line">        .phy_feq = 500*1000,</span><br><span class="line">        .h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .timing = &amp;lcd_nt35516_mipi_timing,    //(3) mipi lcd的时序proch配置</span><br><span class="line">        .ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">        .panel_init = nt35516_mipi_init,    //包含mipi屏大量初始化代码</span><br><span class="line">        .panel_readid = nt35516_readid,    //mipi屏的读取id操作</span><br><span class="line">&#125;;</span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">        .hfp = 20,  /* unit: pixel */</span><br><span class="line">        .hbp = 20,</span><br><span class="line">        .hsync = 20,//4,</span><br><span class="line">        .vfp = 10, /*unit: line*/</span><br><span class="line">        .vbp = 10,</span><br><span class="line">        .vsync = 6,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="lcd-模组初始化流程"><a href="#lcd-模组初始化流程" class="headerlink" title="lcd 模组初始化流程"></a>lcd 模组初始化流程</h2><p>系统上电执行芯片 <strong>RomCode</strong>，完成 DDR 和外部存储器等常用外设的初始化；</p><p>之后读取外部存储器中的 uboot 并跳转执行，优先完成板级初始化 <code>board_init_f</code> 和 <code>board_init_r</code>，其中 <code>board_init_r</code> 中调用了<code>stdio_init</code>。代码流程图如下：</p><p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprdfb_uboot_lcd_init.png" alt="sprdfb_lcd_init"></p><p>我们把重点聚焦在 sprdfb_probe 的实现上，下面剔除了部分无关代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c  </span><br><span class="line"></span><br><span class="line">static int sprdfb_probe(void * lcdbase)</span><br><span class="line">&#123;</span><br><span class="line">        struct sprdfb_device *dev = &amp;s_sprdfb_dev;</span><br><span class="line">        set_backlight(0);    //(1)</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(2) </span><br><span class="line">        dev-&gt;ctrl-&gt;early_init(dev);    //(3)</span><br><span class="line">        if (0 != sprdfb_panel_probe(dev)) &#123;    //(4)</span><br><span class="line">                sprdfb_panel_remove(dev);</span><br><span class="line">                dev-&gt;ctrl-&gt;uninit(dev);</span><br><span class="line">                printf(&quot;sprdfb: failed to probe\n&quot;);</span><br><span class="line">                return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        dev-&gt;smem_start = ((uint32_t)lcdbase);</span><br><span class="line">        dev-&gt;ctrl-&gt;init(dev);    //(5)</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(1) 关闭pwm控制</li><li>(2) 获取display controller的接口，定义在 <code>sprdfb_dispc.c</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_dispc.c</span><br><span class="line"></span><br><span class="line">struct display_ctrl sprdfb_dispc_ctrl = &#123;</span><br><span class="line">        .name           = &quot;dispc&quot;,</span><br><span class="line">        .early_init             = sprdfb_dispc_early_init,</span><br><span class="line">        .init                   = sprdfb_dispc_init,</span><br><span class="line">        .uninit         = sprdfb_dispc_uninit,</span><br><span class="line">        .refresh                = sprdfb_dispc_refresh,</span><br><span class="line">        .update_clk     = dispc_update_clock,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li>(3) 调用<code>sprdfb_dispc_early_init</code>，配置相关的clk，使能<code>dispc module</code></li><li>(4) <code>sprdfb_panel_probe</code> 会读取和保存 lcd 模组的 id，并对该模组完成初始化。</li><li>(5) <code>sprdfb_dispc_init</code> 会完成显示系统 dithering 和 osd layer 的设置。</li></ul><p>需要特别注意 uboot lcd 初始化流程中会保存 <strong>lcd_base</strong> 和 <strong>lcd_id</strong>，通过命令行参数传递，以供 kernel 阶段继续使用。</p><h2 id="lcd-刷新显示流程"><a href="#lcd-刷新显示流程" class="headerlink" title="lcd 刷新显示流程"></a>lcd 刷新显示流程</h2><p>看到这里读者可能会有疑问，uboot logo 是什么时候显示的呢？</p><p>下面开始分析lcd refresh流程，这里要从 <code>board_init_r</code> 中的<strong>do_cboot</strong>代码分析。</p><ol><li><p>normal_mode<br>代码定义了多种启动方式：normal、recovery、fastboot、charge、watchdog等，这里直接看normal_boot的代码。<br>首先初始化马达硬件，完成开机震动，然后调用 vlx_nand_boot，这里的代码取决有是 nand 方案还是 emmc 方案，这里假设是 emmc 启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ property/normal_mode.c</span><br><span class="line"></span><br><span class="line">void normal_mode(void) &#123;</span><br><span class="line">    vibrator_hw_init();</span><br><span class="line">    set_vibrator(1);</span><br><span class="line">#if BOOT_NATIVE_LINUX</span><br><span class="line">    vlx_nand_boot(BOOT_PART, CONFIG_BOOTARGS, BACKLIGHT_ON);</span><br><span class="line">#else</span><br><span class="line">    vlx_nand_boot(BOOT_PART, NULL, BACKLIGHT_ON);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vlx_nand_boot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ property/normal_emc_mode.c</span><br><span class="line"></span><br><span class="line">void vlx_nand_boot(char * kernel_pname, char * cmdline, int backlight_set) &#123;</span><br><span class="line">    _boot_display_logo(dev, backlight_set);    //(1)</span><br><span class="line">    set_vibrator(FALSE);</span><br><span class="line">    _boot_load_kernel_ramdisk_image(dev, kernel_pname, hdr);</span><br><span class="line">    _boot_secure_check();</span><br><span class="line">    sipc_addr_reset();</span><br><span class="line">    vlx_entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>调用_boot_display_logo，读取logo分区图片内容，并调用lcd_display_logo，重点关注。</p></li><li><p>关闭马达;</p></li><li><p>从存储器读取kernel、ramdisk、dtb image，保存相关内存地址。</p></li><li><p>secure boot校验流程，根据产品定义，可能会对DSP、Modem、SIMLOCK等image进行校验。</p></li><li><p>sipc 内存区域清零，这部分由展讯自己实现，用于AP和Modem之间的通信交换，后面有文章会涉及。</p></li><li><p>跳转到内核启动</p></li></ul><ol start="3"><li><p>_boot_display_logo<br>从logo分区中读取图片信息，存放到缓存中，调用<code>lcd_display_logo</code>刷新显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LOCAL __inline void _boot_display_logo(block_dev_desc_t *dev, int backlight_set)</span><br><span class="line">&#123;</span><br><span class="line">        size_t size;</span><br><span class="line">#if defined(CONFIG_LCD_720P) || defined(CONFIG_LCD_HD) //LiWei add CONFIG_LCD_HD</span><br><span class="line">        size = 1&lt;&lt;20;</span><br><span class="line">#else</span><br><span class="line">        size = 1&lt;&lt;19;</span><br><span class="line">#endif</span><br><span class="line">        uint8 * bmp_img = malloc(size);</span><br><span class="line">        if(!bmp_img)&#123;</span><br><span class="line">            debugf(&quot;%s: malloc for splash image failed!\n&quot;,__FUNCTION__);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!_boot_partition_read(dev, L&quot;logo&quot;, 0, size, bmp_img))</span><br><span class="line">        &#123;</span><br><span class="line">                debugf(&quot;%s: read logo partition failed!\n&quot;,__FUNCTION__);</span><br><span class="line">                goto end;</span><br><span class="line">        &#125;</span><br><span class="line">        lcd_display_logo(backlight_set,(ulong)bmp_img,size);</span><br><span class="line">end:</span><br><span class="line">        free(bmp_img);</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lcd_display_logo<br>因为是bmp格式图片，需要调用 lcd_display_bitmap 进行格式转换后才能在lcd上显示；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void lcd_display_logo(int backlight_set,ulong bmp_img,size_t size)</span><br><span class="line">&#123;</span><br><span class="line">#define mdelay(t)     (&#123;unsigned long msec=(t); while (msec--) &#123; udelay(1000);&#125;&#125;)</span><br><span class="line">    if(backlight_set == BACKLIGHT_ON)&#123;</span><br><span class="line">        lcd_display_bitmap((ulong)bmp_img, 0, 0);</span><br><span class="line">        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);</span><br><span class="line">        lcd_display();</span><br><span class="line">        mdelay(50);</span><br><span class="line">        set_backlight(255);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);</span><br><span class="line">        lcd_display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lcd_display<br>参考前面的内容，refresh函数指针等同于<code>sprdfb_dispc_refresh</code>，定义在 <code>drivers/video/sprdfb_dispc.c</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c</span><br><span class="line">void lcd_display(void)</span><br><span class="line">&#123;</span><br><span class="line">    real_refresh(&amp;s_sprdfb_dev);</span><br><span class="line">&#125;</span><br><span class="line">static int real_refresh(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    dev-&gt;ctrl-&gt;refresh(dev);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sprdfb_dispc_refresh<br>这里针对mipi lcd模组，可以简单理解为cmd mode和video mode不同方式刷新显示，这里不再详细分析操作寄存器的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb_dispc.c</span><br><span class="line">static int32_t sprdfb_dispc_refresh (struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    if(SPRDFB_PANEL_IF_DPI == dev-&gt;panel_if_type) &#123;    //cmd mode</span><br><span class="line">        dispc_set_bits((1&lt;&lt;5), DISPC_DPI_CTRL);</span><br><span class="line">        if(is_first_frame)&#123;</span><br><span class="line">            udelay(30);</span><br><span class="line">            dispc_clear_bits((1&lt;&lt;4), DISPC_DPI_CTRL);</span><br><span class="line">            dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);</span><br><span class="line">            is_first_frame = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;    //video mode</span><br><span class="line">        dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);</span><br><span class="line">        ...</span><br><span class="line">        dispc_set_bits((1&lt;&lt;0), DISPC_INT_CLR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此，uboot lcd的初始化和刷新显示已经分析完成了。</p><h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><p>lcd 相关代码如下图：<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd.png" alt="sprdfb kernel code"></p><p>和 uboot 代码架构基本相似，下面以 <code>lcd_nt35516_mipi.c</code>为例进行分析</p><h2 id="lcd模组配置"><a href="#lcd模组配置" class="headerlink" title="lcd模组配置"></a>lcd模组配置</h2><p>驱动文件放置路径:  <code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code></p><ul><li><p>drivers/video/sprdfb/lcd/Makefile<br>包含编译该屏驱动的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_FB_LCD_NT35516_MIPI)  += lcd_nt35516_mipi.o=</span><br></pre></td></tr></table></figure></li><li><p>drivers/video/sprdfb/Kconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config FB_LCD_NT35516_MIPI</span><br><span class="line">        boolean &quot;support NT35516 mipi panel&quot;</span><br><span class="line">        depends on FB_SC8825 || FB_SCX35 || FB_SCX30G</span><br><span class="line">        default n</span><br></pre></td></tr></table></figure></li><li><p>arch/arm/configs/sp7731gea-dt_defconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FB_LCD_NT35516_MIPI=y</span><br></pre></td></tr></table></figure></li><li><p>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c<br>这个文件配置了该模组的基本信息和操作方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">.panel_init = nt35516_mipi_init,</span><br><span class="line">.panel_readid = nt35516_readid,</span><br><span class="line">.panel_enter_sleep = nt35516_enter_sleep,</span><br><span class="line">.panel_esd_check = nt35516_check_esd,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">.hfp = 20,  /* unit: pixel */</span><br><span class="line">.hbp = 20,</span><br><span class="line">.hsync = 20,//4,</span><br><span class="line">.vfp = 10, /*unit: line*/</span><br><span class="line">.vbp = 10,</span><br><span class="line">.vsync = 6,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">.work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">.video_bus_width = 24, /*18,16*/</span><br><span class="line">.lan_number = 3,</span><br><span class="line">.phy_feq = 500*1000,</span><br><span class="line">.h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">.v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">.de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">.te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">.color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">.shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">.timing = &amp;lcd_nt35516_mipi_timing,</span><br><span class="line">.ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">.display_width = 480,</span><br><span class="line">.display_height = 854,</span><br><span class="line">#endif</span><br><span class="line">.width = 540,</span><br><span class="line">.height = 960,</span><br><span class="line">.fps = 60,</span><br><span class="line">.type = LCD_MODE_DSI,</span><br><span class="line">.direction = LCD_DIRECT_NORMAL,</span><br><span class="line">.is_clean_lcd = true,</span><br><span class="line">.info = &#123;</span><br><span class="line">.mipi = &amp;lcd_nt35516_mipi_info</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;lcd_nt35516_mipi_operations,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct panel_cfg lcd_nt35516_mipi = &#123;</span><br><span class="line">/* this panel can only be main lcd */</span><br><span class="line">.dev_id = SPRDFB_MAINLCD_ID,</span><br><span class="line">.lcd_id = 0x16,</span><br><span class="line">.lcd_name = &quot;lcd_nt35516_mipi&quot;,</span><br><span class="line">.panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init lcd_nt35516_mipi_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return sprdfb_panel_register(&amp;lcd_nt35516_mipi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(lcd_nt35516_mipi_init);</span><br></pre></td></tr></table></figure></li></ul><p><strong>subsys_initcall</strong> 是一个内核中的一个宏，定义特殊的init段，在内核启动过程中会依次调用这些函数，基本和<strong>module_init</strong>类似，但优先级更高。</p><p><strong>sprdfb_panel_register</strong> 定义在 <code>drivers/video/sprdfb/sprdfb_panel.c</code>，会把该模组对应的 panel_cfg 添加到维护的全局链表<code>panel_list_main</code> 中。</p><h2 id="lcd-模组初始化流程-1"><a href="#lcd-模组初始化流程-1" class="headerlink" title="lcd 模组初始化流程"></a>lcd 模组初始化流程</h2><ul><li><p>arch/arm/configs/sp7731gea-native_defconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MACH_SP7731GEA=y</span><br></pre></td></tr></table></figure></li><li><p>arch/arm/boot/dts/Makefile </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch/arm/boot/dts/sprd-scx35_sp7731gea.dts</span><br><span class="line">226:dtb-$(CONFIG_MACH_SP7731GEA) += sprd-scx35_sp7731gea.dtb</span><br><span class="line">227:dtb-$(CONFIG_MACH_SP7731GEA_LM) += sprd-scx35_sp7731gea_lm.dtb</span><br><span class="line">228:dtb-$(CONFIG_MACH_SP7731GEA_FWVGA) += sprd-scx35_sp7731gea_fwvga.dtb</span><br><span class="line">229:dtb-$(CONFIG_MACH_SP7731GEAOPENPHONE) += sprd-scx35_sp7731geaopenphone.dtb</span><br></pre></td></tr></table></figure></li><li><p>sprd-scx35_sp7731gea.dts<br>其中lcd controller配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">serial0 = &amp;uart0;</span><br><span class="line">serial1 = &amp;uart1;</span><br><span class="line">serial2 = &amp;uart2;</span><br><span class="line">serial3 = &amp;uart3;</span><br><span class="line">i2c0 = &amp;i2c0;</span><br><span class="line">i2c1 = &amp;i2c1;</span><br><span class="line">i2c2 = &amp;i2c2;</span><br><span class="line">i2c3 = &amp;i2c3;</span><br><span class="line">lcd0 = &amp;fb0;</span><br><span class="line">spi0 = &amp;spi0;</span><br><span class="line">spi1 = &amp;spi1;</span><br><span class="line">spi2 = &amp;spi2;</span><br><span class="line">hwspinlock0 = &amp;hwspinlock0;</span><br><span class="line">hwspinlock1 = &amp;hwspinlock1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fb0: fb@20800000 &#123;</span><br><span class="line">compatible = &quot;sprd,sprdfb&quot;;</span><br><span class="line">reg = &lt;0xf5122000 0x1000&gt;,&lt;0xf5146000 0x1000&gt;;</span><br><span class="line">interrupts = &lt;0 46 0x0&gt;,&lt;0 48 0x0&gt;, &lt;0 49 0x0&gt;;</span><br><span class="line">clock-names = &quot;dispc_clk_parent&quot;, &quot;dispc_dbi_clk_parent&quot;, &quot;dispc_dpi_clk_parent&quot;, &quot;dispc_emc_clk_parent&quot;, &quot;dispc_clk&quot;, &quot;dispc_dbi_clk&quot;, &quot;dispc_dpi_clk&quot;, &quot;dispc_emc_clk&quot;, &quot;fb_spi_clock&quot;, &quot;fb_spi_clock_parent&quot;;</span><br><span class="line">clocks = &lt;&amp;clk_256m&gt;, &lt;&amp;clk_256m&gt;, &lt;&amp;clk_384m&gt;, &lt;&amp;clk_aon_apb&gt;, &lt;&amp;clk_dispc0&gt;, &lt;&amp;clk_dispc0_dbi&gt;, &lt;&amp;clk_dispc0_dpi&gt;, &lt;&amp;clk_disp_emc&gt;, &lt;&amp;clk_spi2&gt;, &lt;&amp;ext_26m&gt;;</span><br><span class="line">clock-src = &lt;256000000 256000000 384000000&gt;;</span><br><span class="line">dpi_clk_div = &lt;7&gt;;</span><br><span class="line">sprd,fb_use_reservemem;</span><br><span class="line">sprd,fb_mem = &lt;0x9F311000 0x5EF000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>drivers/video/sprdfb/sprdfb_main.c<br>与之相匹配的lcd控制器驱动位于 <code>drivers/video/sprdfb/sprdfb_main.c</code>，当设备节点device_node被解析为platform_device注册到系统时，会和这个驱动进行匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_OF</span><br><span class="line">static const struct of_device_id sprdfb_dt_ids[] = &#123;</span><br><span class="line">        &#123; .compatible = &quot;sprd,sprdfb&quot;, &#125;,</span><br><span class="line">        &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line">static struct platform_driver sprdfb_driver = &#123;</span><br><span class="line">        .probe = sprdfb_probe,</span><br><span class="line">#ifndef CONFIG_HAS_EARLYSUSPEND</span><br><span class="line">        .suspend = sprdfb_suspend,</span><br><span class="line">        .resume = sprdfb_resume,</span><br><span class="line">#endif</span><br><span class="line">        .remove = sprdfb_remove,</span><br><span class="line">        .driver = &#123;</span><br><span class="line">                .name = &quot;sprd_fb&quot;,</span><br><span class="line">                .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">                .of_match_table = of_match_ptr(sprdfb_dt_ids),</span><br><span class="line">#endif</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">static int __init sprdfb_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        return platform_driver_register(&amp;sprdfb_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>驱动加载流程大致如下图：<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd_init.png" alt="sprd kernel lcd probe"></p><p><strong>sprdfb_probe</strong> 函数的定义如下，简单分析下代码流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static int sprdfb_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct fb_info *fb = NULL;</span><br><span class="line">    struct sprdfb_device *dev = NULL;</span><br><span class="line">    struct resource r;</span><br><span class="line"></span><br><span class="line">    fb = framebuffer_alloc(sizeof(struct sprdfb_device), &amp;pdev-&gt;dev);    //(1)分布帧缓冲使用空间</span><br><span class="line">    dev = fb-&gt;par;</span><br><span class="line">    dev-&gt;fb = fb;</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">    dev-&gt;of_dev = &amp;(pdev-&gt;dev);</span><br><span class="line">    dev-&gt;dev_id = of_alias_get_id(pdev-&gt;dev.of_node, &quot;lcd&quot;);    //(2)读取设备树中lcd id</span><br><span class="line">    printk(&quot;sprdfb: [%s] id = %d\n&quot;, __FUNCTION__, dev-&gt;dev_id);</span><br><span class="line">#else</span><br><span class="line">    dev-&gt;dev_id = pdev-&gt;id;</span><br><span class="line">#endif</span><br><span class="line">    switch(SPRDFB_IN_DATA_TYPE)&#123;</span><br><span class="line">    case SPRD_IN_DATA_TYPE_ABGR888:</span><br><span class="line">        dev-&gt;bpp = 32;</span><br><span class="line">        break;</span><br><span class="line">    case SPRD_IN_DATA_TYPE_BGR565:</span><br><span class="line">        dev-&gt;bpp = 16;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        dev-&gt;bpp = 32;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(SPRDFB_MAINLCD_ID == dev-&gt;dev_id)&#123;    //确认是主屏显示</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(3) </span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">        if(0 != of_address_to_resource(pdev-&gt;dev.of_node, 0, &amp;r))&#123;    //(4)</span><br><span class="line">            printk(KERN_ERR &quot;sprdfb: sprdfb_probe fail. (can&apos;t get register base address)\n&quot;);</span><br><span class="line">            goto err0;</span><br><span class="line">        &#125;</span><br><span class="line">        g_dispc_base_addr = r.start;</span><br><span class="line">        printk(&quot;sprdfb: set g_dispc_base_addr = 0x%x\n&quot;, g_dispc_base_addr);</span><br><span class="line">#endif</span><br><span class="line">    dev-&gt;logo_buffer_addr_v = 0;</span><br><span class="line">    if(sprdfb_panel_get(dev))&#123;    //(5) </span><br><span class="line">        dev-&gt;panel_ready = true;</span><br><span class="line">        dev-&gt;ctrl-&gt;logo_proc(dev);  //(6)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dev-&gt;panel_ready = false;</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;ctrl-&gt;early_init(dev); //(7)</span><br><span class="line">    if(!dev-&gt;panel_ready)&#123;</span><br><span class="line">        if (!sprdfb_panel_probe(dev)) &#123;</span><br><span class="line">            ret = -EIO;</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = setup_fb_mem(dev, pdev);  //(8)</span><br><span class="line">    setup_fb_info(dev); //(9)</span><br><span class="line">    /* register framebuffer device */</span><br><span class="line">    ret = register_framebuffer(fb); //(10)</span><br><span class="line">    platform_set_drvdata(pdev, dev);</span><br><span class="line">    sprdfb_create_sysfs(dev);</span><br><span class="line">    dev-&gt;ctrl-&gt;init(dev);   //(11)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>(1) 为lcd控制器分配 framebuffer 结构体 fb_info；</p></li><li><p>(2) 读取设备树中lcd id，从前面设备树的信息lcd0来看，id = 0；</p></li><li><p>(3) <code>sprdfb_dispc_ctrl</code> 保存为Soc显示控制器的操作接口；</p></li><li><p>(4) 获取设备树中配置的寄存器地址信息。</p></li><li><p>(5) <code>sprdfb_panel_get</code> 会调用<code>adapt_panel_from_uboot</code>遍历模组链表 <code>panel_list_main</code> 中 panel_cfg，将lcd_id 和 uboot中读取的模组芯片id进行对比，如果匹配则返回对应的panel_cfg；如果没有匹配，会再后续的流程中调用<code>sprdfb_panel_probe</code>重新加载模组驱动。这期间会设置 <strong>DISPC</strong> 的dsi硬件配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct panel_spec *adapt_panel_from_readid(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct panel_cfg *cfg;</span><br><span class="line">    struct list_head *panel_list;</span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(6) <code>sprdfb_dispc_logo_proc</code> 按照panel_cfg的尺寸申请缓存区，并从uboot lcd_base中拷贝logo数据；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void sprdfb_dispc_logo_proc(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">uint32_t kernel_fb_size = 0;</span><br><span class="line">uint32_t logo_src_v = 0;</span><br><span class="line">uint32_t logo_dst_v = 0;//use the second frame buffer,virtual</span><br><span class="line">uint32_t logo_dst_p = 0;//use the second frame buffer ,physical</span><br><span class="line">uint32_t logo_size = 0;// should be rgb565</span><br><span class="line"></span><br><span class="line">if(dev == NULL) &#123;</span><br><span class="line">printk(&quot;sprdfb: %s[%d]: dev == NULL, return without process logo!!\n&quot;,__func__,__LINE__);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(lcd_base_from_uboot == 0) &#123;</span><br><span class="line">printk(&quot;sprdfb: %s[%d]: lcd_base_from_uboot == 0, return without process logo!!\n&quot;,__func__,__LINE__);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(SPRDFB_PANEL_IF_DPI != dev-&gt;panel_if_type)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">    logo_size = dev-&gt;panel-&gt;width * dev-&gt;panel-&gt;height * 2;// should be rgb565</span><br><span class="line"></span><br><span class="line">dev-&gt;logo_buffer_size = logo_size;</span><br><span class="line">dev-&gt;logo_buffer_addr_v = __get_free_pages(GFP_ATOMIC | __GFP_ZERO , get_order(logo_size));</span><br><span class="line"></span><br><span class="line">logo_dst_v = dev-&gt;logo_buffer_addr_v;</span><br><span class="line">logo_dst_p = __pa(dev-&gt;logo_buffer_addr_v);</span><br><span class="line"></span><br><span class="line">    logo_src_v =  (uint32_t)ioremap(lcd_base_from_uboot, logo_size);</span><br><span class="line"></span><br><span class="line">memcpy(logo_dst_v, logo_src_v, logo_size);</span><br><span class="line">dma_sync_single_for_device(dev, logo_dst_p, logo_size, DMA_TO_DEVICE);</span><br><span class="line"></span><br><span class="line">iounmap(logo_src_v);</span><br><span class="line">    </span><br><span class="line">dispc_write(logo_dst_p, DISPC_OSD_BASE_ADDR);</span><br><span class="line">sprdfb_dispc_refresh_logo(dev);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int32_t sprdfb_dispc_refresh_logo (struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">dispc_clear_bits(0x1f, DISPC_INT_EN);//disable all interrupt</span><br><span class="line">dispc_set_bits(0x1f, DISPC_INT_CLR);// clear all interruption</span><br><span class="line">dispc_set_bits(BIT(5), DISPC_DPI_CTRL);//update</span><br><span class="line"></span><br><span class="line">//wait for update- done interruption</span><br><span class="line">for(i=0; i&lt;500; i++) &#123;</span><br><span class="line">if(!(dispc_read(DISPC_INT_RAW) &amp; (0x10)))&#123;</span><br><span class="line">udelay(1000);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    if(i &gt;= 500) &#123;</span><br><span class="line">        printk(&quot;sprdfb: [%s] wait dispc done int time out!! (0x%x)\n&quot;, __func__, dispc_read(DISPC_INT_RAW));</span><br><span class="line">    &#125;</span><br><span class="line">dispc_set_bits((1&lt;&lt;5), DISPC_INT_CLR);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(7) sprdfb_dispc_early_init 恢复使能 <strong>DISPC</strong> 模组；</p></li><li><p>(8) setup_fb_mem 解析设备树“sprd,fb_mem”配置 fb_info screen_base等参数</p></li><li><p>(9) setup_fb_info 进一步配置 fb_info，设置固定参数和可变参数；   </p></li><li><p>(10) register_framebuffer 向内核注册帧缓冲区；</p></li><li><p>(11) sprdfb_dispc_init 设置 <strong>DISPC</strong> 的dithering 和 osd layer blending功能。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>针对lcd驱动调试的一些总结：</p><ul><li>背光不亮</li></ul><blockquote><p>通常直接排查硬件，检查背光电压，pwm波形输出等</p></blockquote><ul><li>白屏显示</li></ul><blockquote><p>1.优先检查电压，一般液晶模组在完成初始化后，VGH/VGL经过charge pump，基本能够达到正负15v左右。</p></blockquote><blockquote><p>2.读取模组id，优先检查硬件接口是否有误，然后排查软件接口的设置，可通过示波器辅助快速定位。</p></blockquote><blockquote><p>3.检查是否初始化代码有误，存在模组代码不匹配的情况。</p></blockquote><ul><li>显示异常</li></ul><blockquote><p>1.优先排查硬件，曾经有遇到过BB的VDD输出2.8V，DVDD输出1.8v，但是模组内部将VDD/DVDD相连，直接导致初始化升压不够，显示异常。</p></blockquote><blockquote><p>2.检查分辨率、像素、时序配置和proch设定是否存在问题。</p></blockquote><blockquote><p>3.画面撕裂问题，一般需要开启TE，BB会在每帧数据开始前发送信号同步。</p></blockquote><blockquote><p>4.画面翻转问题，一般修改模组初始化代码，修改显示刷新方向解决。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。&lt;/p&gt;
&lt;p&gt;本文基于Android 4.4代码分析sc7731 lcd的基本流程。&lt;/p&gt;
&lt;h1 id=&quot;显示系统&quot;&gt;&lt;a href=&quot;#显示系统&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Android" scheme="http://tinylaker.github.io/categories/Android/"/>
    
    
      <category term="LCD" scheme="http://tinylaker.github.io/tags/LCD/"/>
    
  </entry>
  
  <entry>
    <title>terminal for microcontrol</title>
    <link href="http://tinylaker.github.io/2019/09/30/terminal-for-microcontrol/"/>
    <id>http://tinylaker.github.io/2019/09/30/terminal-for-microcontrol/</id>
    <published>2019-09-30T08:05:40.000Z</published>
    <updated>2019-10-06T07:34:16.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>此前的嵌入式项目开发过程中，因为硬件资源紧张，硬件工程师在进行原理图设计的时候没有使用芯片的串口，导致软件开发和调试极为困难。后来考虑使用USB CDC虚拟串口搭配命令行控制台进行调试，在gayhub上发现了这个开源的命令行控制项目 <a href="git@github.com:JingoC/terminal.git">Terminal</a></p><h1 id="Terminal简介"><a href="#Terminal简介" class="headerlink" title="Terminal简介"></a>Terminal简介</h1><p><code>Terminal</code> 支持跨平台、可选配置、日志命令、指令中断、回车和删除等常用按键配置，最大耗费系统内存不到10KB。</p><p>代码的目录结构如下，</p><ul><li><code>lib</code> 中包含自定义的字符串和队列操作。</li><li><code>module</code> 中包含对input解析和log的相关操作。</li><li><code>terminal.h</code> 和 <code>terminal.c</code> 实现了命令行控制台的基本功能，包括初始化、命令添加、命令执行、命令解析等API，供用户直接使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terminal # ls </span><br><span class="line">LICENSE    README.md  def_config examples   lib        module     terminal.c terminal.h</span><br><span class="line">terminal # ls def_config</span><br><span class="line">terminal_config.h</span><br><span class="line">terminal # ls lib</span><br><span class="line">cli_queue.c  cli_queue.h  cli_string.c cli_string.h</span><br><span class="line">terminal #</span><br><span class="line">terminal # ls module</span><br><span class="line">cli_input.c cli_input.h cli_log.c   cli_log.h   cli_time.c  cli_time.h</span><br></pre></td></tr></table></figure><h1 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h1><p>参考 <code>examples/Coocox_stm32f4</code>的工程代码和<code>README.md</code>，对当前工程添加自定义配置文件 <code>terminal_config.h</code>。</p><ul><li>使能 <code>TERM_TX_RX_EN</code> 开启输入输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TERM_TX_RX_EN  (1)    // Terminal Printf (without this don,t work)</span><br></pre></td></tr></table></figure><ul><li>复写 <code>CLI_Printf</code> 和 <code>CLI_PutChar</code> 输出函数，实现输出重定向</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#if (TERM_TX_RX_EN == 1)</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define COM_Printf(...)     printf(__VA_ARGS__)</span><br><span class="line">#define CLI_Printf          COM_Printf</span><br><span class="line">#if (ECHO_EN == 1)</span><br><span class="line">#define CLI_PutChar     putchar</span><br><span class="line">#else   // ECHO_EN != 1</span><br><span class="line">#define CLI_PutChar</span><br><span class="line">#endif  // ECHO_EN == 1</span><br><span class="line"></span><br><span class="line">#else   // TERM_TX_RX_EN != 1</span><br><span class="line">#define CLI_Printf</span><br><span class="line">#define CLI_PutChar</span><br><span class="line">#endif  // TERM_TX_RX_EN == 1</span><br></pre></td></tr></table></figure><ul><li>设置基本参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define TERM_SIZE_TASK        (20)    // Max number of commands</span><br><span class="line">#define TERM_CMD_BUF_SIZE     (60)    // Max number of character buffer string command</span><br><span class="line">#define TERM_CMD_LOG_SIZE     (10)    // Max number of loging command</span><br><span class="line">#define TERM_ARGS_BUF_SIZE    (10)    // Max number of arguments in one command</span><br><span class="line">#define TERM_ARG_SIZE         (15)    // Max number character of one arguments</span><br></pre></td></tr></table></figure></li></ul><p>另外可以使用 <code>CLI_AddCmd</code> 接口添加自定义命令，<code>CLI_GetArg</code>接口获取参数，参考<code>my_test_commands</code>目录下的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static uint8_t _t1_cmd();</span><br><span class="line">static uint8_t _t2_cmd();</span><br><span class="line"></span><br><span class="line">void MyTestCmds_Init()</span><br><span class="line">&#123;</span><br><span class="line">    CLI_AddCmd(&quot;t1&quot;, _t1_cmd, 1, TMC_PrintStartTime | TMC_PrintStopTime, &quot;t1 - description command&quot;);</span><br><span class="line">    CLI_AddCmd(&quot;t2&quot;, _t2_cmd, 0, TMC_PrintDiffTime, &quot;t2 - description command&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ***************** implementation commands ****************</span><br><span class="line"></span><br><span class="line">uint8_t _t1_cmd()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t a = 0x01;</span><br><span class="line">    uint32_t b = 0x10;</span><br><span class="line">    uint32_t c = 7;</span><br><span class="line"></span><br><span class="line">    // be sure arguments</span><br><span class="line">    c = CLI_GetArgDec(0);</span><br><span class="line"></span><br><span class="line">    // optional arguments</span><br><span class="line">    CLI_GetArgHexByFlag(&quot;-a&quot;, &amp;a);</span><br><span class="line">    CLI_GetArgHexByFlag(&quot;-b&quot;, &amp;b);</span><br><span class="line"></span><br><span class="line">    CLI_Printf(&quot;\r\na: 0x%08X\r\nb: 0x%08X\r\nc: %d&quot;, (int) a, (int) b, (int) c);</span><br><span class="line"></span><br><span class="line">    return TE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t _t2_cmd()</span><br><span class="line">&#123;</span><br><span class="line">    CLI_Printf(&quot;\r\nPress ESC&quot;);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        CLI_CheckAbort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>已经移植好的固件，在PC上枚举出虚拟串口，使用minicom打开对应串口设备，能够看到如下的相关打印信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ minicom -D /dev/tty.usbmodem3079385933364</span><br><span class="line"></span><br><span class="line">Welcome to minicom 2.7.1</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">Compiled on Aug 20 2018, 10:22:42.</span><br><span class="line">Port /dev/tty.usbmodem3079385933364, 11:38:42</span><br><span class="line"></span><br><span class="line">Press Meta-Z for help on special keys</span><br><span class="line"></span><br><span class="line">****************************************************</span><br><span class="line">|                                                  |</span><br><span class="line">|                   Terminal v1.4                  |</span><br><span class="line">|           sw ver.: Sep 10 2018 22:13:54          |</span><br><span class="line">|                                                  |</span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">Count base command: 4</span><br><span class="line">Max command: 20</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; help</span><br><span class="line">Count command: 4</span><br><span class="line">[] - mandatory argument</span><br><span class="line">&lt;&gt; - optional argument</span><br><span class="line">| - choice between arguments</span><br><span class="line">~          - reset cpu</span><br><span class="line">settime    - set current time</span><br><span class="line">        settime [h] [m] [s]</span><br><span class="line">gettime    - print current time</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;此前的嵌入式项目开发过程中，因为硬件资源紧张，硬件工程师在进行原理图设计的时候没有使用芯片的串口，导致软件开发和调试极为困难
      
    
    </summary>
    
    
      <category term="第三方库" scheme="http://tinylaker.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="Terminal" scheme="http://tinylaker.github.io/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>libusb的使用</title>
    <link href="http://tinylaker.github.io/2019/09/16/libusb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://tinylaker.github.io/2019/09/16/libusb的使用/</id>
    <published>2019-09-16T11:53:55.000Z</published>
    <updated>2019-09-29T14:54:28.338Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅从libusb api-1.0版本的使用方面解读，不详细介绍usb的基本知识和传输协议。</p><h1 id="libusb简介"><a href="#libusb简介" class="headerlink" title="libusb简介"></a>libusb简介</h1><p><strong>libusb</strong> 是一个用来访问usb设备的应用库，可以跨平台使用，支持Linux、Mac、Windows等主流操作系统，当然Andorid上也有libusb身影。</p><p>libusb相关网站：</p><p><strong>github</strong>: <a href="https://github.com/libusb/libusb" target="_blank" rel="noopener">https://github.com/libusb/libusb</a></p><p><strong>homepage</strong>: <a href="https://libusb.info/" target="_blank" rel="noopener">https://libusb.info/</a></p><p><strong>api-1.0</strong>: <a href="http://libusb.sourceforge.net/api-1.0/" target="_blank" rel="noopener">http://libusb.sourceforge.net/api-1.0/</a> </p><p>当产品需要添加自定义协议时，以hid协议为例，usb的固件代码比较容易实现。与此同时，主机也需要对应的协议来正确解析，这里通常有2种实现方式，第一种是在主机编写usb设备驱动解析协议，另一种是应用通过libusb解析协议，显然后一种方法更通用。</p><h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>libusb_init</strong><br>必须最先被执行，完成libusb的初始化。libusb_context代表libusb的会话，如果参数为NULL，会默认创建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_init(libusb_context** context);</span><br></pre></td></tr></table></figure><p><strong>libusb_exit</strong><br>取消libusb初始化，通常在程序结束时调用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_exit(struct libusb_context* ctx)</span><br></pre></td></tr></table></figure><h2 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h2><p><strong>libusb_open</strong><br>打开usb设备，获取设备句柄dev_handle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_open(libusb_device *dev, libusb_device_handle **dev_handle);</span><br></pre></td></tr></table></figure><p><strong>libusb_open_device_with_vid_pid</strong><br>方便快速打开对应pid/vid的设备，可以指定libusb会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libusb_device_handle* libusb_open_device_with_vid_pid(libusb_context *ctx, </span><br><span class="line">    unit16_t vendor_id, uint16_t product_id);</span><br></pre></td></tr></table></figure><p><strong>libusb_close</strong><br>指定设备句柄关闭设备，在程序完成前调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_close(libusb_device_handle *dev_handle);</span><br></pre></td></tr></table></figure><p><strong>libusb_get_device_list</strong><br>获得系统当前所有的usb设备的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t libusb_get_device_list（libusb_context *ctx, libusb_device ***list);</span><br></pre></td></tr></table></figure><p><strong>libusb_free_device_list</strong><br>释放前面使用的设备列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_free_device_list(libusb_device **list, int unref_devices)</span><br></pre></td></tr></table></figure><p><strong>libusb_get_configuration</strong><br>获得当前设备的配置模式，usb设备可能包含多个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int usb_get_configuration(libusb_device_handle *dev_handle, int *config);</span><br></pre></td></tr></table></figure><p><strong>libusb_set_configuration</strong><br>重新设置usb设备的配置模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int usb_set_configuration(libusb_device_handle *dev_handle, int configuration);</span><br></pre></td></tr></table></figure><p><strong>libusb_claim_interface</strong><br>获得usb设备对应接口的所有权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_claim_interface(libusb_device_handle *dev_handle, int interface_number);</span><br></pre></td></tr></table></figure><p><strong>libusb_release_interface</strong><br>释放获取usb设备接口的所有权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_release_interface(libusb_device_handle *dev_handle, int interface_number);</span><br></pre></td></tr></table></figure><p><strong>libusb_set_interface_alt_setting</strong><br>激活某个接口的交替配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_set_interface_alt_setting(libusb_device_handle *dev_handle, int interface_number, int alternate_config);</span><br></pre></td></tr></table></figure><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p><strong>libusb_control_transfer</strong><br>控制传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_control_transfer (libusb_device_handle *dev_handle, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, unsigned char *data, uint16_t wLength, unsigned int timeout);</span><br></pre></td></tr></table></figure><p><strong>libusb_bulk_transfer</strong><br>批量传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_bulk_transfer (struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout);</span><br></pre></td></tr></table></figure><p><strong>libusb_interrupt_transfer</strong><br>中断传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_interrupt_transfer (struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout);</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面的例子，是打开vid = 1234， pid = 5678的usb设备，同时检查是否有接口0的驱动，如果有直接卸载这个驱动，并获取这个接口的所有权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">libusb_context *ctx;</span><br><span class="line">libusb_device_handle* handle = NULL;  /* handle for USB device */</span><br><span class="line"></span><br><span class="line">/* Initialise libusb. */</span><br><span class="line">ret = libusb_init(&amp;ctx);</span><br><span class="line">if (ret != 0)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Error initialising libusb.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /* Open device with vid and pid */</span><br><span class="line">handle = libusb_open_device_with_vid_pid(0, 1234, 5678);</span><br><span class="line">if (!handle)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Unable to open device.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Check whether a kernel driver is attached to interface #0. If so, we&apos;ll</span><br><span class="line">* need to detach it.</span><br><span class="line">*/</span><br><span class="line">if (libusb_kernel_driver_active(handle, 0)) &#123;</span><br><span class="line">ret = libusb_detach_kernel_driver(handle, 0);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">fprintf(stderr, &quot;Error detaching kernel driver.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Claim interface #0. */</span><br><span class="line">ret = libusb_claim_interface(handle, 0);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">fprintf(stderr, &quot;Error claiming interface.\n&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅从libusb api-1.0版本的使用方面解读，不详细介绍usb的基本知识和传输协议。&lt;/p&gt;
&lt;h1 id=&quot;libusb简介&quot;&gt;&lt;a href=&quot;#libusb简介&quot; class=&quot;headerlink&quot; title=&quot;libusb简介&quot;&gt;&lt;/a&gt;libusb简
      
    
    </summary>
    
    
      <category term="第三方库" scheme="http://tinylaker.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="libusb" scheme="http://tinylaker.github.io/tags/libusb/"/>
    
  </entry>
  
  <entry>
    <title>cJSON的使用</title>
    <link href="http://tinylaker.github.io/2019/09/15/cJSON%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://tinylaker.github.io/2019/09/15/cJSON的使用/</id>
    <published>2019-09-14T17:41:47.000Z</published>
    <updated>2019-09-16T08:30:36.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JSON格式"><a href="#1-JSON格式" class="headerlink" title="1. JSON格式"></a>1. JSON格式</h1><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。同时也易于机器解析和生成。</p><p>JSON建构于两种结构：<br><strong>键值对的集合（A collection of name/value pairs）</strong><br><strong>值的有序列表（An ordered list of values）</strong></p><h1 id="2-cJSON"><a href="#2-cJSON" class="headerlink" title="2. cJSON"></a>2. cJSON</h1><p>c语言中处理json格式的数据，可以借助于cJSON函数库，简单且效率高。</p><p>cJSON的开源仓库地址： <a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="noopener">https://github.com/DaveGamble/cJSON</a></p><p>cJSON.h定义了结构体cJSON来描述JSON对象，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct cJSON</span><br><span class="line">&#123;</span><br><span class="line">    /* 对象或数组链表的前后节点 */</span><br><span class="line">    struct cJSON *next;</span><br><span class="line">    struct cJSON *prev;</span><br><span class="line">    /* 对象火数组链表的子节点 */</span><br><span class="line">    struct cJSON *child;</span><br><span class="line"></span><br><span class="line">    /* 键值的类型 */</span><br><span class="line">    int type;</span><br><span class="line"></span><br><span class="line">    /* 保存键值字符串 */</span><br><span class="line">    char *valuestring;</span><br><span class="line"></span><br><span class="line">    int valueint;</span><br><span class="line">    double valuedouble;</span><br><span class="line"></span><br><span class="line">    /* 保存键值的名字 */</span><br><span class="line">    char *string;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure><h2 id="2-1-cJSON-API"><a href="#2-1-cJSON-API" class="headerlink" title="2.1 cJSON API"></a>2.1 cJSON API</h2><h3 id="2-1-1-cJSON-Parse"><a href="#2-1-1-cJSON-Parse" class="headerlink" title="2.1.1 cJSON_Parse"></a>2.1.1 cJSON_Parse</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 解析JSON格式数据，按照cJSON结构进行序列化</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_Parse(const char *value)</span><br></pre></td></tr></table></figure><h3 id="2-1-2-cJSON-Print"><a href="#2-1-2-cJSON-Print" class="headerlink" title="2.1.2 cJSON_Print"></a>2.1.2 cJSON_Print</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 解析cJSON格式数据，转换成JSON格式的字符串</span><br><span class="line"> * @ret: 成功返回指向内存块中JSON字符串的地址，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(char *) cJSON_Print(const cJSON *item)</span><br></pre></td></tr></table></figure><h3 id="2-1-3-cJSON-Delete"><a href="#2-1-3-cJSON-Delete" class="headerlink" title="2.1.3 cJSON_Delete"></a>2.1.3 cJSON_Delete</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * @func: 删除释放cJSON及其子节点。</span><br><span class="line"> * @ret:</span><br><span class="line"> */</span><br><span class="line">(void) cJSON_Delete(cJSON *item)</span><br></pre></td></tr></table></figure><h3 id="2-1-4-cJSON-CreateObject"><a href="#2-1-4-cJSON-CreateObject" class="headerlink" title="2.1.4 cJSON_CreateObject"></a>2.1.4 cJSON_CreateObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 创建新的cJSON对象</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_CreateObject(void)</span><br></pre></td></tr></table></figure><h3 id="2-1-5-cJSON-GetObjectItem"><a href="#2-1-5-cJSON-GetObjectItem" class="headerlink" title="2.1.5 cJSON_GetObjectItem"></a>2.1.5 cJSON_GetObjectItem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 获取JSON字符串字段值</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)</span><br></pre></td></tr></table></figure><h2 id="2-2-如何解析JSON格式"><a href="#2-2-如何解析JSON格式" class="headerlink" title="2.2 如何解析JSON格式"></a>2.2 如何解析JSON格式</h2><p>以github仓库README.md中JSON数据为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Awesome 4K&quot;,</span><br><span class="line">    &quot;resolutions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 1280,</span><br><span class="line">            &quot;height&quot;: 720</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 1920,</span><br><span class="line">            &quot;height&quot;: 1080</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 3840,</span><br><span class="line">            &quot;height&quot;: 2160</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-转换JSON格式为cJSON"><a href="#2-2-1-转换JSON格式为cJSON" class="headerlink" title="2.2.1 转换JSON格式为cJSON"></a>2.2.1 转换JSON格式为cJSON</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cJSON *monitor_json = cJSON_Parse(monitor);</span><br><span class="line">if (monitor_json == NULL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-解析字符串数据"><a href="#2-2-2-解析字符串数据" class="headerlink" title="2.2.2 解析字符串数据"></a>2.2.2 解析字符串数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = cJSON_GetObjectItemCaseSensitive(monitor_json, &quot;name&quot;);</span><br><span class="line">if (cJSON_IsString(name) &amp;&amp; (name-&gt;valuestring != NULL))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-解析数组数据"><a href="#2-2-3-解析数组数据" class="headerlink" title="2.2.3 解析数组数据"></a>2.2.3 解析数组数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolutions = cJSON_GetObjectItemCaseSensitive(monitor_json, &quot;resolutions&quot;);</span><br><span class="line">cJSON_ArrayForEach(resolution, resolutions)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *width = cJSON_GetObjectItemCaseSensitive(resolution, &quot;width&quot;);</span><br><span class="line">    cJSON *height = cJSON_GetObjectItemCaseSensitive(resolution, &quot;height&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-释放内存"><a href="#2-2-4-释放内存" class="headerlink" title="2.2.4 释放内存"></a>2.2.4 释放内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_Delete(monitor_json);</span><br></pre></td></tr></table></figure><h2 id="2-3-如何生成JSON格式"><a href="#2-3-如何生成JSON格式" class="headerlink" title="2.3 如何生成JSON格式"></a>2.3 如何生成JSON格式</h2><h3 id="2-3-1-创建cJSON结构体"><a href="#2-3-1-创建cJSON结构体" class="headerlink" title="2.3.1 创建cJSON结构体"></a>2.3.1 创建cJSON结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON *monitor = cJSON_CreateObject();</span><br></pre></td></tr></table></figure><h3 id="2-3-2-添加字符串数据"><a href="#2-3-2-添加字符串数据" class="headerlink" title="2.3.2 添加字符串数据"></a>2.3.2 添加字符串数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_AddStringToObject(monitor, &quot;name&quot;, &quot;Awesome 4K&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-3-3-添加数组数据"><a href="#2-3-3-添加数组数据" class="headerlink" title="2.3.3 添加数组数据"></a>2.3.3 添加数组数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resolutions = cJSON_AddArrayToObject(monitor, &quot;resolutions&quot;);</span><br><span class="line"></span><br><span class="line">for (index = 0; index &lt; (sizeof(resolution_numbers) / (2 * sizeof(int))); ++index)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *resolution = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line">    if (cJSON_AddNumberToObject(resolution, &quot;width&quot;, resolution_numbers[index][0]) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cJSON_AddNumberToObject(resolution, &quot;height&quot;, resolution_numbers[index][1]) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cJSON_AddItemToArray(resolutions, resolution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-格式化JSON数据"><a href="#2-3-4-格式化JSON数据" class="headerlink" title="2.3.4 格式化JSON数据"></a>2.3.4 格式化JSON数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *string = cJSON_Print(monitor);</span><br></pre></td></tr></table></figure><h3 id="2-3-5-释放内存"><a href="#2-3-5-释放内存" class="headerlink" title="2.3.5 释放内存"></a>2.3.5 释放内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cJSON_free(string);</span><br><span class="line">cJSON_Delete(monitor);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-JSON格式&quot;&gt;&lt;a href=&quot;#1-JSON格式&quot; class=&quot;headerlink&quot; title=&quot;1. JSON格式&quot;&gt;&lt;/a&gt;1. JSON格式&lt;/h1&gt;&lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换
      
    
    </summary>
    
    
      <category term="第三方库" scheme="http://tinylaker.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="cJSON" scheme="http://tinylaker.github.io/tags/cJSON/"/>
    
  </entry>
  
</feed>
