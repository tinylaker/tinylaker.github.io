<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tinylaker blog</title>
  
  <subtitle>stay hungry stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tinylaker.github.io/"/>
  <updated>2019-09-29T07:34:30.541Z</updated>
  <id>http://tinylaker.github.io/</id>
  
  <author>
    <name>tinylaker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>libusb的使用</title>
    <link href="http://tinylaker.github.io/2019/09/16/libusb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://tinylaker.github.io/2019/09/16/libusb的使用/</id>
    <published>2019-09-16T11:53:55.000Z</published>
    <updated>2019-09-29T07:34:30.541Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅从libusb api-1.0版本的使用方面解读，不详细介绍usb的基本知识和传输协议。</p><h1 id="libusb简介"><a href="#libusb简介" class="headerlink" title="libusb简介"></a>libusb简介</h1><p><strong>libusb</strong> 是一个用来访问usb设备的应用库，可以跨平台使用，支持Linux、Mac、Windows等主流操作系统，当然Andorid上也有libusb身影。</p><p>libusb相关网站：</p><p><strong>github</strong>: <a href="https://github.com/libusb/libusb" target="_blank" rel="noopener">https://github.com/libusb/libusb</a></p><p><strong>homepage</strong>: <a href="https://libusb.info/" target="_blank" rel="noopener">https://libusb.info/</a></p><p><strong>api-1.0</strong>: <a href="http://libusb.sourceforge.net/api-1.0/" target="_blank" rel="noopener">http://libusb.sourceforge.net/api-1.0/</a> </p><p>当产品需要添加自定义协议时，以hid协议为例，usb的固件代码比较容易实现。与此同时，主机也需要对应的协议来正确解析，这里通常有2种实现方式，第一种是在主机编写usb设备驱动解析协议，另一种是应用通过libusb解析协议，显然后一种方法更通用。</p><h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>libusb_init</strong><br>必须最先被执行，完成libusb的初始化。libusb_context代表libusb的会话，如果参数为NULL，会默认创建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_init(libusb_context** context);</span><br></pre></td></tr></table></figure><p><strong>libusb_exit</strong><br>取消libusb初始化，通常在程序结束时调用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_exit(struct libusb_context* ctx)</span><br></pre></td></tr></table></figure><h2 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h2><p><strong>libusb_open</strong><br>打开usb设备，获取设备句柄dev_handle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_open(libusb_device *dev, libusb_device_handle **dev_handle);</span><br></pre></td></tr></table></figure><p><strong>libusb_open_device_with_vid_pid</strong><br>方便快速打开对应pid/vid的设备，可以指定libusb会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libusb_device_handle* libusb_open_device_with_vid_pid(libusb_context *ctx, </span><br><span class="line">    unit16_t vendor_id, uint16_t product_id);</span><br></pre></td></tr></table></figure><p><strong>libusb_close</strong><br>指定设备句柄关闭设备，在程序完成前调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_close(libusb_device_handle *dev_handle);</span><br></pre></td></tr></table></figure><p><strong>libusb_get_device_list</strong><br>获得系统当前所有的usb设备的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t libusb_get_device_list（libusb_context *ctx, libusb_device ***list);</span><br></pre></td></tr></table></figure><p><strong>libusb_free_device_list</strong><br>释放前面使用的设备列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_free_device_list(libusb_device **list, int unref_devices)</span><br></pre></td></tr></table></figure><p><strong>libusb_get_configuration</strong><br>获得当前设备的配置模式，usb设备可能包含多个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int usb_get_configuration(libusb_device_handle *dev_handle, int *config);</span><br></pre></td></tr></table></figure><p><strong>libusb_set_configuration</strong><br>重新设置usb设备的配置模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int usb_set_configuration(libusb_device_handle *dev_handle, int configuration);</span><br></pre></td></tr></table></figure><p><strong>libusb_claim_interface</strong><br>获得usb设备对应接口的所有权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_claim_interface(libusb_device_handle *dev_handle, int interface_number);</span><br></pre></td></tr></table></figure><p><strong>libusb_release_interface</strong><br>释放获取usb设备接口的所有权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_release_interface(libusb_device_handle *dev_handle, int interface_number);</span><br></pre></td></tr></table></figure><p><strong>libusb_set_interface_alt_setting</strong><br>激活某个接口的交替配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_set_interface_alt_setting(libusb_device_handle *dev_handle, int interface_number, int alternate_config);</span><br></pre></td></tr></table></figure><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p><strong>libusb_control_transfer</strong><br>控制传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_control_transfer (libusb_device_handle *dev_handle, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, unsigned char *data, uint16_t wLength, unsigned int timeout);</span><br></pre></td></tr></table></figure><p><strong>libusb_bulk_transfer</strong><br>批量传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_bulk_transfer (struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout);</span><br></pre></td></tr></table></figure><p><strong>libusb_interrupt_transfer</strong><br>中断传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_interrupt_transfer (struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout);</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面的例子，是打开vid = 1234， pid = 5678的usb设备，同时检查是否有接口0的驱动，如果有直接卸载这个驱动，并获取这个接口的所有权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">libusb_context *ctx;</span><br><span class="line">libusb_device_handle* handle = NULL;  /* handle for USB device */</span><br><span class="line"></span><br><span class="line">/* Initialise libusb. */</span><br><span class="line">ret = libusb_init(&amp;ctx);</span><br><span class="line">if (ret != 0)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Error initialising libusb.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /* Open device with vid and pid */</span><br><span class="line">handle = libusb_open_device_with_vid_pid(0, 1234, 5678);</span><br><span class="line">if (!handle)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Unable to open device.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Check whether a kernel driver is attached to interface #0. If so, we&apos;ll</span><br><span class="line">* need to detach it.</span><br><span class="line">*/</span><br><span class="line">if (libusb_kernel_driver_active(handle, 0)) &#123;</span><br><span class="line">ret = libusb_detach_kernel_driver(handle, 0);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">fprintf(stderr, &quot;Error detaching kernel driver.\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Claim interface #0. */</span><br><span class="line">ret = libusb_claim_interface(handle, 0);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">fprintf(stderr, &quot;Error claiming interface.\n&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅从libusb api-1.0版本的使用方面解读，不详细介绍usb的基本知识和传输协议。&lt;/p&gt;
&lt;h1 id=&quot;libusb简介&quot;&gt;&lt;a href=&quot;#libusb简介&quot; class=&quot;headerlink&quot; title=&quot;libusb简介&quot;&gt;&lt;/a&gt;libusb简
      
    
    </summary>
    
    
      <category term="第三方库" scheme="http://tinylaker.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="libusb" scheme="http://tinylaker.github.io/tags/libusb/"/>
    
  </entry>
  
  <entry>
    <title>cJSON的使用</title>
    <link href="http://tinylaker.github.io/2019/09/15/cJSON%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://tinylaker.github.io/2019/09/15/cJSON的使用/</id>
    <published>2019-09-14T17:41:47.000Z</published>
    <updated>2019-09-16T08:30:36.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JSON格式"><a href="#1-JSON格式" class="headerlink" title="1. JSON格式"></a>1. JSON格式</h1><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。同时也易于机器解析和生成。</p><p>JSON建构于两种结构：<br><strong>键值对的集合（A collection of name/value pairs）</strong><br><strong>值的有序列表（An ordered list of values）</strong></p><h1 id="2-cJSON"><a href="#2-cJSON" class="headerlink" title="2. cJSON"></a>2. cJSON</h1><p>c语言中处理json格式的数据，可以借助于cJSON函数库，简单且效率高。</p><p>cJSON的开源仓库地址： <a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="noopener">https://github.com/DaveGamble/cJSON</a></p><p>cJSON.h定义了结构体cJSON来描述JSON对象，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct cJSON</span><br><span class="line">&#123;</span><br><span class="line">    /* 对象或数组链表的前后节点 */</span><br><span class="line">    struct cJSON *next;</span><br><span class="line">    struct cJSON *prev;</span><br><span class="line">    /* 对象火数组链表的子节点 */</span><br><span class="line">    struct cJSON *child;</span><br><span class="line"></span><br><span class="line">    /* 键值的类型 */</span><br><span class="line">    int type;</span><br><span class="line"></span><br><span class="line">    /* 保存键值字符串 */</span><br><span class="line">    char *valuestring;</span><br><span class="line"></span><br><span class="line">    int valueint;</span><br><span class="line">    double valuedouble;</span><br><span class="line"></span><br><span class="line">    /* 保存键值的名字 */</span><br><span class="line">    char *string;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure><h2 id="2-1-cJSON-API"><a href="#2-1-cJSON-API" class="headerlink" title="2.1 cJSON API"></a>2.1 cJSON API</h2><h3 id="2-1-1-cJSON-Parse"><a href="#2-1-1-cJSON-Parse" class="headerlink" title="2.1.1 cJSON_Parse"></a>2.1.1 cJSON_Parse</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 解析JSON格式数据，按照cJSON结构进行序列化</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_Parse(const char *value)</span><br></pre></td></tr></table></figure><h3 id="2-1-2-cJSON-Print"><a href="#2-1-2-cJSON-Print" class="headerlink" title="2.1.2 cJSON_Print"></a>2.1.2 cJSON_Print</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 解析cJSON格式数据，转换成JSON格式的字符串</span><br><span class="line"> * @ret: 成功返回指向内存块中JSON字符串的地址，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(char *) cJSON_Print(const cJSON *item)</span><br></pre></td></tr></table></figure><h3 id="2-1-3-cJSON-Delete"><a href="#2-1-3-cJSON-Delete" class="headerlink" title="2.1.3 cJSON_Delete"></a>2.1.3 cJSON_Delete</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * @func: 删除释放cJSON及其子节点。</span><br><span class="line"> * @ret:</span><br><span class="line"> */</span><br><span class="line">(void) cJSON_Delete(cJSON *item)</span><br></pre></td></tr></table></figure><h3 id="2-1-4-cJSON-CreateObject"><a href="#2-1-4-cJSON-CreateObject" class="headerlink" title="2.1.4 cJSON_CreateObject"></a>2.1.4 cJSON_CreateObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 创建新的cJSON对象</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_CreateObject(void)</span><br></pre></td></tr></table></figure><h3 id="2-1-5-cJSON-GetObjectItem"><a href="#2-1-5-cJSON-GetObjectItem" class="headerlink" title="2.1.5 cJSON_GetObjectItem"></a>2.1.5 cJSON_GetObjectItem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 获取JSON字符串字段值</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)</span><br></pre></td></tr></table></figure><h2 id="2-2-如何解析JSON格式"><a href="#2-2-如何解析JSON格式" class="headerlink" title="2.2 如何解析JSON格式"></a>2.2 如何解析JSON格式</h2><p>以github仓库README.md中JSON数据为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Awesome 4K&quot;,</span><br><span class="line">    &quot;resolutions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 1280,</span><br><span class="line">            &quot;height&quot;: 720</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 1920,</span><br><span class="line">            &quot;height&quot;: 1080</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 3840,</span><br><span class="line">            &quot;height&quot;: 2160</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-转换JSON格式为cJSON"><a href="#2-2-1-转换JSON格式为cJSON" class="headerlink" title="2.2.1 转换JSON格式为cJSON"></a>2.2.1 转换JSON格式为cJSON</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cJSON *monitor_json = cJSON_Parse(monitor);</span><br><span class="line">if (monitor_json == NULL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-解析字符串数据"><a href="#2-2-2-解析字符串数据" class="headerlink" title="2.2.2 解析字符串数据"></a>2.2.2 解析字符串数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = cJSON_GetObjectItemCaseSensitive(monitor_json, &quot;name&quot;);</span><br><span class="line">if (cJSON_IsString(name) &amp;&amp; (name-&gt;valuestring != NULL))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-解析数组数据"><a href="#2-2-3-解析数组数据" class="headerlink" title="2.2.3 解析数组数据"></a>2.2.3 解析数组数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolutions = cJSON_GetObjectItemCaseSensitive(monitor_json, &quot;resolutions&quot;);</span><br><span class="line">cJSON_ArrayForEach(resolution, resolutions)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *width = cJSON_GetObjectItemCaseSensitive(resolution, &quot;width&quot;);</span><br><span class="line">    cJSON *height = cJSON_GetObjectItemCaseSensitive(resolution, &quot;height&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-释放内存"><a href="#2-2-4-释放内存" class="headerlink" title="2.2.4 释放内存"></a>2.2.4 释放内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_Delete(monitor_json);</span><br></pre></td></tr></table></figure><h2 id="2-3-如何生成JSON格式"><a href="#2-3-如何生成JSON格式" class="headerlink" title="2.3 如何生成JSON格式"></a>2.3 如何生成JSON格式</h2><h3 id="2-3-1-创建cJSON结构体"><a href="#2-3-1-创建cJSON结构体" class="headerlink" title="2.3.1 创建cJSON结构体"></a>2.3.1 创建cJSON结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON *monitor = cJSON_CreateObject();</span><br></pre></td></tr></table></figure><h3 id="2-3-2-添加字符串数据"><a href="#2-3-2-添加字符串数据" class="headerlink" title="2.3.2 添加字符串数据"></a>2.3.2 添加字符串数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_AddStringToObject(monitor, &quot;name&quot;, &quot;Awesome 4K&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-3-3-添加数组数据"><a href="#2-3-3-添加数组数据" class="headerlink" title="2.3.3 添加数组数据"></a>2.3.3 添加数组数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resolutions = cJSON_AddArrayToObject(monitor, &quot;resolutions&quot;);</span><br><span class="line"></span><br><span class="line">for (index = 0; index &lt; (sizeof(resolution_numbers) / (2 * sizeof(int))); ++index)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *resolution = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line">    if (cJSON_AddNumberToObject(resolution, &quot;width&quot;, resolution_numbers[index][0]) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cJSON_AddNumberToObject(resolution, &quot;height&quot;, resolution_numbers[index][1]) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cJSON_AddItemToArray(resolutions, resolution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-格式化JSON数据"><a href="#2-3-4-格式化JSON数据" class="headerlink" title="2.3.4 格式化JSON数据"></a>2.3.4 格式化JSON数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *string = cJSON_Print(monitor);</span><br></pre></td></tr></table></figure><h3 id="2-3-5-释放内存"><a href="#2-3-5-释放内存" class="headerlink" title="2.3.5 释放内存"></a>2.3.5 释放内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cJSON_free(string);</span><br><span class="line">cJSON_Delete(monitor);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-JSON格式&quot;&gt;&lt;a href=&quot;#1-JSON格式&quot; class=&quot;headerlink&quot; title=&quot;1. JSON格式&quot;&gt;&lt;/a&gt;1. JSON格式&lt;/h1&gt;&lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换
      
    
    </summary>
    
    
      <category term="第三方库" scheme="http://tinylaker.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="cJSON" scheme="http://tinylaker.github.io/tags/cJSON/"/>
    
  </entry>
  
</feed>
