<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="Tinylaker blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="个人学习总结">
<meta name="keywords" content="嵌入式系统">
<meta property="og:type" content="website">
<meta property="og:title" content="Tinylaker blog">
<meta property="og:url" content="http://tinylaker.github.io/index.html">
<meta property="og:site_name" content="Tinylaker blog">
<meta property="og:description" content="个人学习总结">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tinylaker blog">
<meta name="twitter:description" content="个人学习总结">
  <link rel="canonical" href="http://tinylaker.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Tinylaker blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ddfa4a6ba83ff65311f95d251f9389b3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tinylaker blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">stay hungry stay foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tinylaker">
      <meta itemprop="description" content="个人学习总结">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tinylaker blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/09/sc7731-lcd流程分析/" class="post-title-link" itemprop="url">sc7731 lcd流程分析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-09 19:34:45" itemprop="dateCreated datePublished" datetime="2019-11-09T19:34:45+08:00">2019-11-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 21:48:32" itemprop="dateModified" datetime="2019-11-10T21:48:32+08:00">2019-11-10</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。</p>
<p>本文基于Android 4.4代码分析sc7731 lcd的基本流程。</p>
<h1 id="显示系统"><a href="#显示系统" class="headerlink" title="显示系统"></a>显示系统</h1><p>这里暂时以7710芯片手册为例，多媒体显示系统包含 LCDC 和 DISPC，其中 LCDC 仅支持 MCU 接口类型，支持 2 路显示；而 DISPC 同时支持 DBI 和 DPI 接口类型。</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png" alt="lcd"></p>
<ul>
<li>LCDC</li>
</ul>
<p>支持最多6个图层的Alaha Blending，RGB888数据格式到RGB565/RGB666数据格式的Dithering等功能。</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcdc_module.png" alt="lcdc"></p>
<ul>
<li>LCM</li>
</ul>
<p>LCM接收AHB总线或者LCDC数据，并按照MCU接口格式按照固定的时序传输到显示模组上。<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcm_module.png" alt="lcm"></p>
<p>MCU支持8080和6080两种传输格式，两者的区别只是在读写控制上。</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/8080.png" alt="8080"></p>
<ul>
<li>DISPC</li>
</ul>
<p>这里可以看出2种路线，一种直接由LCDC DBI经由DISPC DBI输出；另一种直接由AXI Domain到DISPC DBI/DPI输出。所以如果使用MIPI接口显示模组，是不需要经过LCDC显示模块的，直接由DISPC模块控制。      </p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/DISPC.png" alt="DISPC"></p>
<h1 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h1><p>lcd相关源码位于 <code>drivers/video/sprdfb</code>，代码文件截图如下:</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sc7731_uboot_lcd.png" alt="uboot source code"></p>
<p>可以看到代码兼容了多款 Soc，Makefile 中也包含了多个平台的配置。</p>
<p>头文件 <code>include/configs/sp7731gea.h</code>，里面定义了 <code>CONFIG_SC8830</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SC8830</span><br><span class="line">#define CONFIG_DSIH_VERSION_1P21A</span><br><span class="line">#define CONFIG_FB_LCD_NT35516_MIPI</span><br></pre></td></tr></table></figure>

<p>这里值得一提的是7731和8830的AP相同，只是Modem存在差异，前者支持WCMDA，后者支持TD_SCMDA。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_SC8830)+= sprdfb_main.o sprdfb_panel.o sprdfb_dispc.o \</span><br><span class="line">    sprdfb_mcu.o sprdfb_rgb.o sprdfb_mipi.o \</span><br><span class="line">     sprdfb_i2c.o sprdfb_spi.o sprdfb_dsi.o \</span><br><span class="line">     sprdfb_chip_common.o sprdfb_chip_8830.o</span><br></pre></td></tr></table></figure>

<p>能够看出该平台的显示系统支持多种lcd接口，包括mcu、rgb、mipi、i2c、spi。</p>
<p>这里的mipi dsi有2个不同版本的IP核，参考头文件中的定义，这里使用的是dsi_1_21a中的代码。</p>
<p>下面以 <code>lcd_nt35516_mipi.c</code> 为例，分析 uboot lcd 的整个流程。</p>
<h2 id="lcd-模组配置"><a href="#lcd-模组配置" class="headerlink" title="lcd 模组配置"></a>lcd 模组配置</h2><ol>
<li><p><code>drivers/video/sprdfb/lcd/Makefile</code> 包含编译该屏驱动的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_FB_LCD_NT35516_MIPI) += lcd_nt35516_mipi.o</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>drivers/video/sprdfb/sprdfb_panel.c</code> 中包含该屏的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern struct panel_spec lcd_nt35516_mipi_spec;</span><br><span class="line">static struct panel_cfg panel_cfg[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">#ifdef CONFIG_FB_LCD_NT35516_MIPI </span><br><span class="line">    &#123; </span><br><span class="line">        .lcd_id = 0x16, </span><br><span class="line">        .panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">    &#125;,</span><br><span class="line"> #endif</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code> 中详细描述了该模组的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">        //.cap = PANEL_CAP_NOT_TEAR_SYNC,</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">        .display_width = 480,</span><br><span class="line">        .display_height= 854,</span><br><span class="line">#endif</span><br><span class="line">        .width = 540,</span><br><span class="line">        .height = 960,</span><br><span class="line">        .fps = 60,</span><br><span class="line">        .type = LCD_MODE_DSI,</span><br><span class="line">        .direction = LCD_DIRECT_NORMAL,</span><br><span class="line">        .info = &#123;</span><br><span class="line">                .mipi = &amp;lcd_nt35516_mipi_info    //(1) mipi lcd模组的常规配置</span><br><span class="line">        &#125;,</span><br><span class="line">        .ops = &amp;lcd_nt35516_mipi_operations,    //(2) mipi lcd的操作集合</span><br><span class="line">&#125;;</span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">        .work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">        .video_bus_width = 24, /*18,16*/</span><br><span class="line">        .lan_number = 3,</span><br><span class="line">        .phy_feq = 500*1000,</span><br><span class="line">        .h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .timing = &amp;lcd_nt35516_mipi_timing,    //(3) mipi lcd的时序proch配置</span><br><span class="line">        .ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">        .panel_init = nt35516_mipi_init,    //包含mipi屏大量初始化代码</span><br><span class="line">        .panel_readid = nt35516_readid,    //mipi屏的读取id操作</span><br><span class="line">&#125;;</span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">        .hfp = 20,  /* unit: pixel */</span><br><span class="line">        .hbp = 20,</span><br><span class="line">        .hsync = 20,//4,</span><br><span class="line">        .vfp = 10, /*unit: line*/</span><br><span class="line">        .vbp = 10,</span><br><span class="line">        .vsync = 6,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="lcd-模组初始化流程"><a href="#lcd-模组初始化流程" class="headerlink" title="lcd 模组初始化流程"></a>lcd 模组初始化流程</h2><p>系统上电执行芯片 <strong>RomCode</strong>，完成 DDR 和外部存储器等常用外设的初始化；</p>
<p>之后读取外部存储器中的 uboot 并跳转执行，优先完成板级初始化 <code>board_init_f</code> 和 <code>board_init_r</code>，其中 <code>board_init_r</code> 中调用了<code>stdio_init</code>。代码流程图如下：</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprdfb_uboot_lcd_init.png" alt="sprdfb_lcd_init"></p>
<p>我们把重点聚焦在 sprdfb_probe 的实现上，下面剔除了部分无关代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c  </span><br><span class="line"></span><br><span class="line">static int sprdfb_probe(void * lcdbase)</span><br><span class="line">&#123;</span><br><span class="line">        struct sprdfb_device *dev = &amp;s_sprdfb_dev;</span><br><span class="line">        set_backlight(0);    //(1)</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(2) </span><br><span class="line">        dev-&gt;ctrl-&gt;early_init(dev);    //(3)</span><br><span class="line">        if (0 != sprdfb_panel_probe(dev)) &#123;    //(4)</span><br><span class="line">                sprdfb_panel_remove(dev);</span><br><span class="line">                dev-&gt;ctrl-&gt;uninit(dev);</span><br><span class="line">                printf(&quot;sprdfb: failed to probe\n&quot;);</span><br><span class="line">                return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        dev-&gt;smem_start = ((uint32_t)lcdbase);</span><br><span class="line">        dev-&gt;ctrl-&gt;init(dev);    //(5)</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>(1) 关闭pwm控制</li>
<li>(2) 获取display controller的接口，定义在 <code>sprdfb_dispc.c</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_dispc.c</span><br><span class="line"></span><br><span class="line">struct display_ctrl sprdfb_dispc_ctrl = &#123;</span><br><span class="line">        .name           = &quot;dispc&quot;,</span><br><span class="line">        .early_init             = sprdfb_dispc_early_init,</span><br><span class="line">        .init                   = sprdfb_dispc_init,</span><br><span class="line">        .uninit         = sprdfb_dispc_uninit,</span><br><span class="line">        .refresh                = sprdfb_dispc_refresh,</span><br><span class="line">        .update_clk     = dispc_update_clock,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>(3) 调用<code>sprdfb_dispc_early_init</code>，配置相关的clk，使能<code>dispc module</code></li>
<li>(4) <code>sprdfb_panel_probe</code> 会读取和保存 lcd 模组的 id，并对该模组完成初始化。</li>
<li>(5) <code>sprdfb_dispc_init</code> 会完成显示系统 dithering 和 osd layer 的设置。</li>
</ul>
<p>需要特别注意 uboot lcd 初始化流程中会保存 <strong>lcd_base</strong> 和 <strong>lcd_id</strong>，通过命令行参数传递，以供 kernel 阶段继续使用。</p>
<h2 id="lcd-刷新显示流程"><a href="#lcd-刷新显示流程" class="headerlink" title="lcd 刷新显示流程"></a>lcd 刷新显示流程</h2><p>看到这里读者可能会有疑问，uboot logo 是什么时候显示的呢？</p>
<p>下面开始分析lcd refresh流程，这里要从 <code>board_init_r</code> 中的<strong>do_cboot</strong>代码分析。</p>
<ol>
<li><p>normal_mode<br>代码定义了多种启动方式：normal、recovery、fastboot、charge、watchdog等，这里直接看normal_boot的代码。<br>首先初始化马达硬件，完成开机震动，然后调用 vlx_nand_boot，这里的代码取决有是 nand 方案还是 emmc 方案，这里假设是 emmc 启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ property/normal_mode.c</span><br><span class="line"></span><br><span class="line">void normal_mode(void) &#123;</span><br><span class="line">    vibrator_hw_init();</span><br><span class="line">    set_vibrator(1);</span><br><span class="line">#if BOOT_NATIVE_LINUX</span><br><span class="line">    vlx_nand_boot(BOOT_PART, CONFIG_BOOTARGS, BACKLIGHT_ON);</span><br><span class="line">#else</span><br><span class="line">    vlx_nand_boot(BOOT_PART, NULL, BACKLIGHT_ON);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>vlx_nand_boot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ property/normal_emc_mode.c</span><br><span class="line"></span><br><span class="line">void vlx_nand_boot(char * kernel_pname, char * cmdline, int backlight_set) &#123;</span><br><span class="line">    _boot_display_logo(dev, backlight_set);    //(1)</span><br><span class="line">    set_vibrator(FALSE);</span><br><span class="line">    _boot_load_kernel_ramdisk_image(dev, kernel_pname, hdr);</span><br><span class="line">    _boot_secure_check();</span><br><span class="line">    sipc_addr_reset();</span><br><span class="line">    vlx_entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>调用_boot_display_logo，读取logo分区图片内容，并调用lcd_display_logo，重点关注。</p>
</li>
<li><p>关闭马达;</p>
</li>
<li><p>从存储器读取kernel、ramdisk、dtb image，保存相关内存地址。</p>
</li>
<li><p>secure boot校验流程，根据产品定义，可能会对DSP、Modem、SIMLOCK等image进行校验。</p>
</li>
<li><p>sipc 内存区域清零，这部分由展讯自己实现，用于AP和Modem之间的通信交换，后面有文章会涉及。</p>
</li>
<li><p>跳转到内核启动</p>
</li>
</ul>
<ol start="3">
<li><p>_boot_display_logo<br>从logo分区中读取图片信息，存放到缓存中，调用<code>lcd_display_logo</code>刷新显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LOCAL __inline void _boot_display_logo(block_dev_desc_t *dev, int backlight_set)</span><br><span class="line">&#123;</span><br><span class="line">        size_t size;</span><br><span class="line">#if defined(CONFIG_LCD_720P) || defined(CONFIG_LCD_HD) //LiWei add CONFIG_LCD_HD</span><br><span class="line">        size = 1&lt;&lt;20;</span><br><span class="line">#else</span><br><span class="line">        size = 1&lt;&lt;19;</span><br><span class="line">#endif</span><br><span class="line">        uint8 * bmp_img = malloc(size);</span><br><span class="line">        if(!bmp_img)&#123;</span><br><span class="line">            debugf(&quot;%s: malloc for splash image failed!\n&quot;,__FUNCTION__);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!_boot_partition_read(dev, L&quot;logo&quot;, 0, size, bmp_img))</span><br><span class="line">        &#123;</span><br><span class="line">                debugf(&quot;%s: read logo partition failed!\n&quot;,__FUNCTION__);</span><br><span class="line">                goto end;</span><br><span class="line">        &#125;</span><br><span class="line">        lcd_display_logo(backlight_set,(ulong)bmp_img,size);</span><br><span class="line">end:</span><br><span class="line">        free(bmp_img);</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lcd_display_logo<br>因为是bmp格式图片，需要调用 lcd_display_bitmap 进行格式转换后才能在lcd上显示；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void lcd_display_logo(int backlight_set,ulong bmp_img,size_t size)</span><br><span class="line">&#123;</span><br><span class="line">#define mdelay(t)     (&#123;unsigned long msec=(t); while (msec--) &#123; udelay(1000);&#125;&#125;)</span><br><span class="line">    if(backlight_set == BACKLIGHT_ON)&#123;</span><br><span class="line">        lcd_display_bitmap((ulong)bmp_img, 0, 0);</span><br><span class="line">        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);</span><br><span class="line">        lcd_display();</span><br><span class="line">        mdelay(50);</span><br><span class="line">        set_backlight(255);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);</span><br><span class="line">        lcd_display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lcd_display<br>参考前面的内容，refresh函数指针等同于<code>sprdfb_dispc_refresh</code>，定义在 <code>drivers/video/sprdfb_dispc.c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c</span><br><span class="line">void lcd_display(void)</span><br><span class="line">&#123;</span><br><span class="line">    real_refresh(&amp;s_sprdfb_dev);</span><br><span class="line">&#125;</span><br><span class="line">static int real_refresh(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    dev-&gt;ctrl-&gt;refresh(dev);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sprdfb_dispc_refresh<br>这里针对mipi lcd模组，可以简单理解为cmd mode和video mode不同方式刷新显示，这里不再详细分析操作寄存器的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb_dispc.c</span><br><span class="line">static int32_t sprdfb_dispc_refresh (struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    if(SPRDFB_PANEL_IF_DPI == dev-&gt;panel_if_type) &#123;    //cmd mode</span><br><span class="line">        dispc_set_bits((1&lt;&lt;5), DISPC_DPI_CTRL);</span><br><span class="line">        if(is_first_frame)&#123;</span><br><span class="line">            udelay(30);</span><br><span class="line">            dispc_clear_bits((1&lt;&lt;4), DISPC_DPI_CTRL);</span><br><span class="line">            dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);</span><br><span class="line">            is_first_frame = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;    //video mode</span><br><span class="line">        dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);</span><br><span class="line">        ...</span><br><span class="line">        dispc_set_bits((1&lt;&lt;0), DISPC_INT_CLR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>至此，uboot lcd的初始化和刷新显示已经分析完成了。</p>
<h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><p>lcd 相关代码如下图：<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd.png" alt="sprdfb kernel code"></p>
<p>和 uboot 代码架构基本相似，下面以 <code>lcd_nt35516_mipi.c</code>为例进行分析</p>
<h2 id="lcd模组配置"><a href="#lcd模组配置" class="headerlink" title="lcd模组配置"></a>lcd模组配置</h2><p>驱动文件放置路径:  <code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code></p>
<ul>
<li><p>drivers/video/sprdfb/lcd/Makefile<br>包含编译该屏驱动的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_FB_LCD_NT35516_MIPI)  += lcd_nt35516_mipi.o=</span><br></pre></td></tr></table></figure>
</li>
<li><p>drivers/video/sprdfb/Kconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config FB_LCD_NT35516_MIPI</span><br><span class="line">        boolean &quot;support NT35516 mipi panel&quot;</span><br><span class="line">        depends on FB_SC8825 || FB_SCX35 || FB_SCX30G</span><br><span class="line">        default n</span><br></pre></td></tr></table></figure>
</li>
<li><p>arch/arm/configs/sp7731gea-dt_defconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FB_LCD_NT35516_MIPI=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c<br>这个文件配置了该模组的基本信息和操作方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">	.panel_init = nt35516_mipi_init,</span><br><span class="line">	.panel_readid = nt35516_readid,</span><br><span class="line">	.panel_enter_sleep = nt35516_enter_sleep,</span><br><span class="line">	.panel_esd_check = nt35516_check_esd,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">	.hfp = 20,  /* unit: pixel */</span><br><span class="line">	.hbp = 20,</span><br><span class="line">	.hsync = 20,//4,</span><br><span class="line">	.vfp = 10, /*unit: line*/</span><br><span class="line">	.vbp = 10,</span><br><span class="line">	.vsync = 6,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">	.work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">	.video_bus_width = 24, /*18,16*/</span><br><span class="line">	.lan_number = 3,</span><br><span class="line">	.phy_feq = 500*1000,</span><br><span class="line">	.h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">	.v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">	.de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">	.te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">	.color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">	.shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">	.timing = &amp;lcd_nt35516_mipi_timing,</span><br><span class="line">	.ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">.display_width = 480,</span><br><span class="line">.display_height = 854,</span><br><span class="line">#endif</span><br><span class="line">	.width = 540,</span><br><span class="line">	.height = 960,</span><br><span class="line">	.fps = 60,</span><br><span class="line">	.type = LCD_MODE_DSI,</span><br><span class="line">	.direction = LCD_DIRECT_NORMAL,</span><br><span class="line">	.is_clean_lcd = true,</span><br><span class="line">	.info = &#123;</span><br><span class="line">		.mipi = &amp;lcd_nt35516_mipi_info</span><br><span class="line">	&#125;,</span><br><span class="line">	.ops = &amp;lcd_nt35516_mipi_operations,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct panel_cfg lcd_nt35516_mipi = &#123;</span><br><span class="line">	/* this panel can only be main lcd */</span><br><span class="line">	.dev_id = SPRDFB_MAINLCD_ID,</span><br><span class="line">	.lcd_id = 0x16,</span><br><span class="line">	.lcd_name = &quot;lcd_nt35516_mipi&quot;,</span><br><span class="line">	.panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init lcd_nt35516_mipi_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	return sprdfb_panel_register(&amp;lcd_nt35516_mipi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(lcd_nt35516_mipi_init);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>subsys_initcall</strong> 是一个内核中的一个宏，定义特殊的init段，在内核启动过程中会依次调用这些函数，基本和<strong>module_init</strong>类似，但优先级更高。</p>
<p><strong>sprdfb_panel_register</strong> 定义在 <code>drivers/video/sprdfb/sprdfb_panel.c</code>，会把该模组对应的 panel_cfg 添加到维护的全局链表<code>panel_list_main</code> 中。</p>
<h2 id="lcd-模组初始化流程-1"><a href="#lcd-模组初始化流程-1" class="headerlink" title="lcd 模组初始化流程"></a>lcd 模组初始化流程</h2><ul>
<li><p>arch/arm/configs/sp7731gea-native_defconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MACH_SP7731GEA=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>arch/arm/boot/dts/Makefile </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch/arm/boot/dts/sprd-scx35_sp7731gea.dts</span><br><span class="line">226:dtb-$(CONFIG_MACH_SP7731GEA) += sprd-scx35_sp7731gea.dtb</span><br><span class="line">227:dtb-$(CONFIG_MACH_SP7731GEA_LM) += sprd-scx35_sp7731gea_lm.dtb</span><br><span class="line">228:dtb-$(CONFIG_MACH_SP7731GEA_FWVGA) += sprd-scx35_sp7731gea_fwvga.dtb</span><br><span class="line">229:dtb-$(CONFIG_MACH_SP7731GEAOPENPHONE) += sprd-scx35_sp7731geaopenphone.dtb</span><br></pre></td></tr></table></figure>
</li>
<li><p>sprd-scx35_sp7731gea.dts<br>其中lcd controller配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">	serial0 = &amp;uart0;</span><br><span class="line">	serial1 = &amp;uart1;</span><br><span class="line">	serial2 = &amp;uart2;</span><br><span class="line">	serial3 = &amp;uart3;</span><br><span class="line">	i2c0 = &amp;i2c0;</span><br><span class="line">	i2c1 = &amp;i2c1;</span><br><span class="line">	i2c2 = &amp;i2c2;</span><br><span class="line">	i2c3 = &amp;i2c3;</span><br><span class="line">	lcd0 = &amp;fb0;</span><br><span class="line">	spi0 = &amp;spi0;</span><br><span class="line">	spi1 = &amp;spi1;</span><br><span class="line">	spi2 = &amp;spi2;</span><br><span class="line">	hwspinlock0 = &amp;hwspinlock0;</span><br><span class="line">	hwspinlock1 = &amp;hwspinlock1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fb0: fb@20800000 &#123;</span><br><span class="line">	compatible = &quot;sprd,sprdfb&quot;;</span><br><span class="line">	reg = &lt;0xf5122000 0x1000&gt;,&lt;0xf5146000 0x1000&gt;;</span><br><span class="line">	interrupts = &lt;0 46 0x0&gt;,&lt;0 48 0x0&gt;, &lt;0 49 0x0&gt;;</span><br><span class="line">	clock-names = &quot;dispc_clk_parent&quot;, &quot;dispc_dbi_clk_parent&quot;, &quot;dispc_dpi_clk_parent&quot;, &quot;dispc_emc_clk_parent&quot;, &quot;dispc_clk&quot;, &quot;dispc_dbi_clk&quot;, &quot;dispc_dpi_clk&quot;, &quot;dispc_emc_clk&quot;, &quot;fb_spi_clock&quot;, &quot;fb_spi_clock_parent&quot;;</span><br><span class="line">	clocks = &lt;&amp;clk_256m&gt;, &lt;&amp;clk_256m&gt;, &lt;&amp;clk_384m&gt;, &lt;&amp;clk_aon_apb&gt;, &lt;&amp;clk_dispc0&gt;, &lt;&amp;clk_dispc0_dbi&gt;, &lt;&amp;clk_dispc0_dpi&gt;, &lt;&amp;clk_disp_emc&gt;, &lt;&amp;clk_spi2&gt;, &lt;&amp;ext_26m&gt;;</span><br><span class="line">	clock-src = &lt;256000000 256000000 384000000&gt;;</span><br><span class="line">	dpi_clk_div = &lt;7&gt;;</span><br><span class="line">	sprd,fb_use_reservemem;</span><br><span class="line">	sprd,fb_mem = &lt;0x9F311000 0x5EF000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>drivers/video/sprdfb/sprdfb_main.c<br>与之相匹配的lcd控制器驱动位于 <code>drivers/video/sprdfb/sprdfb_main.c</code>，当设备节点device_node被解析为platform_device注册到系统时，会和这个驱动进行匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_OF</span><br><span class="line">static const struct of_device_id sprdfb_dt_ids[] = &#123;</span><br><span class="line">        &#123; .compatible = &quot;sprd,sprdfb&quot;, &#125;,</span><br><span class="line">        &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line">static struct platform_driver sprdfb_driver = &#123;</span><br><span class="line">        .probe = sprdfb_probe,</span><br><span class="line">#ifndef CONFIG_HAS_EARLYSUSPEND</span><br><span class="line">        .suspend = sprdfb_suspend,</span><br><span class="line">        .resume = sprdfb_resume,</span><br><span class="line">#endif</span><br><span class="line">        .remove = sprdfb_remove,</span><br><span class="line">        .driver = &#123;</span><br><span class="line">                .name = &quot;sprd_fb&quot;,</span><br><span class="line">                .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">                .of_match_table = of_match_ptr(sprdfb_dt_ids),</span><br><span class="line">#endif</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">static int __init sprdfb_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        return platform_driver_register(&amp;sprdfb_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>驱动加载流程大致如下图：<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd_init.png" alt="sprd kernel lcd probe"></p>
<p><strong>sprdfb_probe</strong> 函数的定义如下，简单分析下代码流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static int sprdfb_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct fb_info *fb = NULL;</span><br><span class="line">    struct sprdfb_device *dev = NULL;</span><br><span class="line">    struct resource r;</span><br><span class="line"></span><br><span class="line">    fb = framebuffer_alloc(sizeof(struct sprdfb_device), &amp;pdev-&gt;dev);    //(1)分布帧缓冲使用空间</span><br><span class="line">    dev = fb-&gt;par;</span><br><span class="line">    dev-&gt;fb = fb;</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">    dev-&gt;of_dev = &amp;(pdev-&gt;dev);</span><br><span class="line">    dev-&gt;dev_id = of_alias_get_id(pdev-&gt;dev.of_node, &quot;lcd&quot;);    //(2)读取设备树中lcd id</span><br><span class="line">    printk(&quot;sprdfb: [%s] id = %d\n&quot;, __FUNCTION__, dev-&gt;dev_id);</span><br><span class="line">#else</span><br><span class="line">    dev-&gt;dev_id = pdev-&gt;id;</span><br><span class="line">#endif</span><br><span class="line">    switch(SPRDFB_IN_DATA_TYPE)&#123;</span><br><span class="line">    case SPRD_IN_DATA_TYPE_ABGR888:</span><br><span class="line">        dev-&gt;bpp = 32;</span><br><span class="line">        break;</span><br><span class="line">    case SPRD_IN_DATA_TYPE_BGR565:</span><br><span class="line">        dev-&gt;bpp = 16;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        dev-&gt;bpp = 32;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(SPRDFB_MAINLCD_ID == dev-&gt;dev_id)&#123;    //确认是主屏显示</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(3) </span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">        if(0 != of_address_to_resource(pdev-&gt;dev.of_node, 0, &amp;r))&#123;    //(4)</span><br><span class="line">            printk(KERN_ERR &quot;sprdfb: sprdfb_probe fail. (can&apos;t get register base address)\n&quot;);</span><br><span class="line">            goto err0;</span><br><span class="line">        &#125;</span><br><span class="line">        g_dispc_base_addr = r.start;</span><br><span class="line">        printk(&quot;sprdfb: set g_dispc_base_addr = 0x%x\n&quot;, g_dispc_base_addr);</span><br><span class="line">#endif</span><br><span class="line">    dev-&gt;logo_buffer_addr_v = 0;</span><br><span class="line">    if(sprdfb_panel_get(dev))&#123;    //(5) </span><br><span class="line">        dev-&gt;panel_ready = true;</span><br><span class="line">        dev-&gt;ctrl-&gt;logo_proc(dev);  //(6)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dev-&gt;panel_ready = false;</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;ctrl-&gt;early_init(dev); //(7)</span><br><span class="line">    if(!dev-&gt;panel_ready)&#123;</span><br><span class="line">        if (!sprdfb_panel_probe(dev)) &#123;</span><br><span class="line">            ret = -EIO;</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = setup_fb_mem(dev, pdev);  //(8)</span><br><span class="line">    setup_fb_info(dev); //(9)</span><br><span class="line">    /* register framebuffer device */</span><br><span class="line">    ret = register_framebuffer(fb); //(10)</span><br><span class="line">    platform_set_drvdata(pdev, dev);</span><br><span class="line">    sprdfb_create_sysfs(dev);</span><br><span class="line">    dev-&gt;ctrl-&gt;init(dev);   //(11)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>(1) 为lcd控制器分配 framebuffer 结构体 fb_info；</p>
</li>
<li><p>(2) 读取设备树中lcd id，从前面设备树的信息lcd0来看，id = 0；</p>
</li>
<li><p>(3) <code>sprdfb_dispc_ctrl</code> 保存为Soc显示控制器的操作接口；</p>
</li>
<li><p>(4) 获取设备树中配置的寄存器地址信息。</p>
</li>
<li><p>(5) <code>sprdfb_panel_get</code> 会调用<code>adapt_panel_from_uboot</code>遍历模组链表 <code>panel_list_main</code> 中 panel_cfg，将lcd_id 和 uboot中读取的模组芯片id进行对比，如果匹配则返回对应的panel_cfg；如果没有匹配，会再后续的流程中调用<code>sprdfb_panel_probe</code>重新加载模组驱动。这期间会设置 <strong>DISPC</strong> 的dsi硬件配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct panel_spec *adapt_panel_from_readid(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct panel_cfg *cfg;</span><br><span class="line">    struct list_head *panel_list;</span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(6) <code>sprdfb_dispc_logo_proc</code> 按照panel_cfg的尺寸申请缓存区，并从uboot lcd_base中拷贝logo数据；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void sprdfb_dispc_logo_proc(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t kernel_fb_size = 0;</span><br><span class="line">	uint32_t logo_src_v = 0;</span><br><span class="line">	uint32_t logo_dst_v = 0;//use the second frame buffer	,virtual</span><br><span class="line">	uint32_t logo_dst_p = 0;//use the second frame buffer ,physical</span><br><span class="line">	uint32_t logo_size = 0;// should be rgb565</span><br><span class="line"></span><br><span class="line">	if(dev == NULL) &#123;</span><br><span class="line">		printk(&quot;sprdfb: %s[%d]: dev == NULL, return without process logo!!\n&quot;,__func__,__LINE__);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(lcd_base_from_uboot == 0) &#123;</span><br><span class="line">		printk(&quot;sprdfb: %s[%d]: lcd_base_from_uboot == 0, return without process logo!!\n&quot;,__func__,__LINE__);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(SPRDFB_PANEL_IF_DPI != dev-&gt;panel_if_type)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    logo_size = dev-&gt;panel-&gt;width * dev-&gt;panel-&gt;height * 2;// should be rgb565</span><br><span class="line"></span><br><span class="line">	dev-&gt;logo_buffer_size = logo_size;</span><br><span class="line">	dev-&gt;logo_buffer_addr_v = __get_free_pages(GFP_ATOMIC | __GFP_ZERO , get_order(logo_size));</span><br><span class="line"></span><br><span class="line">	logo_dst_v = dev-&gt;logo_buffer_addr_v;</span><br><span class="line">	logo_dst_p = __pa(dev-&gt;logo_buffer_addr_v);</span><br><span class="line"></span><br><span class="line">    logo_src_v =  (uint32_t)ioremap(lcd_base_from_uboot, logo_size);</span><br><span class="line"></span><br><span class="line">	memcpy(logo_dst_v, logo_src_v, logo_size);</span><br><span class="line">	dma_sync_single_for_device(dev, logo_dst_p, logo_size, DMA_TO_DEVICE);</span><br><span class="line"></span><br><span class="line">	iounmap(logo_src_v);</span><br><span class="line">    </span><br><span class="line">	dispc_write(logo_dst_p, DISPC_OSD_BASE_ADDR);</span><br><span class="line">	sprdfb_dispc_refresh_logo(dev);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int32_t sprdfb_dispc_refresh_logo (struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	dispc_clear_bits(0x1f, DISPC_INT_EN);//disable all interrupt</span><br><span class="line">	dispc_set_bits(0x1f, DISPC_INT_CLR);// clear all interruption</span><br><span class="line">	dispc_set_bits(BIT(5), DISPC_DPI_CTRL);//update</span><br><span class="line"></span><br><span class="line">//wait for update- done interruption</span><br><span class="line">	for(i=0; i&lt;500; i++) &#123;</span><br><span class="line">		if(!(dispc_read(DISPC_INT_RAW) &amp; (0x10)))&#123;</span><br><span class="line">			udelay(1000);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    if(i &gt;= 500) &#123;</span><br><span class="line">        printk(&quot;sprdfb: [%s] wait dispc done int time out!! (0x%x)\n&quot;, __func__, dispc_read(DISPC_INT_RAW));</span><br><span class="line">    &#125;</span><br><span class="line">	dispc_set_bits((1&lt;&lt;5), DISPC_INT_CLR);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(7) sprdfb_dispc_early_init 恢复使能 <strong>DISPC</strong> 模组；</p>
</li>
<li><p>(8) setup_fb_mem 解析设备树“sprd,fb_mem”配置 fb_info screen_base等参数</p>
</li>
<li><p>(9) setup_fb_info 进一步配置 fb_info，设置固定参数和可变参数；   </p>
</li>
<li><p>(10) register_framebuffer 向内核注册帧缓冲区；</p>
</li>
<li><p>(11) sprdfb_dispc_init 设置 <strong>DISPC</strong> 的dithering 和 osd layer blending功能。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>针对lcd驱动调试的一些总结：</p>
<ul>
<li>背光不亮</li>
</ul>
<blockquote>
<p>通常直接排查硬件，检查背光电压，pwm波形输出等</p>
</blockquote>
<ul>
<li>白屏显示</li>
</ul>
<blockquote>
<p>1.优先检查电压，一般液晶模组在完成初始化后，VGH/VGL经过charge pump，基本能够达到正负15v左右。</p>
</blockquote>
<blockquote>
<p>2.读取模组id，优先检查硬件接口是否有误，然后排查软件接口的设置，可通过示波器辅助快速定位。</p>
</blockquote>
<blockquote>
<p>3.检查是否初始化代码有误，存在模组代码不匹配的情况。</p>
</blockquote>
<ul>
<li>显示异常</li>
</ul>
<blockquote>
<p>1.优先排查硬件，曾经有遇到过BB的VDD输出2.8V，DVDD输出1.8v，但是模组内部将VDD/DVDD相连，直接导致初始化升压不够，显示异常。</p>
</blockquote>
<blockquote>
<p>2.检查分辨率、像素、时序配置和proch设定是否存在问题。</p>
</blockquote>
<blockquote>
<p>3.画面撕裂问题，一般需要开启TE，BB会在每帧数据开始前发送信号同步。</p>
</blockquote>
<blockquote>
<p>4.画面翻转问题，一般修改模组初始化代码，修改显示刷新方向解决。</p>
</blockquote>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://tinylaker.github.io/2019/09/30/terminal-for-microcontrol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tinylaker">
      <meta itemprop="description" content="个人学习总结">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tinylaker blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/terminal-for-microcontrol/" class="post-title-link" itemprop="url">terminal for microcontrol</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 16:05:40" itemprop="dateCreated datePublished" datetime="2019-09-30T16:05:40+08:00">2019-09-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-06 15:34:16" itemprop="dateModified" datetime="2019-10-06T15:34:16+08:00">2019-10-06</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方库/" itemprop="url" rel="index"><span itemprop="name">第三方库</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>此前的嵌入式项目开发过程中，因为硬件资源紧张，硬件工程师在进行原理图设计的时候没有使用芯片的串口，导致软件开发和调试极为困难。后来考虑使用USB CDC虚拟串口搭配命令行控制台进行调试，在gayhub上发现了这个开源的命令行控制项目 <a href="git@github.com:JingoC/terminal.git">Terminal</a></p>
<h1 id="Terminal简介"><a href="#Terminal简介" class="headerlink" title="Terminal简介"></a>Terminal简介</h1><p><code>Terminal</code> 支持跨平台、可选配置、日志命令、指令中断、回车和删除等常用按键配置，最大耗费系统内存不到10KB。</p>
<p>代码的目录结构如下，</p>
<ul>
<li><code>lib</code> 中包含自定义的字符串和队列操作。</li>
<li><code>module</code> 中包含对input解析和log的相关操作。</li>
<li><code>terminal.h</code> 和 <code>terminal.c</code> 实现了命令行控制台的基本功能，包括初始化、命令添加、命令执行、命令解析等API，供用户直接使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terminal # ls </span><br><span class="line">LICENSE    README.md  def_config examples   lib        module     terminal.c terminal.h</span><br><span class="line">terminal # ls def_config</span><br><span class="line">terminal_config.h</span><br><span class="line">terminal # ls lib</span><br><span class="line">cli_queue.c  cli_queue.h  cli_string.c cli_string.h</span><br><span class="line">terminal #</span><br><span class="line">terminal # ls module</span><br><span class="line">cli_input.c cli_input.h cli_log.c   cli_log.h   cli_time.c  cli_time.h</span><br></pre></td></tr></table></figure>

<h1 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h1><p>参考 <code>examples/Coocox_stm32f4</code>的工程代码和<code>README.md</code>，对当前工程添加自定义配置文件 <code>terminal_config.h</code>。</p>
<ul>
<li>使能 <code>TERM_TX_RX_EN</code> 开启输入输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TERM_TX_RX_EN  (1)    // Terminal Printf (without this don,t work)</span><br></pre></td></tr></table></figure>

<ul>
<li>复写 <code>CLI_Printf</code> 和 <code>CLI_PutChar</code> 输出函数，实现输出重定向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#if (TERM_TX_RX_EN == 1)</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define COM_Printf(...)     printf(__VA_ARGS__)</span><br><span class="line">#define CLI_Printf          COM_Printf</span><br><span class="line">#if (ECHO_EN == 1)</span><br><span class="line">#define CLI_PutChar     putchar</span><br><span class="line">#else   // ECHO_EN != 1</span><br><span class="line">#define CLI_PutChar</span><br><span class="line">#endif  // ECHO_EN == 1</span><br><span class="line"></span><br><span class="line">#else   // TERM_TX_RX_EN != 1</span><br><span class="line">#define CLI_Printf</span><br><span class="line">#define CLI_PutChar</span><br><span class="line">#endif  // TERM_TX_RX_EN == 1</span><br></pre></td></tr></table></figure>

<ul>
<li>设置基本参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define TERM_SIZE_TASK        (20)    // Max number of commands</span><br><span class="line">#define TERM_CMD_BUF_SIZE     (60)    // Max number of character buffer string command</span><br><span class="line">#define TERM_CMD_LOG_SIZE     (10)    // Max number of loging command</span><br><span class="line">#define TERM_ARGS_BUF_SIZE    (10)    // Max number of arguments in one command</span><br><span class="line">#define TERM_ARG_SIZE         (15)    // Max number character of one arguments</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>另外可以使用 <code>CLI_AddCmd</code> 接口添加自定义命令，<code>CLI_GetArg</code>接口获取参数，参考<code>my_test_commands</code>目录下的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static uint8_t _t1_cmd();</span><br><span class="line">static uint8_t _t2_cmd();</span><br><span class="line"></span><br><span class="line">void MyTestCmds_Init()</span><br><span class="line">&#123;</span><br><span class="line">    CLI_AddCmd(&quot;t1&quot;, _t1_cmd, 1, TMC_PrintStartTime | TMC_PrintStopTime, &quot;t1 - description command&quot;);</span><br><span class="line">    CLI_AddCmd(&quot;t2&quot;, _t2_cmd, 0, TMC_PrintDiffTime, &quot;t2 - description command&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ***************** implementation commands ****************</span><br><span class="line"></span><br><span class="line">uint8_t _t1_cmd()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t a = 0x01;</span><br><span class="line">    uint32_t b = 0x10;</span><br><span class="line">    uint32_t c = 7;</span><br><span class="line"></span><br><span class="line">    // be sure arguments</span><br><span class="line">    c = CLI_GetArgDec(0);</span><br><span class="line"></span><br><span class="line">    // optional arguments</span><br><span class="line">    CLI_GetArgHexByFlag(&quot;-a&quot;, &amp;a);</span><br><span class="line">    CLI_GetArgHexByFlag(&quot;-b&quot;, &amp;b);</span><br><span class="line"></span><br><span class="line">    CLI_Printf(&quot;\r\na: 0x%08X\r\nb: 0x%08X\r\nc: %d&quot;, (int) a, (int) b, (int) c);</span><br><span class="line"></span><br><span class="line">    return TE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t _t2_cmd()</span><br><span class="line">&#123;</span><br><span class="line">    CLI_Printf(&quot;\r\nPress ESC&quot;);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        CLI_CheckAbort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>已经移植好的固件，在PC上枚举出虚拟串口，使用minicom打开对应串口设备，能够看到如下的相关打印信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ minicom -D /dev/tty.usbmodem3079385933364</span><br><span class="line"></span><br><span class="line">Welcome to minicom 2.7.1</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">Compiled on Aug 20 2018, 10:22:42.</span><br><span class="line">Port /dev/tty.usbmodem3079385933364, 11:38:42</span><br><span class="line"></span><br><span class="line">Press Meta-Z for help on special keys</span><br><span class="line"></span><br><span class="line">****************************************************</span><br><span class="line">|                                                  |</span><br><span class="line">|                   Terminal v1.4                  |</span><br><span class="line">|           sw ver.: Sep 10 2018 22:13:54          |</span><br><span class="line">|                                                  |</span><br><span class="line">****************************************************</span><br><span class="line"></span><br><span class="line">Count base command: 4</span><br><span class="line">Max command: 20</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; help</span><br><span class="line">Count command: 4</span><br><span class="line">[] - mandatory argument</span><br><span class="line">&lt;&gt; - optional argument</span><br><span class="line">| - choice between arguments</span><br><span class="line">~          - reset cpu</span><br><span class="line">settime    - set current time</span><br><span class="line">        settime [h] [m] [s]</span><br><span class="line">gettime    - print current time</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://tinylaker.github.io/2019/09/16/libusb的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tinylaker">
      <meta itemprop="description" content="个人学习总结">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tinylaker blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/16/libusb的使用/" class="post-title-link" itemprop="url">libusb的使用</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-16 19:53:55" itemprop="dateCreated datePublished" datetime="2019-09-16T19:53:55+08:00">2019-09-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-29 22:54:28" itemprop="dateModified" datetime="2019-09-29T22:54:28+08:00">2019-09-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方库/" itemprop="url" rel="index"><span itemprop="name">第三方库</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文仅从libusb api-1.0版本的使用方面解读，不详细介绍usb的基本知识和传输协议。</p>
<h1 id="libusb简介"><a href="#libusb简介" class="headerlink" title="libusb简介"></a>libusb简介</h1><p><strong>libusb</strong> 是一个用来访问usb设备的应用库，可以跨平台使用，支持Linux、Mac、Windows等主流操作系统，当然Andorid上也有libusb身影。</p>
<p>libusb相关网站：</p>
<p><strong>github</strong>: <a href="https://github.com/libusb/libusb" target="_blank" rel="noopener">https://github.com/libusb/libusb</a></p>
<p><strong>homepage</strong>: <a href="https://libusb.info/" target="_blank" rel="noopener">https://libusb.info/</a></p>
<p><strong>api-1.0</strong>: <a href="http://libusb.sourceforge.net/api-1.0/" target="_blank" rel="noopener">http://libusb.sourceforge.net/api-1.0/</a> </p>
<p>当产品需要添加自定义协议时，以hid协议为例，usb的固件代码比较容易实现。与此同时，主机也需要对应的协议来正确解析，这里通常有2种实现方式，第一种是在主机编写usb设备驱动解析协议，另一种是应用通过libusb解析协议，显然后一种方法更通用。</p>
<h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>libusb_init</strong><br>必须最先被执行，完成libusb的初始化。libusb_context代表libusb的会话，如果参数为NULL，会默认创建一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_init(libusb_context** context);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_exit</strong><br>取消libusb初始化，通常在程序结束时调用。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_exit(struct libusb_context* ctx)</span><br></pre></td></tr></table></figure>

<h2 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h2><p><strong>libusb_open</strong><br>打开usb设备，获取设备句柄dev_handle。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_open(libusb_device *dev, libusb_device_handle **dev_handle);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_open_device_with_vid_pid</strong><br>方便快速打开对应pid/vid的设备，可以指定libusb会话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libusb_device_handle* libusb_open_device_with_vid_pid(libusb_context *ctx, </span><br><span class="line">    unit16_t vendor_id, uint16_t product_id);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_close</strong><br>指定设备句柄关闭设备，在程序完成前调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_close(libusb_device_handle *dev_handle);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_get_device_list</strong><br>获得系统当前所有的usb设备的列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t libusb_get_device_list（libusb_context *ctx, libusb_device ***list);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_free_device_list</strong><br>释放前面使用的设备列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void libusb_free_device_list(libusb_device **list, int unref_devices)</span><br></pre></td></tr></table></figure>

<p><strong>libusb_get_configuration</strong><br>获得当前设备的配置模式，usb设备可能包含多个配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int usb_get_configuration(libusb_device_handle *dev_handle, int *config);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_set_configuration</strong><br>重新设置usb设备的配置模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int usb_set_configuration(libusb_device_handle *dev_handle, int configuration);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_claim_interface</strong><br>获得usb设备对应接口的所有权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_claim_interface(libusb_device_handle *dev_handle, int interface_number);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_release_interface</strong><br>释放获取usb设备接口的所有权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_release_interface(libusb_device_handle *dev_handle, int interface_number);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_set_interface_alt_setting</strong><br>激活某个接口的交替配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_set_interface_alt_setting(libusb_device_handle *dev_handle, int interface_number, int alternate_config);</span><br></pre></td></tr></table></figure>

<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p><strong>libusb_control_transfer</strong><br>控制传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_control_transfer (libusb_device_handle *dev_handle, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, unsigned char *data, uint16_t wLength, unsigned int timeout);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_bulk_transfer</strong><br>批量传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_bulk_transfer (struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout);</span><br></pre></td></tr></table></figure>

<p><strong>libusb_interrupt_transfer</strong><br>中断传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int libusb_interrupt_transfer (struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout);</span><br></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面的例子，是打开vid = 1234， pid = 5678的usb设备，同时检查是否有接口0的驱动，如果有直接卸载这个驱动，并获取这个接口的所有权。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	libusb_context *ctx;</span><br><span class="line">	libusb_device_handle* handle = NULL;  /* handle for USB device */</span><br><span class="line"></span><br><span class="line">	/* Initialise libusb. */</span><br><span class="line">	ret = libusb_init(&amp;ctx);</span><br><span class="line">	if (ret != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;Error initialising libusb.\n&quot;);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* Open device with vid and pid */</span><br><span class="line">	handle = libusb_open_device_with_vid_pid(0, 1234, 5678);</span><br><span class="line">	if (!handle)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;Unable to open device.\n&quot;);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Check whether a kernel driver is attached to interface #0. If so, we&apos;ll</span><br><span class="line">	* need to detach it.</span><br><span class="line">	*/</span><br><span class="line">	if (libusb_kernel_driver_active(handle, 0)) &#123;</span><br><span class="line">		ret = libusb_detach_kernel_driver(handle, 0);</span><br><span class="line">		if (ret != 0) &#123;</span><br><span class="line">			fprintf(stderr, &quot;Error detaching kernel driver.\n&quot;);</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Claim interface #0. */</span><br><span class="line">	ret = libusb_claim_interface(handle, 0);</span><br><span class="line">	if (ret != 0) &#123;</span><br><span class="line">		fprintf(stderr, &quot;Error claiming interface.\n&quot;);</span><br><span class="line">	    return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://tinylaker.github.io/2019/09/15/cJSON的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tinylaker">
      <meta itemprop="description" content="个人学习总结">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tinylaker blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/15/cJSON的使用/" class="post-title-link" itemprop="url">cJSON的使用</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-15 01:41:47" itemprop="dateCreated datePublished" datetime="2019-09-15T01:41:47+08:00">2019-09-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-16 16:30:36" itemprop="dateModified" datetime="2019-09-16T16:30:36+08:00">2019-09-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方库/" itemprop="url" rel="index"><span itemprop="name">第三方库</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-JSON格式"><a href="#1-JSON格式" class="headerlink" title="1. JSON格式"></a>1. JSON格式</h1><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。同时也易于机器解析和生成。</p>
<p>JSON建构于两种结构：<br><strong>键值对的集合（A collection of name/value pairs）</strong><br><strong>值的有序列表（An ordered list of values）</strong></p>
<h1 id="2-cJSON"><a href="#2-cJSON" class="headerlink" title="2. cJSON"></a>2. cJSON</h1><p>c语言中处理json格式的数据，可以借助于cJSON函数库，简单且效率高。</p>
<p>cJSON的开源仓库地址： <a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="noopener">https://github.com/DaveGamble/cJSON</a></p>
<p>cJSON.h定义了结构体cJSON来描述JSON对象，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct cJSON</span><br><span class="line">&#123;</span><br><span class="line">    /* 对象或数组链表的前后节点 */</span><br><span class="line">    struct cJSON *next;</span><br><span class="line">    struct cJSON *prev;</span><br><span class="line">    /* 对象火数组链表的子节点 */</span><br><span class="line">    struct cJSON *child;</span><br><span class="line"></span><br><span class="line">    /* 键值的类型 */</span><br><span class="line">    int type;</span><br><span class="line"></span><br><span class="line">    /* 保存键值字符串 */</span><br><span class="line">    char *valuestring;</span><br><span class="line"></span><br><span class="line">    int valueint;</span><br><span class="line">    double valuedouble;</span><br><span class="line"></span><br><span class="line">    /* 保存键值的名字 */</span><br><span class="line">    char *string;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-cJSON-API"><a href="#2-1-cJSON-API" class="headerlink" title="2.1 cJSON API"></a>2.1 cJSON API</h2><h3 id="2-1-1-cJSON-Parse"><a href="#2-1-1-cJSON-Parse" class="headerlink" title="2.1.1 cJSON_Parse"></a>2.1.1 cJSON_Parse</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 解析JSON格式数据，按照cJSON结构进行序列化</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_Parse(const char *value)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-cJSON-Print"><a href="#2-1-2-cJSON-Print" class="headerlink" title="2.1.2 cJSON_Print"></a>2.1.2 cJSON_Print</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 解析cJSON格式数据，转换成JSON格式的字符串</span><br><span class="line"> * @ret: 成功返回指向内存块中JSON字符串的地址，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(char *) cJSON_Print(const cJSON *item)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-cJSON-Delete"><a href="#2-1-3-cJSON-Delete" class="headerlink" title="2.1.3 cJSON_Delete"></a>2.1.3 cJSON_Delete</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * @func: 删除释放cJSON及其子节点。</span><br><span class="line"> * @ret:</span><br><span class="line"> */</span><br><span class="line">(void) cJSON_Delete(cJSON *item)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-cJSON-CreateObject"><a href="#2-1-4-cJSON-CreateObject" class="headerlink" title="2.1.4 cJSON_CreateObject"></a>2.1.4 cJSON_CreateObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 创建新的cJSON对象</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_CreateObject(void)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-cJSON-GetObjectItem"><a href="#2-1-5-cJSON-GetObjectItem" class="headerlink" title="2.1.5 cJSON_GetObjectItem"></a>2.1.5 cJSON_GetObjectItem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @func: 获取JSON字符串字段值</span><br><span class="line"> * @ret: 成功返回指向内存块中cJSON的指针，失败返回NULL</span><br><span class="line"> */</span><br><span class="line">(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)</span><br></pre></td></tr></table></figure>

<h2 id="2-2-如何解析JSON格式"><a href="#2-2-如何解析JSON格式" class="headerlink" title="2.2 如何解析JSON格式"></a>2.2 如何解析JSON格式</h2><p>以github仓库README.md中JSON数据为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Awesome 4K&quot;,</span><br><span class="line">    &quot;resolutions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 1280,</span><br><span class="line">            &quot;height&quot;: 720</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 1920,</span><br><span class="line">            &quot;height&quot;: 1080</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;width&quot;: 3840,</span><br><span class="line">            &quot;height&quot;: 2160</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-转换JSON格式为cJSON"><a href="#2-2-1-转换JSON格式为cJSON" class="headerlink" title="2.2.1 转换JSON格式为cJSON"></a>2.2.1 转换JSON格式为cJSON</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cJSON *monitor_json = cJSON_Parse(monitor);</span><br><span class="line">if (monitor_json == NULL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-解析字符串数据"><a href="#2-2-2-解析字符串数据" class="headerlink" title="2.2.2 解析字符串数据"></a>2.2.2 解析字符串数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = cJSON_GetObjectItemCaseSensitive(monitor_json, &quot;name&quot;);</span><br><span class="line">if (cJSON_IsString(name) &amp;&amp; (name-&gt;valuestring != NULL))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-解析数组数据"><a href="#2-2-3-解析数组数据" class="headerlink" title="2.2.3 解析数组数据"></a>2.2.3 解析数组数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolutions = cJSON_GetObjectItemCaseSensitive(monitor_json, &quot;resolutions&quot;);</span><br><span class="line">cJSON_ArrayForEach(resolution, resolutions)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *width = cJSON_GetObjectItemCaseSensitive(resolution, &quot;width&quot;);</span><br><span class="line">    cJSON *height = cJSON_GetObjectItemCaseSensitive(resolution, &quot;height&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-释放内存"><a href="#2-2-4-释放内存" class="headerlink" title="2.2.4 释放内存"></a>2.2.4 释放内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_Delete(monitor_json);</span><br></pre></td></tr></table></figure>

<h2 id="2-3-如何生成JSON格式"><a href="#2-3-如何生成JSON格式" class="headerlink" title="2.3 如何生成JSON格式"></a>2.3 如何生成JSON格式</h2><h3 id="2-3-1-创建cJSON结构体"><a href="#2-3-1-创建cJSON结构体" class="headerlink" title="2.3.1 创建cJSON结构体"></a>2.3.1 创建cJSON结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON *monitor = cJSON_CreateObject();</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-添加字符串数据"><a href="#2-3-2-添加字符串数据" class="headerlink" title="2.3.2 添加字符串数据"></a>2.3.2 添加字符串数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON_AddStringToObject(monitor, &quot;name&quot;, &quot;Awesome 4K&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-添加数组数据"><a href="#2-3-3-添加数组数据" class="headerlink" title="2.3.3 添加数组数据"></a>2.3.3 添加数组数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resolutions = cJSON_AddArrayToObject(monitor, &quot;resolutions&quot;);</span><br><span class="line"></span><br><span class="line">for (index = 0; index &lt; (sizeof(resolution_numbers) / (2 * sizeof(int))); ++index)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *resolution = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line">    if (cJSON_AddNumberToObject(resolution, &quot;width&quot;, resolution_numbers[index][0]) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cJSON_AddNumberToObject(resolution, &quot;height&quot;, resolution_numbers[index][1]) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cJSON_AddItemToArray(resolutions, resolution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-格式化JSON数据"><a href="#2-3-4-格式化JSON数据" class="headerlink" title="2.3.4 格式化JSON数据"></a>2.3.4 格式化JSON数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *string = cJSON_Print(monitor);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-释放内存"><a href="#2-3-5-释放内存" class="headerlink" title="2.3.5 释放内存"></a>2.3.5 释放内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cJSON_free(string);</span><br><span class="line">cJSON_Delete(monitor);</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tinylaker</p>
  <div class="site-description" itemprop="description">个人学习总结</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/tinylaker" title="GitHub &rarr; https://github.com/tinylaker" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:xyxujinlong@163.com" title="E-Mail &rarr; mailto:xyxujinlong@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tinylaker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
