<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="Tinylaker blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。 本文基于Android 4.4代码分析sc7731 lcd的基本流程。 显示系统这里暂时以7710芯片手册为例，多媒体显示系统包含 LCDC 和 DISPC，其中 LCDC 仅支持 MCU 接口类型，支持 2 路显示；而 DISPC 同时支持 DBI 和 DPI 接口类型。   LCDC  支持最多6">
<meta name="keywords" content="lcd">
<meta property="og:type" content="article">
<meta property="og:title" content="sc7731 lcd流程分析">
<meta property="og:url" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/index.html">
<meta property="og:site_name" content="Tinylaker blog">
<meta property="og:description" content="本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。 本文基于Android 4.4代码分析sc7731 lcd的基本流程。 显示系统这里暂时以7710芯片手册为例，多媒体显示系统包含 LCDC 和 DISPC，其中 LCDC 仅支持 MCU 接口类型，支持 2 路显示；而 DISPC 同时支持 DBI 和 DPI 接口类型。   LCDC  支持最多6">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcdc_module.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcm_module.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/8080.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/DISPC.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sc7731_uboot_lcd.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprdfb_uboot_lcd_init.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd_init.png">
<meta property="og:updated_time" content="2019-11-10T13:48:32.208Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sc7731 lcd流程分析">
<meta name="twitter:description" content="本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。 本文基于Android 4.4代码分析sc7731 lcd的基本流程。 显示系统这里暂时以7710芯片手册为例，多媒体显示系统包含 LCDC 和 DISPC，其中 LCDC 仅支持 MCU 接口类型，支持 2 路显示；而 DISPC 同时支持 DBI 和 DPI 接口类型。   LCDC  支持最多6">
<meta name="twitter:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png">
  <link rel="canonical" href="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>sc7731 lcd流程分析 | Tinylaker blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ddfa4a6ba83ff65311f95d251f9389b3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tinylaker blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">stay hungry stay foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tinylaker">
      <meta itemprop="description" content="个人学习总结">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tinylaker blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">sc7731 lcd流程分析

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-09 19:34:45" itemprop="dateCreated datePublished" datetime="2019-11-09T19:34:45+08:00">2019-11-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 21:48:32" itemprop="dateModified" datetime="2019-11-10T21:48:32+08:00">2019-11-10</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。</p>
<p>本文基于Android 4.4代码分析sc7731 lcd的基本流程。</p>
<h1 id="显示系统"><a href="#显示系统" class="headerlink" title="显示系统"></a>显示系统</h1><p>这里暂时以7710芯片手册为例，多媒体显示系统包含 LCDC 和 DISPC，其中 LCDC 仅支持 MCU 接口类型，支持 2 路显示；而 DISPC 同时支持 DBI 和 DPI 接口类型。</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png" alt="lcd"></p>
<ul>
<li>LCDC</li>
</ul>
<p>支持最多6个图层的Alaha Blending，RGB888数据格式到RGB565/RGB666数据格式的Dithering等功能。</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcdc_module.png" alt="lcdc"></p>
<ul>
<li>LCM</li>
</ul>
<p>LCM接收AHB总线或者LCDC数据，并按照MCU接口格式按照固定的时序传输到显示模组上。<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_lcm_module.png" alt="lcm"></p>
<p>MCU支持8080和6080两种传输格式，两者的区别只是在读写控制上。</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/8080.png" alt="8080"></p>
<ul>
<li>DISPC</li>
</ul>
<p>这里可以看出2种路线，一种直接由LCDC DBI经由DISPC DBI输出；另一种直接由AXI Domain到DISPC DBI/DPI输出。所以如果使用MIPI接口显示模组，是不需要经过LCDC显示模块的，直接由DISPC模块控制。      </p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/DISPC.png" alt="DISPC"></p>
<h1 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h1><p>lcd相关源码位于 <code>drivers/video/sprdfb</code>，代码文件截图如下:</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sc7731_uboot_lcd.png" alt="uboot source code"></p>
<p>可以看到代码兼容了多款 Soc，Makefile 中也包含了多个平台的配置。</p>
<p>头文件 <code>include/configs/sp7731gea.h</code>，里面定义了 <code>CONFIG_SC8830</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SC8830</span><br><span class="line">#define CONFIG_DSIH_VERSION_1P21A</span><br><span class="line">#define CONFIG_FB_LCD_NT35516_MIPI</span><br></pre></td></tr></table></figure>

<p>这里值得一提的是7731和8830的AP相同，只是Modem存在差异，前者支持WCMDA，后者支持TD_SCMDA。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_SC8830)+= sprdfb_main.o sprdfb_panel.o sprdfb_dispc.o \</span><br><span class="line">    sprdfb_mcu.o sprdfb_rgb.o sprdfb_mipi.o \</span><br><span class="line">     sprdfb_i2c.o sprdfb_spi.o sprdfb_dsi.o \</span><br><span class="line">     sprdfb_chip_common.o sprdfb_chip_8830.o</span><br></pre></td></tr></table></figure>

<p>能够看出该平台的显示系统支持多种lcd接口，包括mcu、rgb、mipi、i2c、spi。</p>
<p>这里的mipi dsi有2个不同版本的IP核，参考头文件中的定义，这里使用的是dsi_1_21a中的代码。</p>
<p>下面以 <code>lcd_nt35516_mipi.c</code> 为例，分析 uboot lcd 的整个流程。</p>
<h2 id="lcd-模组配置"><a href="#lcd-模组配置" class="headerlink" title="lcd 模组配置"></a>lcd 模组配置</h2><ol>
<li><p><code>drivers/video/sprdfb/lcd/Makefile</code> 包含编译该屏驱动的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_FB_LCD_NT35516_MIPI) += lcd_nt35516_mipi.o</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>drivers/video/sprdfb/sprdfb_panel.c</code> 中包含该屏的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern struct panel_spec lcd_nt35516_mipi_spec;</span><br><span class="line">static struct panel_cfg panel_cfg[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">#ifdef CONFIG_FB_LCD_NT35516_MIPI </span><br><span class="line">    &#123; </span><br><span class="line">        .lcd_id = 0x16, </span><br><span class="line">        .panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">    &#125;,</span><br><span class="line"> #endif</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code> 中详细描述了该模组的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">        //.cap = PANEL_CAP_NOT_TEAR_SYNC,</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">        .display_width = 480,</span><br><span class="line">        .display_height= 854,</span><br><span class="line">#endif</span><br><span class="line">        .width = 540,</span><br><span class="line">        .height = 960,</span><br><span class="line">        .fps = 60,</span><br><span class="line">        .type = LCD_MODE_DSI,</span><br><span class="line">        .direction = LCD_DIRECT_NORMAL,</span><br><span class="line">        .info = &#123;</span><br><span class="line">                .mipi = &amp;lcd_nt35516_mipi_info    //(1) mipi lcd模组的常规配置</span><br><span class="line">        &#125;,</span><br><span class="line">        .ops = &amp;lcd_nt35516_mipi_operations,    //(2) mipi lcd的操作集合</span><br><span class="line">&#125;;</span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">        .work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">        .video_bus_width = 24, /*18,16*/</span><br><span class="line">        .lan_number = 3,</span><br><span class="line">        .phy_feq = 500*1000,</span><br><span class="line">        .h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .timing = &amp;lcd_nt35516_mipi_timing,    //(3) mipi lcd的时序proch配置</span><br><span class="line">        .ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">        .panel_init = nt35516_mipi_init,    //包含mipi屏大量初始化代码</span><br><span class="line">        .panel_readid = nt35516_readid,    //mipi屏的读取id操作</span><br><span class="line">&#125;;</span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">        .hfp = 20,  /* unit: pixel */</span><br><span class="line">        .hbp = 20,</span><br><span class="line">        .hsync = 20,//4,</span><br><span class="line">        .vfp = 10, /*unit: line*/</span><br><span class="line">        .vbp = 10,</span><br><span class="line">        .vsync = 6,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="lcd-模组初始化流程"><a href="#lcd-模组初始化流程" class="headerlink" title="lcd 模组初始化流程"></a>lcd 模组初始化流程</h2><p>系统上电执行芯片 <strong>RomCode</strong>，完成 DDR 和外部存储器等常用外设的初始化；</p>
<p>之后读取外部存储器中的 uboot 并跳转执行，优先完成板级初始化 <code>board_init_f</code> 和 <code>board_init_r</code>，其中 <code>board_init_r</code> 中调用了<code>stdio_init</code>。代码流程图如下：</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprdfb_uboot_lcd_init.png" alt="sprdfb_lcd_init"></p>
<p>我们把重点聚焦在 sprdfb_probe 的实现上，下面剔除了部分无关代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c  </span><br><span class="line"></span><br><span class="line">static int sprdfb_probe(void * lcdbase)</span><br><span class="line">&#123;</span><br><span class="line">        struct sprdfb_device *dev = &amp;s_sprdfb_dev;</span><br><span class="line">        set_backlight(0);    //(1)</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(2) </span><br><span class="line">        dev-&gt;ctrl-&gt;early_init(dev);    //(3)</span><br><span class="line">        if (0 != sprdfb_panel_probe(dev)) &#123;    //(4)</span><br><span class="line">                sprdfb_panel_remove(dev);</span><br><span class="line">                dev-&gt;ctrl-&gt;uninit(dev);</span><br><span class="line">                printf(&quot;sprdfb: failed to probe\n&quot;);</span><br><span class="line">                return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        dev-&gt;smem_start = ((uint32_t)lcdbase);</span><br><span class="line">        dev-&gt;ctrl-&gt;init(dev);    //(5)</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>(1) 关闭pwm控制</li>
<li>(2) 获取display controller的接口，定义在 <code>sprdfb_dispc.c</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_dispc.c</span><br><span class="line"></span><br><span class="line">struct display_ctrl sprdfb_dispc_ctrl = &#123;</span><br><span class="line">        .name           = &quot;dispc&quot;,</span><br><span class="line">        .early_init             = sprdfb_dispc_early_init,</span><br><span class="line">        .init                   = sprdfb_dispc_init,</span><br><span class="line">        .uninit         = sprdfb_dispc_uninit,</span><br><span class="line">        .refresh                = sprdfb_dispc_refresh,</span><br><span class="line">        .update_clk     = dispc_update_clock,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>(3) 调用<code>sprdfb_dispc_early_init</code>，配置相关的clk，使能<code>dispc module</code></li>
<li>(4) <code>sprdfb_panel_probe</code> 会读取和保存 lcd 模组的 id，并对该模组完成初始化。</li>
<li>(5) <code>sprdfb_dispc_init</code> 会完成显示系统 dithering 和 osd layer 的设置。</li>
</ul>
<p>需要特别注意 uboot lcd 初始化流程中会保存 <strong>lcd_base</strong> 和 <strong>lcd_id</strong>，通过命令行参数传递，以供 kernel 阶段继续使用。</p>
<h2 id="lcd-刷新显示流程"><a href="#lcd-刷新显示流程" class="headerlink" title="lcd 刷新显示流程"></a>lcd 刷新显示流程</h2><p>看到这里读者可能会有疑问，uboot logo 是什么时候显示的呢？</p>
<p>下面开始分析lcd refresh流程，这里要从 <code>board_init_r</code> 中的<strong>do_cboot</strong>代码分析。</p>
<ol>
<li><p>normal_mode<br>代码定义了多种启动方式：normal、recovery、fastboot、charge、watchdog等，这里直接看normal_boot的代码。<br>首先初始化马达硬件，完成开机震动，然后调用 vlx_nand_boot，这里的代码取决有是 nand 方案还是 emmc 方案，这里假设是 emmc 启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ property/normal_mode.c</span><br><span class="line"></span><br><span class="line">void normal_mode(void) &#123;</span><br><span class="line">    vibrator_hw_init();</span><br><span class="line">    set_vibrator(1);</span><br><span class="line">#if BOOT_NATIVE_LINUX</span><br><span class="line">    vlx_nand_boot(BOOT_PART, CONFIG_BOOTARGS, BACKLIGHT_ON);</span><br><span class="line">#else</span><br><span class="line">    vlx_nand_boot(BOOT_PART, NULL, BACKLIGHT_ON);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>vlx_nand_boot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ property/normal_emc_mode.c</span><br><span class="line"></span><br><span class="line">void vlx_nand_boot(char * kernel_pname, char * cmdline, int backlight_set) &#123;</span><br><span class="line">    _boot_display_logo(dev, backlight_set);    //(1)</span><br><span class="line">    set_vibrator(FALSE);</span><br><span class="line">    _boot_load_kernel_ramdisk_image(dev, kernel_pname, hdr);</span><br><span class="line">    _boot_secure_check();</span><br><span class="line">    sipc_addr_reset();</span><br><span class="line">    vlx_entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>调用_boot_display_logo，读取logo分区图片内容，并调用lcd_display_logo，重点关注。</p>
</li>
<li><p>关闭马达;</p>
</li>
<li><p>从存储器读取kernel、ramdisk、dtb image，保存相关内存地址。</p>
</li>
<li><p>secure boot校验流程，根据产品定义，可能会对DSP、Modem、SIMLOCK等image进行校验。</p>
</li>
<li><p>sipc 内存区域清零，这部分由展讯自己实现，用于AP和Modem之间的通信交换，后面有文章会涉及。</p>
</li>
<li><p>跳转到内核启动</p>
</li>
</ul>
<ol start="3">
<li><p>_boot_display_logo<br>从logo分区中读取图片信息，存放到缓存中，调用<code>lcd_display_logo</code>刷新显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LOCAL __inline void _boot_display_logo(block_dev_desc_t *dev, int backlight_set)</span><br><span class="line">&#123;</span><br><span class="line">        size_t size;</span><br><span class="line">#if defined(CONFIG_LCD_720P) || defined(CONFIG_LCD_HD) //LiWei add CONFIG_LCD_HD</span><br><span class="line">        size = 1&lt;&lt;20;</span><br><span class="line">#else</span><br><span class="line">        size = 1&lt;&lt;19;</span><br><span class="line">#endif</span><br><span class="line">        uint8 * bmp_img = malloc(size);</span><br><span class="line">        if(!bmp_img)&#123;</span><br><span class="line">            debugf(&quot;%s: malloc for splash image failed!\n&quot;,__FUNCTION__);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!_boot_partition_read(dev, L&quot;logo&quot;, 0, size, bmp_img))</span><br><span class="line">        &#123;</span><br><span class="line">                debugf(&quot;%s: read logo partition failed!\n&quot;,__FUNCTION__);</span><br><span class="line">                goto end;</span><br><span class="line">        &#125;</span><br><span class="line">        lcd_display_logo(backlight_set,(ulong)bmp_img,size);</span><br><span class="line">end:</span><br><span class="line">        free(bmp_img);</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lcd_display_logo<br>因为是bmp格式图片，需要调用 lcd_display_bitmap 进行格式转换后才能在lcd上显示；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void lcd_display_logo(int backlight_set,ulong bmp_img,size_t size)</span><br><span class="line">&#123;</span><br><span class="line">#define mdelay(t)     (&#123;unsigned long msec=(t); while (msec--) &#123; udelay(1000);&#125;&#125;)</span><br><span class="line">    if(backlight_set == BACKLIGHT_ON)&#123;</span><br><span class="line">        lcd_display_bitmap((ulong)bmp_img, 0, 0);</span><br><span class="line">        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);</span><br><span class="line">        lcd_display();</span><br><span class="line">        mdelay(50);</span><br><span class="line">        set_backlight(255);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);</span><br><span class="line">        lcd_display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lcd_display<br>参考前面的内容，refresh函数指针等同于<code>sprdfb_dispc_refresh</code>，定义在 <code>drivers/video/sprdfb_dispc.c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c</span><br><span class="line">void lcd_display(void)</span><br><span class="line">&#123;</span><br><span class="line">    real_refresh(&amp;s_sprdfb_dev);</span><br><span class="line">&#125;</span><br><span class="line">static int real_refresh(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    dev-&gt;ctrl-&gt;refresh(dev);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sprdfb_dispc_refresh<br>这里针对mipi lcd模组，可以简单理解为cmd mode和video mode不同方式刷新显示，这里不再详细分析操作寄存器的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb_dispc.c</span><br><span class="line">static int32_t sprdfb_dispc_refresh (struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    if(SPRDFB_PANEL_IF_DPI == dev-&gt;panel_if_type) &#123;    //cmd mode</span><br><span class="line">        dispc_set_bits((1&lt;&lt;5), DISPC_DPI_CTRL);</span><br><span class="line">        if(is_first_frame)&#123;</span><br><span class="line">            udelay(30);</span><br><span class="line">            dispc_clear_bits((1&lt;&lt;4), DISPC_DPI_CTRL);</span><br><span class="line">            dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);</span><br><span class="line">            is_first_frame = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;    //video mode</span><br><span class="line">        dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);</span><br><span class="line">        ...</span><br><span class="line">        dispc_set_bits((1&lt;&lt;0), DISPC_INT_CLR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>至此，uboot lcd的初始化和刷新显示已经分析完成了。</p>
<h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><p>lcd 相关代码如下图：<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd.png" alt="sprdfb kernel code"></p>
<p>和 uboot 代码架构基本相似，下面以 <code>lcd_nt35516_mipi.c</code>为例进行分析</p>
<h2 id="lcd模组配置"><a href="#lcd模组配置" class="headerlink" title="lcd模组配置"></a>lcd模组配置</h2><p>驱动文件放置路径:  <code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code></p>
<ul>
<li><p>drivers/video/sprdfb/lcd/Makefile<br>包含编译该屏驱动的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_FB_LCD_NT35516_MIPI)  += lcd_nt35516_mipi.o=</span><br></pre></td></tr></table></figure>
</li>
<li><p>drivers/video/sprdfb/Kconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config FB_LCD_NT35516_MIPI</span><br><span class="line">        boolean &quot;support NT35516 mipi panel&quot;</span><br><span class="line">        depends on FB_SC8825 || FB_SCX35 || FB_SCX30G</span><br><span class="line">        default n</span><br></pre></td></tr></table></figure>
</li>
<li><p>arch/arm/configs/sp7731gea-dt_defconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FB_LCD_NT35516_MIPI=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c<br>这个文件配置了该模组的基本信息和操作方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">	.panel_init = nt35516_mipi_init,</span><br><span class="line">	.panel_readid = nt35516_readid,</span><br><span class="line">	.panel_enter_sleep = nt35516_enter_sleep,</span><br><span class="line">	.panel_esd_check = nt35516_check_esd,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">	.hfp = 20,  /* unit: pixel */</span><br><span class="line">	.hbp = 20,</span><br><span class="line">	.hsync = 20,//4,</span><br><span class="line">	.vfp = 10, /*unit: line*/</span><br><span class="line">	.vbp = 10,</span><br><span class="line">	.vsync = 6,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">	.work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">	.video_bus_width = 24, /*18,16*/</span><br><span class="line">	.lan_number = 3,</span><br><span class="line">	.phy_feq = 500*1000,</span><br><span class="line">	.h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">	.v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">	.de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">	.te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">	.color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">	.shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">	.timing = &amp;lcd_nt35516_mipi_timing,</span><br><span class="line">	.ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">.display_width = 480,</span><br><span class="line">.display_height = 854,</span><br><span class="line">#endif</span><br><span class="line">	.width = 540,</span><br><span class="line">	.height = 960,</span><br><span class="line">	.fps = 60,</span><br><span class="line">	.type = LCD_MODE_DSI,</span><br><span class="line">	.direction = LCD_DIRECT_NORMAL,</span><br><span class="line">	.is_clean_lcd = true,</span><br><span class="line">	.info = &#123;</span><br><span class="line">		.mipi = &amp;lcd_nt35516_mipi_info</span><br><span class="line">	&#125;,</span><br><span class="line">	.ops = &amp;lcd_nt35516_mipi_operations,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct panel_cfg lcd_nt35516_mipi = &#123;</span><br><span class="line">	/* this panel can only be main lcd */</span><br><span class="line">	.dev_id = SPRDFB_MAINLCD_ID,</span><br><span class="line">	.lcd_id = 0x16,</span><br><span class="line">	.lcd_name = &quot;lcd_nt35516_mipi&quot;,</span><br><span class="line">	.panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init lcd_nt35516_mipi_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	return sprdfb_panel_register(&amp;lcd_nt35516_mipi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(lcd_nt35516_mipi_init);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>subsys_initcall</strong> 是一个内核中的一个宏，定义特殊的init段，在内核启动过程中会依次调用这些函数，基本和<strong>module_init</strong>类似，但优先级更高。</p>
<p><strong>sprdfb_panel_register</strong> 定义在 <code>drivers/video/sprdfb/sprdfb_panel.c</code>，会把该模组对应的 panel_cfg 添加到维护的全局链表<code>panel_list_main</code> 中。</p>
<h2 id="lcd-模组初始化流程-1"><a href="#lcd-模组初始化流程-1" class="headerlink" title="lcd 模组初始化流程"></a>lcd 模组初始化流程</h2><ul>
<li><p>arch/arm/configs/sp7731gea-native_defconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MACH_SP7731GEA=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>arch/arm/boot/dts/Makefile </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch/arm/boot/dts/sprd-scx35_sp7731gea.dts</span><br><span class="line">226:dtb-$(CONFIG_MACH_SP7731GEA) += sprd-scx35_sp7731gea.dtb</span><br><span class="line">227:dtb-$(CONFIG_MACH_SP7731GEA_LM) += sprd-scx35_sp7731gea_lm.dtb</span><br><span class="line">228:dtb-$(CONFIG_MACH_SP7731GEA_FWVGA) += sprd-scx35_sp7731gea_fwvga.dtb</span><br><span class="line">229:dtb-$(CONFIG_MACH_SP7731GEAOPENPHONE) += sprd-scx35_sp7731geaopenphone.dtb</span><br></pre></td></tr></table></figure>
</li>
<li><p>sprd-scx35_sp7731gea.dts<br>其中lcd controller配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">	serial0 = &amp;uart0;</span><br><span class="line">	serial1 = &amp;uart1;</span><br><span class="line">	serial2 = &amp;uart2;</span><br><span class="line">	serial3 = &amp;uart3;</span><br><span class="line">	i2c0 = &amp;i2c0;</span><br><span class="line">	i2c1 = &amp;i2c1;</span><br><span class="line">	i2c2 = &amp;i2c2;</span><br><span class="line">	i2c3 = &amp;i2c3;</span><br><span class="line">	lcd0 = &amp;fb0;</span><br><span class="line">	spi0 = &amp;spi0;</span><br><span class="line">	spi1 = &amp;spi1;</span><br><span class="line">	spi2 = &amp;spi2;</span><br><span class="line">	hwspinlock0 = &amp;hwspinlock0;</span><br><span class="line">	hwspinlock1 = &amp;hwspinlock1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fb0: fb@20800000 &#123;</span><br><span class="line">	compatible = &quot;sprd,sprdfb&quot;;</span><br><span class="line">	reg = &lt;0xf5122000 0x1000&gt;,&lt;0xf5146000 0x1000&gt;;</span><br><span class="line">	interrupts = &lt;0 46 0x0&gt;,&lt;0 48 0x0&gt;, &lt;0 49 0x0&gt;;</span><br><span class="line">	clock-names = &quot;dispc_clk_parent&quot;, &quot;dispc_dbi_clk_parent&quot;, &quot;dispc_dpi_clk_parent&quot;, &quot;dispc_emc_clk_parent&quot;, &quot;dispc_clk&quot;, &quot;dispc_dbi_clk&quot;, &quot;dispc_dpi_clk&quot;, &quot;dispc_emc_clk&quot;, &quot;fb_spi_clock&quot;, &quot;fb_spi_clock_parent&quot;;</span><br><span class="line">	clocks = &lt;&amp;clk_256m&gt;, &lt;&amp;clk_256m&gt;, &lt;&amp;clk_384m&gt;, &lt;&amp;clk_aon_apb&gt;, &lt;&amp;clk_dispc0&gt;, &lt;&amp;clk_dispc0_dbi&gt;, &lt;&amp;clk_dispc0_dpi&gt;, &lt;&amp;clk_disp_emc&gt;, &lt;&amp;clk_spi2&gt;, &lt;&amp;ext_26m&gt;;</span><br><span class="line">	clock-src = &lt;256000000 256000000 384000000&gt;;</span><br><span class="line">	dpi_clk_div = &lt;7&gt;;</span><br><span class="line">	sprd,fb_use_reservemem;</span><br><span class="line">	sprd,fb_mem = &lt;0x9F311000 0x5EF000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>drivers/video/sprdfb/sprdfb_main.c<br>与之相匹配的lcd控制器驱动位于 <code>drivers/video/sprdfb/sprdfb_main.c</code>，当设备节点device_node被解析为platform_device注册到系统时，会和这个驱动进行匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_OF</span><br><span class="line">static const struct of_device_id sprdfb_dt_ids[] = &#123;</span><br><span class="line">        &#123; .compatible = &quot;sprd,sprdfb&quot;, &#125;,</span><br><span class="line">        &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line">static struct platform_driver sprdfb_driver = &#123;</span><br><span class="line">        .probe = sprdfb_probe,</span><br><span class="line">#ifndef CONFIG_HAS_EARLYSUSPEND</span><br><span class="line">        .suspend = sprdfb_suspend,</span><br><span class="line">        .resume = sprdfb_resume,</span><br><span class="line">#endif</span><br><span class="line">        .remove = sprdfb_remove,</span><br><span class="line">        .driver = &#123;</span><br><span class="line">                .name = &quot;sprd_fb&quot;,</span><br><span class="line">                .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">                .of_match_table = of_match_ptr(sprdfb_dt_ids),</span><br><span class="line">#endif</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">static int __init sprdfb_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        return platform_driver_register(&amp;sprdfb_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>驱动加载流程大致如下图：<br><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/sprd_kernel_lcd_init.png" alt="sprd kernel lcd probe"></p>
<p><strong>sprdfb_probe</strong> 函数的定义如下，简单分析下代码流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static int sprdfb_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct fb_info *fb = NULL;</span><br><span class="line">    struct sprdfb_device *dev = NULL;</span><br><span class="line">    struct resource r;</span><br><span class="line"></span><br><span class="line">    fb = framebuffer_alloc(sizeof(struct sprdfb_device), &amp;pdev-&gt;dev);    //(1)分布帧缓冲使用空间</span><br><span class="line">    dev = fb-&gt;par;</span><br><span class="line">    dev-&gt;fb = fb;</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">    dev-&gt;of_dev = &amp;(pdev-&gt;dev);</span><br><span class="line">    dev-&gt;dev_id = of_alias_get_id(pdev-&gt;dev.of_node, &quot;lcd&quot;);    //(2)读取设备树中lcd id</span><br><span class="line">    printk(&quot;sprdfb: [%s] id = %d\n&quot;, __FUNCTION__, dev-&gt;dev_id);</span><br><span class="line">#else</span><br><span class="line">    dev-&gt;dev_id = pdev-&gt;id;</span><br><span class="line">#endif</span><br><span class="line">    switch(SPRDFB_IN_DATA_TYPE)&#123;</span><br><span class="line">    case SPRD_IN_DATA_TYPE_ABGR888:</span><br><span class="line">        dev-&gt;bpp = 32;</span><br><span class="line">        break;</span><br><span class="line">    case SPRD_IN_DATA_TYPE_BGR565:</span><br><span class="line">        dev-&gt;bpp = 16;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        dev-&gt;bpp = 32;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(SPRDFB_MAINLCD_ID == dev-&gt;dev_id)&#123;    //确认是主屏显示</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(3) </span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">        if(0 != of_address_to_resource(pdev-&gt;dev.of_node, 0, &amp;r))&#123;    //(4)</span><br><span class="line">            printk(KERN_ERR &quot;sprdfb: sprdfb_probe fail. (can&apos;t get register base address)\n&quot;);</span><br><span class="line">            goto err0;</span><br><span class="line">        &#125;</span><br><span class="line">        g_dispc_base_addr = r.start;</span><br><span class="line">        printk(&quot;sprdfb: set g_dispc_base_addr = 0x%x\n&quot;, g_dispc_base_addr);</span><br><span class="line">#endif</span><br><span class="line">    dev-&gt;logo_buffer_addr_v = 0;</span><br><span class="line">    if(sprdfb_panel_get(dev))&#123;    //(5) </span><br><span class="line">        dev-&gt;panel_ready = true;</span><br><span class="line">        dev-&gt;ctrl-&gt;logo_proc(dev);  //(6)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dev-&gt;panel_ready = false;</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;ctrl-&gt;early_init(dev); //(7)</span><br><span class="line">    if(!dev-&gt;panel_ready)&#123;</span><br><span class="line">        if (!sprdfb_panel_probe(dev)) &#123;</span><br><span class="line">            ret = -EIO;</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = setup_fb_mem(dev, pdev);  //(8)</span><br><span class="line">    setup_fb_info(dev); //(9)</span><br><span class="line">    /* register framebuffer device */</span><br><span class="line">    ret = register_framebuffer(fb); //(10)</span><br><span class="line">    platform_set_drvdata(pdev, dev);</span><br><span class="line">    sprdfb_create_sysfs(dev);</span><br><span class="line">    dev-&gt;ctrl-&gt;init(dev);   //(11)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>(1) 为lcd控制器分配 framebuffer 结构体 fb_info；</p>
</li>
<li><p>(2) 读取设备树中lcd id，从前面设备树的信息lcd0来看，id = 0；</p>
</li>
<li><p>(3) <code>sprdfb_dispc_ctrl</code> 保存为Soc显示控制器的操作接口；</p>
</li>
<li><p>(4) 获取设备树中配置的寄存器地址信息。</p>
</li>
<li><p>(5) <code>sprdfb_panel_get</code> 会调用<code>adapt_panel_from_uboot</code>遍历模组链表 <code>panel_list_main</code> 中 panel_cfg，将lcd_id 和 uboot中读取的模组芯片id进行对比，如果匹配则返回对应的panel_cfg；如果没有匹配，会再后续的流程中调用<code>sprdfb_panel_probe</code>重新加载模组驱动。这期间会设置 <strong>DISPC</strong> 的dsi硬件配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct panel_spec *adapt_panel_from_readid(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct panel_cfg *cfg;</span><br><span class="line">    struct list_head *panel_list;</span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(6) <code>sprdfb_dispc_logo_proc</code> 按照panel_cfg的尺寸申请缓存区，并从uboot lcd_base中拷贝logo数据；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void sprdfb_dispc_logo_proc(struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t kernel_fb_size = 0;</span><br><span class="line">	uint32_t logo_src_v = 0;</span><br><span class="line">	uint32_t logo_dst_v = 0;//use the second frame buffer	,virtual</span><br><span class="line">	uint32_t logo_dst_p = 0;//use the second frame buffer ,physical</span><br><span class="line">	uint32_t logo_size = 0;// should be rgb565</span><br><span class="line"></span><br><span class="line">	if(dev == NULL) &#123;</span><br><span class="line">		printk(&quot;sprdfb: %s[%d]: dev == NULL, return without process logo!!\n&quot;,__func__,__LINE__);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(lcd_base_from_uboot == 0) &#123;</span><br><span class="line">		printk(&quot;sprdfb: %s[%d]: lcd_base_from_uboot == 0, return without process logo!!\n&quot;,__func__,__LINE__);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(SPRDFB_PANEL_IF_DPI != dev-&gt;panel_if_type)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    logo_size = dev-&gt;panel-&gt;width * dev-&gt;panel-&gt;height * 2;// should be rgb565</span><br><span class="line"></span><br><span class="line">	dev-&gt;logo_buffer_size = logo_size;</span><br><span class="line">	dev-&gt;logo_buffer_addr_v = __get_free_pages(GFP_ATOMIC | __GFP_ZERO , get_order(logo_size));</span><br><span class="line"></span><br><span class="line">	logo_dst_v = dev-&gt;logo_buffer_addr_v;</span><br><span class="line">	logo_dst_p = __pa(dev-&gt;logo_buffer_addr_v);</span><br><span class="line"></span><br><span class="line">    logo_src_v =  (uint32_t)ioremap(lcd_base_from_uboot, logo_size);</span><br><span class="line"></span><br><span class="line">	memcpy(logo_dst_v, logo_src_v, logo_size);</span><br><span class="line">	dma_sync_single_for_device(dev, logo_dst_p, logo_size, DMA_TO_DEVICE);</span><br><span class="line"></span><br><span class="line">	iounmap(logo_src_v);</span><br><span class="line">    </span><br><span class="line">	dispc_write(logo_dst_p, DISPC_OSD_BASE_ADDR);</span><br><span class="line">	sprdfb_dispc_refresh_logo(dev);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int32_t sprdfb_dispc_refresh_logo (struct sprdfb_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	dispc_clear_bits(0x1f, DISPC_INT_EN);//disable all interrupt</span><br><span class="line">	dispc_set_bits(0x1f, DISPC_INT_CLR);// clear all interruption</span><br><span class="line">	dispc_set_bits(BIT(5), DISPC_DPI_CTRL);//update</span><br><span class="line"></span><br><span class="line">//wait for update- done interruption</span><br><span class="line">	for(i=0; i&lt;500; i++) &#123;</span><br><span class="line">		if(!(dispc_read(DISPC_INT_RAW) &amp; (0x10)))&#123;</span><br><span class="line">			udelay(1000);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    if(i &gt;= 500) &#123;</span><br><span class="line">        printk(&quot;sprdfb: [%s] wait dispc done int time out!! (0x%x)\n&quot;, __func__, dispc_read(DISPC_INT_RAW));</span><br><span class="line">    &#125;</span><br><span class="line">	dispc_set_bits((1&lt;&lt;5), DISPC_INT_CLR);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(7) sprdfb_dispc_early_init 恢复使能 <strong>DISPC</strong> 模组；</p>
</li>
<li><p>(8) setup_fb_mem 解析设备树“sprd,fb_mem”配置 fb_info screen_base等参数</p>
</li>
<li><p>(9) setup_fb_info 进一步配置 fb_info，设置固定参数和可变参数；   </p>
</li>
<li><p>(10) register_framebuffer 向内核注册帧缓冲区；</p>
</li>
<li><p>(11) sprdfb_dispc_init 设置 <strong>DISPC</strong> 的dithering 和 osd layer blending功能。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>针对lcd驱动调试的一些总结：</p>
<ul>
<li>背光不亮</li>
</ul>
<blockquote>
<p>通常直接排查硬件，检查背光电压，pwm波形输出等</p>
</blockquote>
<ul>
<li>白屏显示</li>
</ul>
<blockquote>
<p>1.优先检查电压，一般液晶模组在完成初始化后，VGH/VGL经过charge pump，基本能够达到正负15v左右。</p>
</blockquote>
<blockquote>
<p>2.读取模组id，优先检查硬件接口是否有误，然后排查软件接口的设置，可通过示波器辅助快速定位。</p>
</blockquote>
<blockquote>
<p>3.检查是否初始化代码有误，存在模组代码不匹配的情况。</p>
</blockquote>
<ul>
<li>显示异常</li>
</ul>
<blockquote>
<p>1.优先排查硬件，曾经有遇到过BB的VDD输出2.8V，DVDD输出1.8v，但是模组内部将VDD/DVDD相连，直接导致初始化升压不够，显示异常。</p>
</blockquote>
<blockquote>
<p>2.检查分辨率、像素、时序配置和proch设定是否存在问题。</p>
</blockquote>
<blockquote>
<p>3.画面撕裂问题，一般需要开启TE，BB会在每帧数据开始前发送信号同步。</p>
</blockquote>
<blockquote>
<p>4.画面翻转问题，一般修改模组初始化代码，修改显示刷新方向解决。</p>
</blockquote>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/lcd/" rel="tag"># lcd</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/30/terminal-for-microcontrol/" rel="next" title="terminal for microcontrol">
                  <i class="fa fa-chevron-left"></i> terminal for microcontrol
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#显示系统"><span class="nav-number">1.</span> <span class="nav-text">显示系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uboot"><span class="nav-number">2.</span> <span class="nav-text">uboot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lcd-模组配置"><span class="nav-number">2.1.</span> <span class="nav-text">lcd 模组配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lcd-模组初始化流程"><span class="nav-number">2.2.</span> <span class="nav-text">lcd 模组初始化流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lcd-刷新显示流程"><span class="nav-number">2.3.</span> <span class="nav-text">lcd 刷新显示流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kernel"><span class="nav-number">3.</span> <span class="nav-text">kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lcd模组配置"><span class="nav-number">3.1.</span> <span class="nav-text">lcd模组配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lcd-模组初始化流程-1"><span class="nav-number">3.2.</span> <span class="nav-text">lcd 模组初始化流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tinylaker</p>
  <div class="site-description" itemprop="description">个人学习总结</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/tinylaker" title="GitHub &rarr; https://github.com/tinylaker" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:xyxujinlong@163.com" title="E-Mail &rarr; mailto:xyxujinlong@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tinylaker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
