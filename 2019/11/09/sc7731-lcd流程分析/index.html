<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="Tinylaker blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。 本文基于Android 4.4代码分析sc7731 lcd的基本流程。 显示控制器下面的截图是显示控制器的组成，包含lcdc和dispc，  ubootlcd相关源码位于 drivers/video/sprdfb，代码文件截图如下:  可以看到代码兼容了多款 Soc，Makefile 中也包含了多个平">
<meta name="keywords" content="lcd">
<meta property="og:type" content="article">
<meta property="og:title" content="sc7731 lcd流程分析">
<meta property="og:url" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/index.html">
<meta property="og:site_name" content="Tinylaker blog">
<meta property="og:description" content="本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。 本文基于Android 4.4代码分析sc7731 lcd的基本流程。 显示控制器下面的截图是显示控制器的组成，包含lcdc和dispc，  ubootlcd相关源码位于 drivers/video/sprdfb，代码文件截图如下:  可以看到代码兼容了多款 Soc，Makefile 中也包含了多个平">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/images/sc7731_uboot_lcd.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/images/sprdfb_uboot_lcd_init.png">
<meta property="og:updated_time" content="2019-11-10T05:30:16.607Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sc7731 lcd流程分析">
<meta name="twitter:description" content="本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。 本文基于Android 4.4代码分析sc7731 lcd的基本流程。 显示控制器下面的截图是显示控制器的组成，包含lcdc和dispc，  ubootlcd相关源码位于 drivers/video/sprdfb，代码文件截图如下:  可以看到代码兼容了多款 Soc，Makefile 中也包含了多个平">
<meta name="twitter:image" content="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png">
  <link rel="canonical" href="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>sc7731 lcd流程分析 | Tinylaker blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ddfa4a6ba83ff65311f95d251f9389b3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tinylaker blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">stay hungry stay foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tinylaker">
      <meta itemprop="description" content="个人学习总结">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tinylaker blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">sc7731 lcd流程分析

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-09 19:34:45" itemprop="dateCreated datePublished" datetime="2019-11-09T19:34:45+08:00">2019-11-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-10 13:30:16" itemprop="dateModified" datetime="2019-11-10T13:30:16+08:00">2019-11-10</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本系列文章以分享笔者以前的学习和工作内容为主，旨在查缺补漏，如有错误和不足之处，请读者不吝指正。</p>
<p>本文基于Android 4.4代码分析sc7731 lcd的基本流程。</p>
<h1 id="显示控制器"><a href="#显示控制器" class="headerlink" title="显示控制器"></a>显示控制器</h1><p>下面的截图是显示控制器的组成，包含lcdc和dispc，</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/lcdc.png" alt="lcdc"></p>
<h1 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h1><p>lcd相关源码位于 <code>drivers/video/sprdfb</code>，代码文件截图如下:</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/images/sc7731_uboot_lcd.png" alt="sc7731 uboot source code"></p>
<p>可以看到代码兼容了多款 Soc，Makefile 中也包含了多个平台的配置。</p>
<p>头文件 <code>include/configs/sp7731gea.h</code>，里面定义了 <code>CONFIG_SC8830</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SC8830</span><br><span class="line">#define CONFIG_DSIH_VERSION_1P21A</span><br><span class="line">#define CONFIG_FB_LCD_NT35516_MIPI</span><br></pre></td></tr></table></figure>

<p>这里值得一提的是7731和8830的AP相同，只是Modem存在差异，前者支持WCMDA，后者支持TD_SCMDA。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_SC8830)+= sprdfb_main.o sprdfb_panel.o sprdfb_dispc.o \</span><br><span class="line">    sprdfb_mcu.o sprdfb_rgb.o sprdfb_mipi.o \</span><br><span class="line">     sprdfb_i2c.o sprdfb_spi.o sprdfb_dsi.o \</span><br><span class="line">     sprdfb_chip_common.o sprdfb_chip_8830.o</span><br></pre></td></tr></table></figure>

<p>能够看出该平台的显示系统支持多种lcd接口，包括mcu、rgb、mipi、i2c、spi。</p>
<p>这里的mipi dsi有2个不同版本的IP核，参考头文件中的定义，这里使用的是dsi_1_21a中的代码。</p>
<p>下面以 <code>lcd_nt35516_mipi.c</code> 为例，分析 uboot lcd 的整个流程。</p>
<h2 id="一、lcd-模组配置"><a href="#一、lcd-模组配置" class="headerlink" title="一、lcd 模组配置"></a>一、lcd 模组配置</h2><ol>
<li><code>drivers/video/sprdfb/lcd/Makefile</code> 包含编译该屏驱动的配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COBJS-$(CONFIG_FB_LCD_NT35516_MIPI) += lcd_nt35516_mipi.o</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><code>drivers/video/sprdfb/sprdfb_panel.c</code> 中包含该屏的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern struct panel_spec lcd_nt35516_mipi_spec;</span><br><span class="line">static struct panel_cfg panel_cfg[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">#ifdef CONFIG_FB_LCD_NT35516_MIPI </span><br><span class="line">    &#123; </span><br><span class="line">        .lcd_id = 0x16, </span><br><span class="line">        .panel = &amp;lcd_nt35516_mipi_spec,</span><br><span class="line">    &#125;,</span><br><span class="line"> #endif</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</code> 中详细描述了该模组的配置</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct panel_spec lcd_nt35516_mipi_spec = &#123;</span><br><span class="line">        //.cap = PANEL_CAP_NOT_TEAR_SYNC,</span><br><span class="line">#ifdef CONFIG_FB_LOW_RES_SIMU</span><br><span class="line">        .display_width = 480,</span><br><span class="line">        .display_height= 854,</span><br><span class="line">#endif</span><br><span class="line">        .width = 540,</span><br><span class="line">        .height = 960,</span><br><span class="line">        .fps = 60,</span><br><span class="line">        .type = LCD_MODE_DSI,</span><br><span class="line">        .direction = LCD_DIRECT_NORMAL,</span><br><span class="line">        .info = &#123;</span><br><span class="line">                .mipi = &amp;lcd_nt35516_mipi_info    //(1) mipi lcd模组的常规配置</span><br><span class="line">        &#125;,</span><br><span class="line">        .ops = &amp;lcd_nt35516_mipi_operations,    //(2) mipi lcd的操作集合</span><br><span class="line">&#125;;</span><br><span class="line">static struct info_mipi lcd_nt35516_mipi_info = &#123;</span><br><span class="line">        .work_mode  = SPRDFB_MIPI_MODE_VIDEO,</span><br><span class="line">        .video_bus_width = 24, /*18,16*/</span><br><span class="line">        .lan_number = 3,</span><br><span class="line">        .phy_feq = 500*1000,</span><br><span class="line">        .h_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .v_sync_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .de_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .te_pol = SPRDFB_POLARITY_POS,</span><br><span class="line">        .color_mode_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .shut_down_pol = SPRDFB_POLARITY_NEG,</span><br><span class="line">        .timing = &amp;lcd_nt35516_mipi_timing,    //(3) mipi lcd的时序proch配置</span><br><span class="line">        .ops = NULL,</span><br><span class="line">&#125;;</span><br><span class="line">static struct panel_operations lcd_nt35516_mipi_operations = &#123;</span><br><span class="line">        .panel_init = nt35516_mipi_init,    //包含mipi屏大量初始化代码</span><br><span class="line">        .panel_readid = nt35516_readid,    //mipi屏的读取id操作</span><br><span class="line">&#125;;</span><br><span class="line">static struct timing_rgb lcd_nt35516_mipi_timing = &#123;</span><br><span class="line">        .hfp = 20,  /* unit: pixel */</span><br><span class="line">        .hbp = 20,</span><br><span class="line">        .hsync = 20,//4,</span><br><span class="line">        .vfp = 10, /*unit: line*/</span><br><span class="line">        .vbp = 10,</span><br><span class="line">        .vsync = 6,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二、lcd-模组初始化流程"><a href="#二、lcd-模组初始化流程" class="headerlink" title="二、lcd 模组初始化流程"></a>二、lcd 模组初始化流程</h2><p>系统上电执行芯片 <strong>RomCode</strong>，完成 DDR 和外部存储器等常用外设的初始化；</p>
<p>之后读取外部存储器中的 uboot 并跳转执行，优先完成板级初始化 <code>board_init_f</code> 和 <code>board_init_r</code>，其中 <code>board_init_r</code> 中调用了<code>stdio_init</code>。代码流程图如下：</p>
<p><img src="//tinylaker.github.io/2019/11/09/sc7731-lcd流程分析/images/sprdfb_uboot_lcd_init.png" alt="sprdfb_lcd_init"></p>
<p>我们把重点聚焦在 sprdfb_probe 的实现上，下面剔除了部分无关代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ drivers/video/sprdfb/sprdfb_main.c  </span><br><span class="line"></span><br><span class="line">static int sprdfb_probe(void * lcdbase)</span><br><span class="line">&#123;</span><br><span class="line">        struct sprdfb_device *dev = &amp;s_sprdfb_dev;</span><br><span class="line">        set_backlight(0);    //(1)</span><br><span class="line">        dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;    //(2) </span><br><span class="line">        dev-&gt;ctrl-&gt;early_init(dev);    //(3)</span><br><span class="line">        if (0 != sprdfb_panel_probe(dev)) &#123;    //(4)</span><br><span class="line">                sprdfb_panel_remove(dev);</span><br><span class="line">                dev-&gt;ctrl-&gt;uninit(dev);</span><br><span class="line">                printf(&quot;sprdfb: failed to probe\n&quot;);</span><br><span class="line">                return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        dev-&gt;smem_start = ((uint32_t)lcdbase);</span><br><span class="line">        dev-&gt;ctrl-&gt;init(dev);    //(5)</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>(1) 关闭pwm控制</li>
<li>(2) 获取通用的 display ctrl 实现，定义在 <code>sprdfb_dispc.c</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@ drivers/video/sprdfb/sprdfb_dispc.c</span><br><span class="line">  struct display_ctrl sprdfb_dispc_ctrl = &#123;</span><br><span class="line">          .name           = &quot;dispc&quot;,</span><br><span class="line">          .early_init             = sprdfb_dispc_early_init,</span><br><span class="line">          .init                   = sprdfb_dispc_init,</span><br><span class="line">          .uninit         = sprdfb_dispc_uninit,</span><br><span class="line">          .refresh                = sprdfb_dispc_refresh,</span><br><span class="line">          .update_clk     = dispc_update_clock,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">- (3) 调用`sprdfb_dispc_early_init`，配置显示系统相关的clk，使能`dispc module`</span><br><span class="line">- (4) `sprdfb_panel_probe` 会读取和保存 lcd 模组的 id，并对该模组完成初始化。</span><br><span class="line">-  (5) `sprdfb_dispc_init` 会完成显示系统 dithering 和osd layer 的设置。</span><br><span class="line"></span><br><span class="line">需要特别注意 uboot lcd 初始化流程中会保存 **lcd_base** 和 **lcd_id**，通过命令行参数传递，以供 kernel 阶段继续使用。</span><br><span class="line"></span><br><span class="line">## 三、lcd 刷新显示流程</span><br><span class="line"></span><br><span class="line">看到这里读者可能会有疑问，uboot logo 是什么时候显示的呢？</span><br><span class="line"></span><br><span class="line">下面开始分析lcd refresh流程，这里要从 `board_init_r` 中的**do_cboot**代码分析。</span><br><span class="line"></span><br><span class="line">1. normal_mode</span><br><span class="line"></span><br><span class="line">代码定义了多种启动方式：normal、recovery、fastboot、charge、watchdog等，这里直接看normal_boot的代码。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>@ property/normal_mode.c</p>
<p>void normal_mode(void) {<br>    vibrator_hw_init();<br>    set_vibrator(1);</p>
<p>#if BOOT_NATIVE_LINUX<br>    vlx_nand_boot(BOOT_PART, CONFIG_BOOTARGS, BACKLIGHT_ON);</p>
<p>#else<br>    vlx_nand_boot(BOOT_PART, NULL, BACKLIGHT_ON);</p>
<p>#endif<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先初始化马达硬件，完成开机震动，然后调用 vlx_nand_boot，这里的代码取决有是 nand 方案还是 emmc 方案，这里假设是 emmc 启动。</span><br><span class="line"></span><br><span class="line">2. vlx_nand_boot</span><br></pre></td></tr></table></figure>

<p>@ property/normal_emc_mode.c</p>
<p>void vlx_nand_boot(char * kernel_pname, char * cmdline, int backlight_set) {<br>    _boot_display_logo(dev, backlight_set);    //(1)<br>    set_vibrator(FALSE);<br>    _boot_load_kernel_ramdisk_image(dev, kernel_pname, hdr);<br>    _boot_secure_check();<br>    sipc_addr_reset();<br>    vlx_entry();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 调用_boot_display_logo，读取logo分区图片内容，并调用lcd_display_logo，重点关注。</span><br><span class="line"></span><br><span class="line">- 关闭马达;</span><br><span class="line"></span><br><span class="line">- 从存储器读取kernel、ramdisk、dtb image，保存相关内存地址。</span><br><span class="line"></span><br><span class="line">- secure boot校验流程，根据产品定义，可能会对DSP、Modem、SIMLOCK等image进行校验。</span><br><span class="line"></span><br><span class="line">- sipc 内存区域清零，这部分由展讯自己实现，用于AP和Modem之间的通信交换，后面有文章会涉及。</span><br><span class="line"></span><br><span class="line">- 跳转到内核启动</span><br><span class="line"></span><br><span class="line">3. _boot_display_logo</span><br></pre></td></tr></table></figure>

<p>LOCAL __inline void _boot_display_logo(block_dev_desc_t *dev, int backlight_set)<br>{<br>        size_t size;</p>
<p>#if defined(CONFIG_LCD_720P) || defined(CONFIG_LCD_HD) //LiWei add CONFIG_LCD_HD<br>        size = 1&lt;&lt;20;</p>
<p>#else<br>        size = 1&lt;&lt;19;</p>
<p>#endif<br>        uint8 * bmp_img = malloc(size);<br>        if(!bmp_img){<br>            debugf(“%s: malloc for splash image failed!\n”,<strong>FUNCTION</strong>);<br>            return;<br>        }<br>        if(!<em>boot_partition_read(dev, L”logo”, 0, size, bmp_img))<br>        {<br>                debugf(“%s: read logo partition failed!\n”,<em>_FUNCTION</em></em>);<br>                goto end;<br>        }<br>        lcd_display_logo(backlight_set,(ulong)bmp_img,size);<br>end:<br>        free(bmp_img);<br>        return;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从logo分区中读取图片信息，存放到缓存中，调用`lcd_display_logo`刷新显示</span><br><span class="line"></span><br><span class="line">4. lcd_display_logo</span><br><span class="line"></span><br><span class="line">因为是bmp格式图片，需要调用 lcd_display_bitmap 进行格式转换后才能在lcd上显示；</span><br></pre></td></tr></table></figure>

<p>void lcd_display_logo(int backlight_set,ulong bmp_img,size_t size)<br>{</p>
<p>#define mdelay(t)     ({unsigned long msec=(t); while (msec–) { udelay(1000);}})<br>    if(backlight_set == BACKLIGHT_ON){<br>        lcd_display_bitmap((ulong)bmp_img, 0, 0);<br>        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);<br>        lcd_display();<br>        mdelay(50);<br>        set_backlight(255);<br>    } else {<br>        Dcache_CleanRegion((unsigned int)(lcd_base), size&lt;&lt;1);<br>        lcd_display();<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. lcd_display</span><br><span class="line"></span><br><span class="line">参考前面的内容，refresh函数指针等同于`sprdfb_dispc_refresh`，定义在 `drivers/video/sprdfb_dispc.c`</span><br></pre></td></tr></table></figure>

<p>@ drivers/video/sprdfb/sprdfb_main.c<br>void lcd_display(void)<br>{<br>    real_refresh(&amp;s_sprdfb_dev);<br>}<br>static int real_refresh(struct sprdfb_device *dev)<br>{<br>    dev-&gt;ctrl-&gt;refresh(dev);<br>    return 0;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. sprdfb_dispc_refresh</span><br><span class="line"></span><br><span class="line">这里针对mipi lcd模组，可以简单理解为cmd mode和video mode不同方式刷新显示，这里不再详细分析操作寄存器的部分。</span><br></pre></td></tr></table></figure>

<p>@ drivers/video/sprdfb_dispc.c<br>static int32_t sprdfb_dispc_refresh (struct sprdfb_device *dev)<br>{<br>    if(SPRDFB_PANEL_IF_DPI == dev-&gt;panel_if_type) {    //cmd mode<br>        dispc_set_bits((1&lt;&lt;5), DISPC_DPI_CTRL);<br>        if(is_first_frame){<br>            udelay(30);<br>            dispc_clear_bits((1&lt;&lt;4), DISPC_DPI_CTRL);<br>            dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);<br>            is_first_frame = 0;<br>        }<br>    } else {    //video mode<br>        dispc_set_bits((1 &lt;&lt; 4), DISPC_CTRL);<br>        …<br>        dispc_set_bits((1&lt;&lt;0), DISPC_INT_CLR);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">至此，uboot lcd的初始化和刷新显示已经分析完成了。</span><br><span class="line"></span><br><span class="line"># kernel</span><br><span class="line"></span><br><span class="line">lcd 相关代码如下图：</span><br><span class="line">![sprdfb kernel code](../images/sprd_kernel_lcd.png)</span><br><span class="line"></span><br><span class="line">和 uboot 代码架构基本相似，下面以 `lcd_nt35516_mipi.c `为例进行分析</span><br><span class="line"></span><br><span class="line">## 一、lcd模组配置</span><br><span class="line"></span><br><span class="line">驱动文件放置路径:  `drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c`</span><br><span class="line"></span><br><span class="line">- drivers/video/sprdfb/lcd/Makefile </span><br><span class="line">包含编译该屏驱动的配置</span><br></pre></td></tr></table></figure>

<p>obj-$(CONFIG_FB_LCD_NT35516_MIPI)  += lcd_nt35516_mipi.o=</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- drivers/video/sprdfb/Kconfig</span><br></pre></td></tr></table></figure>

<p>config FB_LCD_NT35516_MIPI<br>        boolean “support NT35516 mipi panel”<br>        depends on FB_SC8825 || FB_SCX35 || FB_SCX30G<br>        default n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- arch/arm/configs/sp7731gea-dt_defconfig</span><br></pre></td></tr></table></figure>

<p>CONFIG_FB_LCD_NT35516_MIPI=y</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- drivers/video/sprdfb/lcd/lcd_nt35516_mipi.c</span><br><span class="line"></span><br><span class="line">这个文件配置了该模组的基本信息和操作方法</span><br></pre></td></tr></table></figure>

<p>static struct panel_operations lcd_nt35516_mipi_operations = {<br>    .panel_init = nt35516_mipi_init,<br>    .panel_readid = nt35516_readid,<br>    .panel_enter_sleep = nt35516_enter_sleep,<br>    .panel_esd_check = nt35516_check_esd,<br>};</p>
<p>static struct timing_rgb lcd_nt35516_mipi_timing = {<br>    .hfp = 20,  /* unit: pixel <em>/<br>    .hbp = 20,<br>    .hsync = 20,//4,<br>    .vfp = 10, /*unit: line</em>/<br>    .vbp = 10,<br>    .vsync = 6,<br>};</p>
<p>static struct info_mipi lcd_nt35516_mipi_info = {<br>    .work_mode  = SPRDFB_MIPI_MODE_VIDEO,<br>    .video_bus_width = 24, /<em>18,16</em>/<br>    .lan_number = 3,<br>    .phy_feq = 500*1000,<br>    .h_sync_pol = SPRDFB_POLARITY_POS,<br>    .v_sync_pol = SPRDFB_POLARITY_POS,<br>    .de_pol = SPRDFB_POLARITY_POS,<br>    .te_pol = SPRDFB_POLARITY_POS,<br>    .color_mode_pol = SPRDFB_POLARITY_NEG,<br>    .shut_down_pol = SPRDFB_POLARITY_NEG,<br>    .timing = &amp;lcd_nt35516_mipi_timing,<br>    .ops = NULL,<br>};</p>
<p>struct panel_spec lcd_nt35516_mipi_spec = {</p>
<p>#ifdef CONFIG_FB_LOW_RES_SIMU<br>.display_width = 480,<br>.display_height = 854,</p>
<p>#endif<br>    .width = 540,<br>    .height = 960,<br>    .fps = 60,<br>    .type = LCD_MODE_DSI,<br>    .direction = LCD_DIRECT_NORMAL,<br>    .is_clean_lcd = true,<br>    .info = {<br>        .mipi = &amp;lcd_nt35516_mipi_info<br>    },<br>    .ops = &amp;lcd_nt35516_mipi_operations,<br>};</p>
<p>struct panel_cfg lcd_nt35516_mipi = {<br>    /* this panel can only be main lcd */<br>    .dev_id = SPRDFB_MAINLCD_ID,<br>    .lcd_id = 0x16,<br>    .lcd_name = “lcd_nt35516_mipi”,<br>    .panel = &amp;lcd_nt35516_mipi_spec,<br>};</p>
<p>static int __init lcd_nt35516_mipi_init(void)<br>{<br>    return sprdfb_panel_register(&amp;lcd_nt35516_mipi);<br>}</p>
<p>subsys_initcall(lcd_nt35516_mipi_init);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**subsys_initcall** 是一个内核中的一个宏，定义特殊的init段，在内核启动过程中会依次调用这些函数，基本和**module_init**类似，但优先级更高。</span><br><span class="line"></span><br><span class="line">**sprdfb_panel_register** 定义在 `drivers/video/sprdfb/sprdfb_panel.c`，会把该模组对应的 panel_cfg 添加到维护的全局链表`panel_list_main` 中。</span><br><span class="line"></span><br><span class="line">## 二、lcd 模组初始化流程</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">`arch/arm/configs/sp7731gea-native_defconfig `定义</span><br></pre></td></tr></table></figure>

<p>CONFIG_MACH_SP7731GEA=y</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对应的 arch/arm/boot/dts/Makefile 定义</span><br></pre></td></tr></table></figure>

<p>arch/arm/boot/dts/sprd-scx35_sp7731gea.dts<br>226:dtb-$(CONFIG_MACH_SP7731GEA) += sprd-scx35_sp7731gea.dtb<br>227:dtb-$(CONFIG_MACH_SP7731GEA_LM) += sprd-scx35_sp7731gea_lm.dtb<br>228:dtb-$(CONFIG_MACH_SP7731GEA_FWVGA) += sprd-scx35_sp7731gea_fwvga.dtb<br>229:dtb-$(CONFIG_MACH_SP7731GEAOPENPHONE) += sprd-scx35_sp7731geaopenphone.dtb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所以平台使用的设备树文件是`sprd-scx35_sp7731gea.dts`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中lcd controller配置如下：</span><br></pre></td></tr></table></figure>

<pre><code>aliases {
    serial0 = &amp;uart0;
    serial1 = &amp;uart1;
    serial2 = &amp;uart2;
    serial3 = &amp;uart3;
    i2c0 = &amp;i2c0;
    i2c1 = &amp;i2c1;
    i2c2 = &amp;i2c2;
    i2c3 = &amp;i2c3;
    lcd0 = &amp;fb0;
    spi0 = &amp;spi0;
    spi1 = &amp;spi1;
    spi2 = &amp;spi2;
    hwspinlock0 = &amp;hwspinlock0;
    hwspinlock1 = &amp;hwspinlock1;
};

fb0: fb@20800000 {
    compatible = &quot;sprd,sprdfb&quot;;
    reg = &lt;0xf5122000 0x1000&gt;,&lt;0xf5146000 0x1000&gt;;
    interrupts = &lt;0 46 0x0&gt;,&lt;0 48 0x0&gt;, &lt;0 49 0x0&gt;;
    clock-names = &quot;dispc_clk_parent&quot;, &quot;dispc_dbi_clk_parent&quot;, &quot;dispc_dpi_clk_parent&quot;, &quot;dispc_emc_clk_parent&quot;, &quot;dispc_clk&quot;, &quot;dispc_dbi_clk&quot;, &quot;dispc_dpi_clk&quot;, &quot;dispc_emc_clk&quot;, &quot;fb_spi_clock&quot;, &quot;fb_spi_clock_parent&quot;;
    clocks = &lt;&amp;clk_256m&gt;, &lt;&amp;clk_256m&gt;, &lt;&amp;clk_384m&gt;, &lt;&amp;clk_aon_apb&gt;, &lt;&amp;clk_dispc0&gt;, &lt;&amp;clk_dispc0_dbi&gt;, &lt;&amp;clk_dispc0_dpi&gt;, &lt;&amp;clk_disp_emc&gt;, &lt;&amp;clk_spi2&gt;, &lt;&amp;ext_26m&gt;;
    clock-src = &lt;256000000 256000000 384000000&gt;;
    dpi_clk_div = &lt;7&gt;;
    sprd,fb_use_reservemem;
    sprd,fb_mem = &lt;0x9F311000 0x5EF000&gt;;
};</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">与之相匹配的lcd控制器驱动位于 `drivers/video/sprdfb/sprdfb_main.c`，当设备节点device_node被解析为platform_device注册到系统时，会和这个驱动进行匹配。</span><br></pre></td></tr></table></figure>

<p>#ifdef CONFIG_OF<br>static const struct of_device_id sprdfb_dt_ids[] = {<br>        { .compatible = “sprd,sprdfb”, },<br>        {}<br>};</p>
<p>#endif<br>static struct platform_driver sprdfb_driver = {<br>        .probe = sprdfb_probe,</p>
<p>#ifndef CONFIG_HAS_EARLYSUSPEND<br>        .suspend = sprdfb_suspend,<br>        .resume = sprdfb_resume,</p>
<p>#endif<br>        .remove = sprdfb_remove,<br>        .driver = {<br>                .name = “sprd_fb”,<br>                .owner = THIS_MODULE,</p>
<p>#ifdef CONFIG_OF<br>                .of_match_table = of_match_ptr(sprdfb_dt_ids),</p>
<p>#endif<br>        },<br>};<br>static int __init sprdfb_init(void)<br>{<br>        return platform_driver_register(&amp;sprdfb_driver);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">基本匹配流程如下图：</span><br><span class="line">![sprd kernel lcd probe](../images/sprd_kernel_lcd_init.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**sprdfb_probe** 函数的定义</span><br></pre></td></tr></table></figure>

<p>static int sprdfb_probe(struct platform_device *pdev)<br>{<br>    struct fb_info *fb = NULL;<br>    struct sprdfb_device *dev = NULL;<br>    struct resource r;</p>
<pre><code>fb = framebuffer_alloc(sizeof(struct sprdfb_device), &amp;pdev-&gt;dev);    //(1)分布帧缓冲使用空间
dev = fb-&gt;par;
dev-&gt;fb = fb;</code></pre><p>#ifdef CONFIG_OF<br>    dev-&gt;of_dev = &amp;(pdev-&gt;dev);<br>    dev-&gt;dev_id = of_alias_get_id(pdev-&gt;dev.of_node, “lcd”);    //(2)读取设备树中lcd id<br>    printk(“sprdfb: [%s] id = %d\n”, <strong>FUNCTION</strong>, dev-&gt;dev_id);</p>
<p>#else<br>    dev-&gt;dev_id = pdev-&gt;id;</p>
<p>#endif<br>    switch(SPRDFB_IN_DATA_TYPE){<br>    case SPRD_IN_DATA_TYPE_ABGR888:<br>        dev-&gt;bpp = 32;<br>        break;<br>    case SPRD_IN_DATA_TYPE_BGR565:<br>        dev-&gt;bpp = 16;<br>        break;<br>    default:<br>        dev-&gt;bpp = 32;<br>        break;<br>    }<br>    if(SPRDFB_MAINLCD_ID == dev-&gt;dev_id){    //确认是主屏显示<br>        dev-&gt;ctrl = &sprdfb_dispc_ctrl;    //(3) </p>
<p>#ifdef CONFIG_OF<br>        if(0 != of_address_to_resource(pdev-&gt;dev.of_node, 0, &amp;r)){    //(4)<br>            printk(KERN_ERR “sprdfb: sprdfb_probe fail. (can’t get register base address)\n”);<br>            goto err0;<br>        }<br>        g_dispc_base_addr = r.start;<br>        printk(“sprdfb: set g_dispc_base_addr = 0x%x\n”, g_dispc_base_addr);</p>
<p>#endif<br>    dev-&gt;logo_buffer_addr_v = 0;<br>    if(sprdfb_panel_get(dev)){    //(5)<br>        dev-&gt;panel_ready = true;<br>        dev-&gt;ctrl-&gt;logo_proc(dev);  //(6)<br>    }else{<br>        dev-&gt;panel_ready = false;<br>    }<br>    dev-&gt;ctrl-&gt;early_init(dev); //(7)<br>    if(!dev-&gt;panel_ready){<br>        if (!sprdfb_panel_probe(dev)) {<br>            ret = -EIO;<br>            goto cleanup;<br>        }<br>    }<br>    ret = setup_fb_mem(dev, pdev);  //(8)<br>    setup_fb_info(dev); //(9)<br>    /* register framebuffer device */<br>    ret = register_framebuffer(fb); //(10)<br>    platform_set_drvdata(pdev, dev);<br>    sprdfb_create_sysfs(dev);<br>    dev-&gt;ctrl-&gt;init(dev);   //(11)<br>    return 0;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (1) 为lcd控制器分配 framebuffer 结构体 fb_info；</span><br><span class="line"></span><br><span class="line">- (2) 读取设备树中lcd id，从前面设备树的信息lcd0来看，id = 0；</span><br><span class="line"></span><br><span class="line">- (3) `sprdfb_dispc_ctrl` 保存为Soc显示控制器的操作接口；</span><br><span class="line"></span><br><span class="line">- (4) 获取设备树中配置的寄存器地址信息</span><br><span class="line"></span><br><span class="line">- (5) `sprdfb_panel_get` 会去遍历模组链表 `panel_list_main` 中 panel_cfg，将lcd_id 和 uboot中读取的模组芯片id进行对比，如果匹配则返回对应的panel_cfg；</span><br><span class="line"></span><br><span class="line">- (6) `sprdfb_dispc_logo_proc` 按照panel_cfg的尺寸申请缓存区，并从uboot lcd_base中拷贝logo数据，然后调用 `sprdfb_dispc_refresh_logo` 操作控制器寄存器刷新logo；</span><br></pre></td></tr></table></figure>

<p>void sprdfb_dispc_logo_proc(struct sprdfb_device *dev)<br>{<br>    uint32_t kernel_fb_size = 0;<br>    uint32_t logo_src_v = 0;<br>    uint32_t logo_dst_v = 0;//use the second frame buffer    ,virtual<br>    uint32_t logo_dst_p = 0;//use the second frame buffer ,physical<br>    uint32_t logo_size = 0;// should be rgb565</p>
<pre><code>if(dev == NULL) {
    printk(&quot;sprdfb: %s[%d]: dev == NULL, return without process logo!!\n&quot;,__func__,__LINE__);
    return;
}

if(lcd_base_from_uboot == 0) {
    printk(&quot;sprdfb: %s[%d]: lcd_base_from_uboot == 0, return without process logo!!\n&quot;,__func__,__LINE__);
    return;
}
if(SPRDFB_PANEL_IF_DPI != dev-&gt;panel_if_type)
    return;

logo_size = dev-&gt;panel-&gt;width * dev-&gt;panel-&gt;height * 2;// should be rgb565

dev-&gt;logo_buffer_size = logo_size;
dev-&gt;logo_buffer_addr_v = __get_free_pages(GFP_ATOMIC | __GFP_ZERO , get_order(logo_size));

logo_dst_v = dev-&gt;logo_buffer_addr_v;
logo_dst_p = __pa(dev-&gt;logo_buffer_addr_v);

logo_src_v =  (uint32_t)ioremap(lcd_base_from_uboot, logo_size);

memcpy(logo_dst_v, logo_src_v, logo_size);
dma_sync_single_for_device(dev, logo_dst_p, logo_size, DMA_TO_DEVICE);

iounmap(logo_src_v);

dispc_write(logo_dst_p, DISPC_OSD_BASE_ADDR);
sprdfb_dispc_refresh_logo(dev);    </code></pre><p>}</p>
<p>static int32_t sprdfb_dispc_refresh_logo (struct sprdfb_device *dev)<br>{<br>    dispc_clear_bits(0x1f, DISPC_INT_EN);//disable all interrupt<br>    dispc_set_bits(0x1f, DISPC_INT_CLR);// clear all interruption<br>    dispc_set_bits(BIT(5), DISPC_DPI_CTRL);//update</p>
<p>//wait for update- done interruption<br>    for(i=0; i&lt;500; i++) {<br>        if(!(dispc_read(DISPC_INT_RAW) &amp; (0x10))){<br>            udelay(1000);<br>        } else {<br>                break;<br>        }<br>    }<br>    if(i &gt;= 500) {<br>        printk(“sprdfb: [%s] wait dispc done int time out!! (0x%x)\n”, <strong>func</strong>, dispc_read(DISPC_INT_RAW));<br>    }<br>    dispc_set_bits((1&lt;&lt;5), DISPC_INT_CLR);<br>    return 0;<br>}</p>
<pre><code>- (7) `sprdfb_lcdc_early_init` 



 2. kernel 代码结构(不涉及代码详细流程)
按照比较统一的观点是，lcd 在kernel里面的处理分为 framebuffer file ops 、framebuffer driver、lcd driver。这三部分依次形成调用关系。
但是按照个人观点，在以上三部分中，应该还有个panel，它介于framebuffer 和 具体lcd驱动代码之间,属于一个接口过渡层。
(1) framebuffer file ops
 该部分代码位于7731_5.1/kernel/drivers/video/fbmem.c 文件中。
 它的作用就是向VFS层提供文件操作接口，实现 struct file_operations 结构体。换句话说，就是向用户空间提供framebuffer 驱动操作接口。
 当然，也是必须的，它肯定会调用framebuffer 驱动的一些接口。
 至于怎么调，一方面是通过hook的方式，一方面也会使用 file_fb_info()这个接口
 1     static const struct file_operations fb_fops = {
 2     .owner =    THIS_MODULE,
 3     .read =        fb_read,
 4     .write =    fb_write,
 5     .unlocked_ioctl = fb_ioctl,
 6     #ifdef CONFIG_COMPAT
 7     .compat_ioctl = fb_compat_ioctl,
 8     #endif
 9     .mmap =        fb_mmap,
10     .open =        fb_open,
11     .release =    fb_release,
12     #ifdef HAVE_ARCH_FB_UNMAPPED_AREA
13     .get_unmapped_area = get_fb_unmapped_area,
14     #endif
15     #ifdef CONFIG_FB_DEFERRED_IO
16     .fsync =    fb_deferred_io_fsync,
17     #endif
18     .llseek =    default_llseek,
19     };
 (2) framebuffer 驱动
该部分代码位于7731_5.1/kernel/drivers/video/sprdfb/sprdfb_main.c文件中，其中 sprdfb_probe() 探针函数是最关键的。
这是LCD 的一个核心，一切的实现都在这里开始。向上，给fb_fops提供调用，以便实现用户接口；向下，通过lcd panel，操作具体的硬件。
总结下展讯该探针函数大概的处理:
 1 static int sprdfb_probe(struct platform_device *pdev)
 2 {
 3     struct fb_info *fb = NULL;
 4     
 5     //分配帧缓冲使用的内存空间
 6     fb = framebuffer_alloc(sizeof(struct sprdfb_device), &amp;pdev-&gt;dev);
 7     
 8     //...
 9     
10     //检查设备ID
11     if((SPRDFB_MAINLCD_ID != dev-&gt;dev_id) &amp;&amp;(SPRDFB_SUBLCD_ID != dev-&gt;dev_id)){
12         //...
13     }
14     
15     //LCD 硬件主控制操作函数 control ops
16     if(SPRDFB_MAINLCD_ID == dev-&gt;dev_id) {
17         dev-&gt;ctrl = &amp;sprdfb_dispc_ctrl;
18     }else {
19         dev-&gt;ctrl = &amp;sprdfb_lcdc_ctrl;
20     }
21     
22     //设置/获取 帧缓冲区mem各种参数 --LCD 硬件上固定的参数 ?
23     ret = setup_fb_mem(dev, pdev);
24     
25     //帧缓冲区显示参数的设置 ---用户可修改的参数 ? 
26     setup_fb_info(dev);    
27 
28     //注册帧缓冲区到系统
29     ret = register_framebuffer(fb);
30     
31     //利用帧缓冲的资源初始化平台驱动结构体
32     platform_set_drvdata(pdev, dev);
33     
34     //创建sysfs 文件系统
35     sprdfb_create_sysfs(dev);
36         
37     //对LCD控制器硬件的初始化
38     dev-&gt;ctrl-&gt;init(dev);
39 
40     //注册睡眠唤醒机制
41     register_early_suspend(&amp;dev-&gt;early_suspend);
42     
43     //....
44     
45     return 0;
46 }
 以上需要关注的是：
Control ops： 会牵涉到底层硬件操作接口的调用(想了想，硬件操作接口操作和硬件操作，还是选择了前者。硬件的的操作，是lcd 驱动去做的)
lcd 硬件固定参数： 这个是lcd的物理尺寸，无法更改的。
lcd 可修改参数： 这个可修改是在硬件物理尺寸的基础上来操作的。比如一张图片的大小，或者显示的范围(不一定准确，大概意思差不多).
 (3) lcd panel过渡层
该部分代码位于7731_5.1/kernel/drivers/video/sprdfb/sprdfb_panel.c 文件中。
主要介于framebuffer 和 具体的lcd 具体驱动之间。可以简单的看做，是具体lcd 驱动的一个封装，然后把这些封装提供给framebuffer层使用。
我之所以叫它为过渡层，是因为这里纯粹就是一些函数接口的封装，不涉及kernel的模块机制。也就是不会modue_init到编译链接脚本。
以下是该过渡层提供给lcd驱动和framebuffer驱动的接口列表：
 1 //每一个LCD 驱动，都通过该接口加入到一个驱动链表里(这里是仅仅向系统加入一个驱动，不会去匹配硬件的，匹配硬件的操作是在framebuffer 驱动里面完成的)
 2 //换句话说，该接口就是具体的LCD 驱动调用，比如在 ili9806e 的lcd 驱动文件 lcd_ili9806e_mipi.c 会调用该接口
 3 int sprdfb_panel_register(struct panel_cfg *cfg); 
 4 
 5 //移除一个lcd 驱动
 6 //这里的移除，并非是把一个LCD驱动从链表移除，而是进行一种disable的操作
 7 //该接口将被 sprdfb_remove @drivers/video/sprdfb/sprdfb_main.c 调用
 8 void sprdfb_panel_remove(struct sprdfb_device *dev);
 9 
10 
11 
12 //唤醒接口，与lcd 睡眠唤醒机制相关
13 //在 sprdfb_dispc_resume@drivers/video/sprdfb/Sprdfb_dispc.c 以及 sprdfb_lcdc_resume@drivers/video/sprdfb/Sprdfb_lcdc.c 里被调用
14 void sprdfb_panel_resume(struct sprdfb_device *dev, bool from_deep_sleep);
15 
16 //睡眠接口，与lcd 睡眠唤醒机制相关
17 //在sprdfb_dispc_suspend@drivers/video/sprdfb/Sprdfb_dispc.c 以及 sprdfb_lcdc_suspend@drivers/video/sprdfb/Sprdfb_lcdc.c 里被调用
18 void sprdfb_panel_suspend(struct sprdfb_device *dev);
19 
20 
21 //检查ESD硬件接口, 在framebuffer 里使用， @drivers/video/sprdfb/sprdfb_main.c
22 uint32_t sprdfb_panel_ESD_check(struct sprdfb_device *dev);
23 
24 //改变fps，在sprdfb_dispc_chg_clk@drivers/video/sprdfb/Sprdfb_dispc.c 里使用
25 void sprdfb_panel_change_fps(struct sprdfb_device *dev, int fps_level);
26 
27 
28 //以下4个接口与图形刷新有关系，在drivers/video/sprdfb/Sprdfb_dispc.c 和 drivers/video/sprdfb/Sprdfb_lcdc.c 都会使用到
29 void sprdfb_panel_after_refresh(struct sprdfb_device *dev);
30 void sprdfb_panel_before_refresh(struct sprdfb_device *dev);
31 void sprdfb_panel_invalidate(struct panel_spec *self);
32 void sprdfb_panel_invalidate_rect(struct panel_spec *self,uint16_t left, uint16_t top, uint16_t right, uint16_t bottom);
33 
34 
35 //注册framebuffer驱动之前，会检查kernel里面的device ID 和 uboot里面传上来的device ID 是否相同。若不相同，则需要调用该接口，重新准备lcd panel 层
36 //sprdfb_probe@drivers/video/sprdfb/sprdfb_main.c 调用
37 bool sprdfb_panel_probe(struct sprdfb_device *dev); //static struct panel_spec *adapt_panel_from_readid(struct sprdfb_device *dev);
38 //匹配kernel中device ID 和 uboot里面传上来的device ID。如果匹配失败，则会导致前面 sprdfb_panel_probe() 接口被调用
39 //sprdfb_probe@drivers/video/sprdfb/sprdfb_main.c 调用
40 bool sprdfb_panel_get(struct sprdfb_device *dev);  //static struct panel_spec *adapt_panel_from_uboot(uint16_t dev_id);
41 
42 
43 //检查lcd panel 是否有效
44 int panel_ready(struct sprdfb_device *dev);
(4) lcd 驱动
这一层，就完全是同lcd硬件打交道了。那么，不同厂商不同型号的lcd，其驱动代码处理细节都是不同的。当然，处理流程肯定是一样的。
这些代码展讯都放在了 7731_5.1/kernel/drivers/video/sprdfb/lcd/ 的目录下。至于如何添加新屏，前面已经详细写过。
每个lcd的驱动，都会通过lcd panel层提供的sprdfb_panel_register()接口，把自己添加到一个panel_list_main 或者 panel_list_sub链表中去。至于细节，暂未分析。
第三，用户空间对framebuffer 驱动的调用
framebuffer驱动已经通过fb_ops 向用户空间提供了文件操作接口。
如果愿意，可以直接使用UNIX的文件编程接口 open/read/write/ioctl也行。当然，对于android这样如此复杂的系统，简单的这样操作，就只有实验价值而已。并且，这里的接口还涉及到c/c++与java的本地交互。实现一个操作库的可行性更高。
在Android里面，提供了一个操作framebuffer 驱动的库，名字叫 gralloc。其最终实现，当然还是会使用open等基础接口，不过其架构、效率、机制都非常的优秀。
在这里，有一个高大上的名字：HAL层。
1. gralloc 库
(1) 基础说明
该部分文件一般放在了 7731_5.1/hardware/libhardware/modules/gralloc/ 目录下。不过展讯在 vendor/sprd/open-source/libs/gralloc/ 目录下又搞了一份。
该库经过编译后，会生成一个动态的 gralloc.default.so 库文件，该库文件会放在 system/lib/hw/ 目录下，系统会通过特定的函数去读取该.so 并提出相应的信息。展讯的名字叫： gralloc.sc8830.so
以上.so文件放置的路径以及.so文件的名字，都可以通过 7731_5.1/hardware/libhardware/modules/gralloc/Android.mk (展讯: 7731_5.1/vendor/sprd/open-source/libs/gralloc/utgard/Android.mk)进行修改。
1 #指定.so 放置的路径
2 LOCAL_MODULE_RELATIVE_PATH := hw 
3 
4 #生成.so模块的名字
5 LOCAL_MODULE := gralloc.default
 (2) gralloc 代码入口:
7731_5.1/hardware/libhardware/modules/gralloc/gralloc.cpp 是gralloc 库的核心文件。
入口: HAL_MODULE_INFO_SYM 是每个HAL模块都必须实现的一个宏，其中最重要的就是base成员。在这里定义了获取module、注册、注销、锁定缓冲区的操作接口。
模块ID: GRALLOC_HARDWARE_MODULE_ID 通过此ID来标示该模块.
关键性的函数接口: gralloc_device_open();
2. 调用 gralloc 模块
调用gralloc 库的地方比较多：
1 7731_5.1/frameworks/native/libs/ui/GraphicBufferAllocator.cpp
2 7731_5.1/frameworks/native/libs/ui/GraphicBufferMapper.cpp
3 7731_5.1/frameworks/native/libs/ui/FramebufferNativeWindow.cpp
4 7731_5.1/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
5 7731_5.1/frameworks/native/opengl/libagl/egl.cpp
6 7731_5.1/frameworks/native/opengl/libagl/texture.cpp
7 ....
 但是都会通过一个统一的接口来调用: hw_get_module()@hardware/libhardware/hardware.c
所有的HAL调用，应该都是使用该接口。而对于各模块的区别，就是使用模块ID来区别的，比如: GRALLOC_HARDWARE_MODULE_ID

</code></pre>
    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/lcd/" rel="tag"># lcd</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/30/terminal-for-microcontrol/" rel="next" title="terminal for microcontrol">
                  <i class="fa fa-chevron-left"></i> terminal for microcontrol
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/11/10/test/" rel="prev" title="test">
                  test <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#显示控制器"><span class="nav-number">1.</span> <span class="nav-text">显示控制器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uboot"><span class="nav-number">2.</span> <span class="nav-text">uboot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、lcd-模组配置"><span class="nav-number">2.1.</span> <span class="nav-text">一、lcd 模组配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、lcd-模组初始化流程"><span class="nav-number">2.2.</span> <span class="nav-text">二、lcd 模组初始化流程</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tinylaker</p>
  <div class="site-description" itemprop="description">个人学习总结</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/tinylaker" title="GitHub &rarr; https://github.com/tinylaker" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:xyxujinlong@163.com" title="E-Mail &rarr; mailto:xyxujinlong@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tinylaker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
