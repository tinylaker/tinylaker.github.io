<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://tinylaker.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="在谈及 Android GUI 框架前，先从底层视角梳理一下显示的流程。在 Android 系统中，引入了状态栏、导航栏、壁纸和背景的图层概念，需要把这些图层进行 alpha blending 后显示。 在嵌入式 linux 系统下显示界面，可以直接操作 framebuffer 的内存；但 Android 应用并不能直接操作 framebuffer，应用需要借助 SurfaceFlinger。 S">
<meta name="keywords" content="GUI">
<meta property="og:type" content="article">
<meta property="og:title" content="Android GUI框架简介">
<meta property="og:url" content="http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/index.html">
<meta property="og:site_name" content="Tinylaker blog">
<meta property="og:description" content="在谈及 Android GUI 框架前，先从底层视角梳理一下显示的流程。在 Android 系统中，引入了状态栏、导航栏、壁纸和背景的图层概念，需要把这些图层进行 alpha blending 后显示。 在嵌入式 linux 系统下显示界面，可以直接操作 framebuffer 的内存；但 Android 应用并不能直接操作 framebuffer，应用需要借助 SurfaceFlinger。 S">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/surface.png">
<meta property="og:image" content="http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/BufferQueue.png">
<meta property="og:updated_time" content="2019-12-05T13:41:21.740Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android GUI框架简介">
<meta name="twitter:description" content="在谈及 Android GUI 框架前，先从底层视角梳理一下显示的流程。在 Android 系统中，引入了状态栏、导航栏、壁纸和背景的图层概念，需要把这些图层进行 alpha blending 后显示。 在嵌入式 linux 系统下显示界面，可以直接操作 framebuffer 的内存；但 Android 应用并不能直接操作 framebuffer，应用需要借助 SurfaceFlinger。 S">
<meta name="twitter:image" content="http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/surface.png">

<link rel="canonical" href="http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Android GUI框架简介 | Tinylaker blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ddfa4a6ba83ff65311f95d251f9389b3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tinylaker blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">stay hungry stay foolish</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tinylaker">
      <meta itemprop="description" content="个人学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tinylaker blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android GUI框架简介
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-11 20:28:05" itemprop="dateCreated datePublished" datetime="2019-11-11T20:28:05+08:00">2019-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-05 21:41:21" itemprop="dateModified" datetime="2019-12-05T21:41:21+08:00">2019-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>46k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在谈及 Android GUI 框架前，先从底层视角梳理一下显示的流程。在 Android 系统中，引入了状态栏、导航栏、壁纸和背景的图层概念，需要把这些图层进行 alpha blending 后显示。</p>
<p>在嵌入式 linux 系统下显示界面，可以直接操作 framebuffer 的内存；但 Android 应用并不能直接操作 framebuffer，应用需要借助 SurfaceFlinger。</p>
<p>SurfaceFlinger 通过 Gralloc HAL 向 ashmem 申请内存，供应用使用。同时使用 OpenGL 和 HardwareComposer 来合成 Surface。</p>
<h1 id="SurfaceFlinger内部机制"><a href="#SurfaceFlinger内部机制" class="headerlink" title="SurfaceFlinger内部机制"></a>SurfaceFlinger内部机制</h1><p>可以把应用理解为客户端，SurfaceFlinger 理解为服务端，在 SurfaceFlinger 中用 Client 对象表示应用，有多少个应用就有多少个 Client 对象。</p>
<p>Client 对象中包含了 Layer 对象，用来对应应用层的 SurfaceControl ；其中 Layer 对象包含消费者 mSurfaceFlingerConsumer 和 生产者 mBufferQueue 成员变量，并在 onFirstRef() 方法中构建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceFlingerConsumer&gt; mSurfaceFlingerConsumer;</span><br><span class="line">sp&lt;BufferQueue&gt; mBufferQueue;</span><br></pre></td></tr></table></figure>

<p>与之对应的， Surface 对象中包含生产者 mGraphicBufferProducer 和 BufferSlot ，后者是 Surface 内部存储 buffer 的地方，最多有32个，仅当 dequeueBuffer 时才会分配真正的空间。这里基本可以看出 Surface 对象是通过 mGraphicBufferProducer 来获取 buffer ，并将它记录在 mSlots 数组中供后续使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferProducer&gt; mGraphicBufferProducer;</span><br><span class="line">BufferSlot mSlots[NUM_BUFFER_SLOTS];</span><br><span class="line"></span><br><span class="line">struct BufferSlot &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">    Region dirtyRegion;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过系统的测试用例 resize 了解应用的基本流程，追踪代码分析 SurfaceFlinger 的工作方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/tests/resize/resize.cpp</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    // set up the thread-pool</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    // create a client to surfaceflinger</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient(); //&lt;1&gt;</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;createSurface(String8(&quot;resize&quot;), 160, 240, PIXEL_FORMAT_RGB_565, 0);    //&lt;2&gt;</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; surface = surfaceControl-&gt;getSurface(); //&lt;3&gt;</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    surfaceControl-&gt;setLayer(100000);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    surface-&gt;lock(&amp;outBuffer, NULL);    //&lt;4&gt;</span><br><span class="line">    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    android_memset16((uint16_t*)outBuffer.bits, 0xF800, bpr*outBuffer.height);</span><br><span class="line">    surface-&gt;unlockAndPost();   &lt;5&gt;</span><br><span class="line"></span><br><span class="line">    surface-&gt;lock(&amp;outBuffer);</span><br><span class="line">    android_memset16((uint16_t*)outBuffer.bits, 0x07E0, bpr*outBuffer.height);</span><br><span class="line">    surface-&gt;unlockAndPost();</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    surfaceControl-&gt;setSize(320, 240);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的流程图如下：</p>
<p><img src="//tinylaker.github.io/2019/11/11/Android-GUI框架简介/surface.png" alt="SurfaceFlinger"></p>
<h2 id="SurfaceComposerClient"><a href="#SurfaceComposerClient" class="headerlink" title="SurfaceComposerClient"></a>SurfaceComposerClient</h2><p>当应用程序请求 SurfaceFlinger 服务时，首先需要构造 SurfaceComposerClient 对象，通过 SurfaceComposerClient 对象访问 SurfaceFlinger 服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/include/gui/SurfaceComposerClient.h</span><br><span class="line"></span><br><span class="line">class SurfaceComposerClient : public RefBase</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    virtual void onFirstRef();</span><br><span class="line">    Composer&amp; getComposer();</span><br><span class="line"></span><br><span class="line">    mutable     Mutex                       mLock;</span><br><span class="line">                status_t                    mStatus;</span><br><span class="line">                sp&lt;ISurfaceComposerClient&gt;  mClient;</span><br><span class="line">                Composer&amp;                   mComposer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 SurfaceComposerClient 继承于 RefBase 类，在创建 SurfaceComposerClient 对象后，第一次引用对象时，调用 onFirstRef() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">    : mStatus(NO_INIT), mComposer(Composer::getInstance())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line">    //获取 BpSurfaceComposer 的实例化对象</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());</span><br><span class="line">    if (sm != 0) &#123;</span><br><span class="line">        //获取 BpSurfaceComposerClient 实例化对象</span><br><span class="line">        sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">        if (conn != 0) &#123;</span><br><span class="line">            mClient = conn;</span><br><span class="line">            mStatus = NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onFirstRef() 方法首先调用 ComposerService 类的 getComposerService() 方法获取 SurfaceFlinger 的代理对象 BpSurfaceComposer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">/*static*/ sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();</span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    if (instance.mComposerService == NULL) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != NULL);</span><br><span class="line">        ALOGD(&quot;ComposerService reconnected&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance.mComposerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过单例模式调用 getInstance() 方法构造 ComposerService 对象，期间会调用 connectLocked() 方法获取 BpServiceComposer 服务的代理对象 ，并保存到成员变量 mComposerService 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">ANDROID_SINGLETON_STATIC_INSTANCE(ComposerService);</span><br><span class="line"></span><br><span class="line">ComposerService::ComposerService()</span><br><span class="line">: Singleton&lt;ComposerService&gt;() &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    connectLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ComposerService::connectLocked() &#123;</span><br><span class="line">    const String16 name(&quot;SurfaceFlinger&quot;);</span><br><span class="line">    while (getService(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        usleep(250000);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(mComposerService != NULL);</span><br><span class="line"></span><br><span class="line">    // Create the death listener.</span><br><span class="line">    class DeathObserver : public IBinder::DeathRecipient &#123;</span><br><span class="line">        ComposerService&amp; mComposerService;</span><br><span class="line">        virtual void binderDied(const wp&lt;IBinder&gt;&amp; who) &#123;</span><br><span class="line">            ALOGW(&quot;ComposerService remote (surfaceflinger) died [%p]&quot;,</span><br><span class="line">                  who.unsafe_get());</span><br><span class="line">            mComposerService.composerServiceDied();</span><br><span class="line">        &#125;</span><br><span class="line">     public:</span><br><span class="line">        DeathObserver(ComposerService&amp; mgr) : mComposerService(mgr) &#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mDeathObserver = new DeathObserver(*const_cast&lt;ComposerService*&gt;(this));</span><br><span class="line">    mComposerService-&gt;asBinder()-&gt;linkToDeath(mDeathObserver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面已经获取到 BpSurfaceComposer 对象，调用它的 createConnection() 方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="line"></span><br><span class="line">class BpSurfaceComposer : public BpInterface&lt;ISurfaceComposer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BpSurfaceComposer(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;ISurfaceComposer&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">virtual sp&lt;ISurfaceComposerClient&gt; createConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        uint32_t n;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(BnSurfaceComposer::CREATE_CONNECTION, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;ISurfaceComposerClient&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createConnection() 方法中调用 <code>remote()-&gt;transact</code> 会导致 SurfaceFlinger 类的 onTransact()方法被调用，进而调用 BnSurfaceComposer::onTransact() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case CREATE_CONNECTION:</span><br><span class="line">        case CREATE_DISPLAY:</span><br><span class="line">        case SET_TRANSACTION_STATE:</span><br><span class="line">        case BOOT_FINISHED:</span><br><span class="line">        case BLANK:</span><br><span class="line">        case UNBLANK:</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = BnSurfaceComposer::onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="line"></span><br><span class="line">status_t BnSurfaceComposer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_CONNECTION: &#123;</span><br><span class="line">            CHECK_INTERFACE(ISurfaceComposer, data, reply);</span><br><span class="line">            sp&lt;IBinder&gt; b = createConnection()-&gt;asBinder();</span><br><span class="line">            reply-&gt;writeStrongBinder(b);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        default: &#123;</span><br><span class="line">            return BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceFlinger 继承 BnSurfaceComposer，作为 Binder 的服务端，复写了 createConnection()方法，该方法会构造 Client 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.h</span><br><span class="line"></span><br><span class="line">class SurfaceFlinger : public BnSurfaceComposer,</span><br><span class="line">                        private IBinder::DeathRecipient,</span><br><span class="line">                        private HWComposer::EventHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/include/gui/ISurfaceComposer.h</span><br><span class="line"></span><br><span class="line">class BnSurfaceComposer: public BnInterface&lt;ISurfaceComposer&gt;                        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line">    sp&lt;Client&gt; client(new Client(this));</span><br><span class="line">    status_t err = client-&gt;initCheck();</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        bclient = client;</span><br><span class="line">    &#125;</span><br><span class="line">    return bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client 继承 BnSurfaceComposerClient ，保存 SurfaceFlinger 对象的引用到成员变量 mFlinger。最终应用程序通过 <code>ISurfaceComposer::createConnection()</code> 方法获得 BpSurfaceComposerClient 代理对象，并将其保存在成员变量 mClient 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"></span><br><span class="line">Client::Client(const sp&lt;SurfaceFlinger&gt;&amp; flinger)</span><br><span class="line">    : mFlinger(flinger)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：应用程序创建 SurfaceFlinger Client，需要首先获取 SurfaceFlinger 服务，通过 SurfaceFlinger::createConnection() 方法建立应用程序和 SurfaceFlinger 的连接。SurfaceFlinger 会创建一个 BnSurfaceComposerClient 本地对象，同时应用程序会得到一个 BpSurfaceComposerClient 代理类对象，后面会通过这个代理类对象创建 Surface。</p>
<h2 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a>SurfaceControl</h2><p>根据 SurfaceComposerClient 对象创建 SurfafeControl 对象，其实就是通过 SurfaceFlinger 创建 Layer，下面分析代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        uint32_t w,</span><br><span class="line">        uint32_t h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    if (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">        status_t err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">                &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, &quot;SurfaceComposerClient::createSurface error %s&quot;, strerror(-err));</span><br><span class="line">        if (err == NO_ERROR) &#123;</span><br><span class="line">            sur = new SurfaceControl(this, handle, gbp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remote()-&gt;transact</code> 根据 Binder 机制，调用 BnSurfaceComposerClient::onTransact() 本地方法，进而调用到 Client::createSurface() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ISurfaceComposerClient.cpp</span><br><span class="line"></span><br><span class="line">class BpSurfaceComposerClient : public BpInterface&lt;ISurfaceComposerClient&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    virtual status_t createSurface(const String8&amp; name, uint32_t w,</span><br><span class="line">                uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp) &#123;</span><br><span class="line">          Parcel data, reply;</span><br><span class="line">          data.writeInterfaceToken(ISurfaceComposerClient::getInterfaceDescriptor());</span><br><span class="line">          data.writeString8(name);</span><br><span class="line">          data.writeInt32(w);</span><br><span class="line">          data.writeInt32(h);</span><br><span class="line">          data.writeInt32(format);</span><br><span class="line">          data.writeInt32(flags);</span><br><span class="line">          remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">          *handle = reply.readStrongBinder();</span><br><span class="line">          *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">          return reply.readInt32();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BnSurfaceComposerClient::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_SURFACE: &#123;</span><br><span class="line">            CHECK_INTERFACE(ISurfaceComposerClient, data, reply);</span><br><span class="line">            String8 name = data.readString8();</span><br><span class="line">            uint32_t w = data.readInt32();</span><br><span class="line">            uint32_t h = data.readInt32();</span><br><span class="line">            PixelFormat format = data.readInt32();</span><br><span class="line">            uint32_t flags = data.readInt32();</span><br><span class="line">            sp&lt;IBinder&gt; handle;</span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">            status_t result = createSurface(name, w, h, format, flags,</span><br><span class="line">                    &amp;handle, &amp;gbp);</span><br><span class="line">            reply-&gt;writeStrongBinder(handle);</span><br><span class="line">            reply-&gt;writeStrongBinder(gbp-&gt;asBinder());</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createSurface() 方法定义了一个消息类 MessageCreateLayer ，然后把它的对象通过 postMessageSync() 方法发送出去，这个消息是以同步的方式发送，因此函数结束后可以直接返回结果。所以会调用到消息处理方法 handler()，直接调用 <code>SurfaceFlinger::createLayer()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"></span><br><span class="line">status_t Client::createSurface(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    class MessageCreateLayer : public MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        status_t result;</span><br><span class="line">        const String8&amp; name;</span><br><span class="line">        uint32_t w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">    public:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                const String8&amp; name, Client* client,</span><br><span class="line">                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">            handle(handle), gbp(gbp),</span><br><span class="line">            name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        status_t getResult() const &#123; return result; &#125;</span><br><span class="line">        virtual bool handler() &#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, this, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createLayer() 方法根据 flags 参数选择创建不同类型的 Layer ( NormalLayer 和 DimLayer )，这里以 createNormalLayer 为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::createLayer(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    //ALOGD(&quot;createLayer for (%d x %d), name=%s&quot;, w, h, name.string());</span><br><span class="line">    if (int32_t(w|h) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;createLayer() failed, w or h is negative (w=%d, h=%d)&quot;,</span><br><span class="line">                int(w), int(h));</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line"></span><br><span class="line">    switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceNoDisp:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            break;</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result == NO_ERROR) &#123;</span><br><span class="line">        addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">        if(!(flags &amp; ISurfaceComposerClient::eFXSurfaceNoDisp)) &#123;</span><br><span class="line">            setTransactionFlags(eTransactionNeeded);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ALOGD(&quot;%s flags=%x&quot;, __FUNCTION__, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createNormalLayer() 方法根据 format 参数不同创建 Layer 对象 outLayer ，调用 Layer::getHandle() 方法赋值给 handle，调用 Layer::getBufferQueue() 方法赋值给 gbp 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span><br><span class="line">&#123;</span><br><span class="line">    // initialize the surfaces</span><br><span class="line">    switch (format) &#123;</span><br><span class="line">    case PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    case PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">        break;</span><br><span class="line">    case PIXEL_FORMAT_OPAQUE:</span><br><span class="line">#ifdef NO_RGBX_8888</span><br><span class="line">        format = PIXEL_FORMAT_RGB_565;</span><br><span class="line">#else</span><br><span class="line">        format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">#endif</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef NO_RGBX_8888</span><br><span class="line">    if (format == PIXEL_FORMAT_RGBX_8888)</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    *outLayer = new Layer(this, client, name, w, h, flags);</span><br><span class="line">    status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">        *gbp = (*outLayer)-&gt;getBufferQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE_IF(err, &quot;createNormalLayer() failed (%s)&quot;, strerror(-err));</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下 Layer 类的构造方法和 onFirstRef() 方法的实现，这里会构造图像缓冲区队列 BufferQueue ，同时创建消费者对象 SurfaceFlingerConsumer 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Layer::Layer(SurfaceFlinger* flinger, const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags)</span><br><span class="line">    :   contentDirty(false),</span><br><span class="line">        sequence(uint32_t(android_atomic_inc(&amp;sSequence))),</span><br><span class="line">        mFlinger(flinger),</span><br><span class="line">        mTextureName(-1U),</span><br><span class="line">        mPremultipliedAlpha(true),</span><br><span class="line">        mName(&quot;unnamed&quot;),</span><br><span class="line">        mDebug(false),</span><br><span class="line">        mFormat(PIXEL_FORMAT_NONE),</span><br><span class="line">        mOpaqueLayer(true),</span><br><span class="line">        mTransactionFlags(0),</span><br><span class="line">        mQueuedFrames(0),</span><br><span class="line">        mCurrentTransform(0),</span><br><span class="line">        mCurrentScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),</span><br><span class="line">        mCurrentOpacity(true),</span><br><span class="line">        mRefreshPending(false),</span><br><span class="line">        mFrameLatencyNeeded(false),</span><br><span class="line">        mFiltering(false),</span><br><span class="line">        mNeedsFiltering(false),</span><br><span class="line">        mMesh(Mesh::TRIANGLE_FAN, 4, 2, 2),</span><br><span class="line">        mSecure(false),</span><br><span class="line">        mProtectedByApp(false),</span><br><span class="line">        mHasSurface(false),</span><br><span class="line">        mClientRef(client),</span><br><span class="line">        mCaptureScreen(false)</span><br><span class="line">&#123;</span><br><span class="line">    mCurrentCrop.makeInvalid();</span><br><span class="line">    mFlinger-&gt;getRenderEngine().genTextures(1, &amp;mTextureName);</span><br><span class="line">    mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line"></span><br><span class="line">    uint32_t layerFlags = 0;</span><br><span class="line">    if (flags &amp; ISurfaceComposerClient::eHidden)</span><br><span class="line">        layerFlags = layer_state_t::eLayerHidden;</span><br><span class="line"></span><br><span class="line">    if (flags &amp; ISurfaceComposerClient::eNonPremultiplied)</span><br><span class="line">        mPremultipliedAlpha = false;</span><br><span class="line"></span><br><span class="line">    mName = name;</span><br><span class="line"></span><br><span class="line">    mCurrentState.active.w = w;</span><br><span class="line">    mCurrentState.active.h = h;</span><br><span class="line">    mCurrentState.active.crop.makeInvalid();</span><br><span class="line">    mCurrentState.z = 0;</span><br><span class="line">    mCurrentState.alpha = 0xFF;</span><br><span class="line">    mCurrentState.layerStack = 0;</span><br><span class="line">    mCurrentState.flags = layerFlags;</span><br><span class="line">    mCurrentState.sequence = 0;</span><br><span class="line">    mCurrentState.transform.set(0, 0);</span><br><span class="line">    mCurrentState.requested = mCurrentState.active;</span><br><span class="line"></span><br><span class="line">    // drawing state &amp; current state are identical</span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    nsecs_t displayPeriod =</span><br><span class="line">            flinger-&gt;getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    mFrameTracker.setDisplayRefreshPeriod(displayPeriod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Layer::onFirstRef() &#123;</span><br><span class="line">    // Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span><br><span class="line">    mBufferQueue = new SurfaceTextureLayer(mFlinger);</span><br><span class="line">    mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(mBufferQueue, mTextureName);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setFrameAvailableListener(this);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"></span><br><span class="line">#ifdef TARGET_DISABLE_TRIPLE_BUFFERING</span><br><span class="line">#warning &quot;disabling triple buffering&quot;</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(2);</span><br><span class="line">#else</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(3);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">    updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BufferQueue 是 IGraphicBufferProducer 服务端的实现，类的内部有个成员数组 <code>BufferSlot mSlots[NUM_BUFFER_SLOTS]</code>，这与 Surface 类中 BufferSlot 的定义并不一样。这里 mGraphicBuffer 用以记录 BufferSlot 的缓冲区，mBufferState 用来追踪每个缓冲区的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/include/gui/BufferQueue.h</span><br><span class="line"></span><br><span class="line">class BufferQueue : public BnGraphicBufferProducer,</span><br><span class="line">                    public BnGraphicBufferConsumer,</span><br><span class="line">                    private IBinder::DeathRecipient &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t dequeueBuffer(int *buf, sp&lt;Fence&gt;* fence, bool async,</span><br><span class="line">            uint32_t width, uint32_t height, uint32_t format, uint32_t usage);    </span><br><span class="line">    </span><br><span class="line">    virtual status_t queueBuffer(int buf,</span><br><span class="line">            const QueueBufferInput&amp; input, QueueBufferOutput* output);</span><br><span class="line">    </span><br><span class="line">    virtual void cancelBuffer(int buf, const sp&lt;Fence&gt;&amp; fence);</span><br><span class="line"></span><br><span class="line">    virtual status_t acquireBuffer(BufferItem *buffer, nsecs_t presentWhen);</span><br><span class="line"></span><br><span class="line">    virtual status_t releaseBuffer(int buf, uint64_t frameNumber,</span><br><span class="line">            EGLDisplay display, EGLSyncKHR fence,</span><br><span class="line">            const sp&lt;Fence&gt;&amp; releaseFence); </span><br><span class="line"></span><br><span class="line">    struct BufferSlot &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line">        enum BufferState &#123;</span><br><span class="line">            FREE = 0,</span><br><span class="line">            DEQUEUED = 1,</span><br><span class="line">            QUEUED = 2,</span><br><span class="line">            ACQUIRED = 3</span><br><span class="line">        &#125;;</span><br><span class="line">        BufferState mBufferState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BufferSlot mSlots[NUM_BUFFER_SLOTS];</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferAlloc&gt; mGraphicBufferAlloc;</span><br><span class="line"></span><br><span class="line">    sp&lt;IConsumerListener&gt; mConsumerListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着调用 addClientLayer() 方法，把 Layer 对象和 SurfaceFlinger 以及应用程序关联起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; gbc,</span><br><span class="line">        const sp&lt;Layer&gt;&amp; lbc)</span><br><span class="line">&#123;</span><br><span class="line">    // attach this layer to the client</span><br><span class="line">    client-&gt;attachLayer(handle, lbc);</span><br><span class="line"></span><br><span class="line">    // add this layer to the current state list</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    mCurrentState.layersSortedByZ.add(lbc);</span><br><span class="line">    mGraphicBufferProducerList.add(gbc-&gt;asBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>attachLayer() 将 handle 和 outLayer 添加到 Client::mLayers 成员变量中; SurfaceFlinger 分别使用成员变量 mCurrentState 和 mGraphicBufferProducerList 保存 outLayer 和 gbp 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"></span><br><span class="line">void Client::attachLayer(const sp&lt;IBinder&gt;&amp; handle, const sp&lt;Layer&gt;&amp; layer)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLayers.add(handle, layer);//添加到client的mLayers变量中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据前面获取的 handle 和 gbp ，构造 SurfaceControl 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceControl.cpp</span><br><span class="line"></span><br><span class="line">SurfaceControl::SurfaceControl(</span><br><span class="line">        const sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">        const sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; gbp)</span><br><span class="line">      : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：通过 SurfaceFlinger 构造 Layer ，然后创建 surfaceControl 对象。该对象有三个参数，第一个参数是 SurfaceComposerClient 代理对象；第二个参数是 handle ，表示 SurfaceControl 的唯一性；第三个参数是 gbp ,表示 Layer 对象中的 GraphicBufferProducer 的生产者代理类对象。</p>
<h2 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h2><p>通过 SurfaceControl 对象的 getSurface() 方法构造 Surface 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/SurfaceControl.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() const</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    if (mSurfaceData == 0) &#123;</span><br><span class="line">        // This surface is always consumed by SurfaceFlinger, so the</span><br><span class="line">        // producerControlledByApp value doesn&apos;t matter; using false.</span><br><span class="line">        mSurfaceData = new Surface(mGraphicBufferProducer, false);</span><br><span class="line">    &#125;</span><br><span class="line">    return mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 mGraphicBufferProducer 代理类对象构造 Surface 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Surface::Surface(</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,</span><br><span class="line">        bool controlledByApp)</span><br><span class="line">    : mGraphicBufferProducer(bufferProducer)</span><br><span class="line">&#123;</span><br><span class="line">    // Initialize the ANativeWindow function pointers.</span><br><span class="line">    ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">    ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">    ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">    ANativeWindow::query            = hook_query;</span><br><span class="line">    ANativeWindow::perform          = hook_perform;</span><br><span class="line"></span><br><span class="line">    ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;</span><br><span class="line">    ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line">    const_cast&lt;int&amp;&gt;(ANativeWindow::minSwapInterval) = 0;</span><br><span class="line">    const_cast&lt;int&amp;&gt;(ANativeWindow::maxSwapInterval) = 1;</span><br><span class="line"></span><br><span class="line">    mReqWidth = 0;</span><br><span class="line">    mReqHeight = 0;</span><br><span class="line">    mReqFormat = 0;</span><br><span class="line">    mReqUsage = 0;</span><br><span class="line">    mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;</span><br><span class="line">    mCrop.clear();</span><br><span class="line">    mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;</span><br><span class="line">    mTransform = 0;</span><br><span class="line">    mDefaultWidth = 0;</span><br><span class="line">    mDefaultHeight = 0;</span><br><span class="line">    mUserWidth = 0;</span><br><span class="line">    mUserHeight = 0;</span><br><span class="line">    mTransformHint = 0;</span><br><span class="line">    mConsumerRunningBehind = false;</span><br><span class="line">    mConnectedToCpu = false;</span><br><span class="line">    mProducerControlledByApp = controlledByApp;</span><br><span class="line">    mSwapIntervalZero = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：当应用程序构建 Surface 的时候， SurfaceFlinger 会创建对应的图层 Layer， 并且把 Layer 的图像缓冲区的生产者对象赋值给 Surface 对象的成员变量 mGraphicBufferProducer ，这样应用程序就可以通过这个生产者接口更新数据。</p>
<p>那么缓冲区的消费者呢，Layer::onFirstRef() 方法中创建 SurfaceFlingerConsumer 对象，该类间接继承于 ConsumerBase 消费者基类，所以 <code>mSurfaceFlingerConsumer-&gt;setFrameAvailableListener(this)</code> 实际等于 <code>ConsumerBase::setFrameAvailableListener(const Layer &amp;)</code> ，注册 Layer 为 Listener。</p>
<p>当缓冲区数据准备好，BufferQueue 就会调用 onFrameAvailable() 方法通知消费者，这里还涉及到很多 Binder 的流程，我们暂不关心，只看 Layer::onFrameAvailable() 方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/ConsumerBase.cpp</span><br><span class="line"></span><br><span class="line">void ConsumerBase::setFrameAvailableListener(</span><br><span class="line">        const wp&lt;FrameAvailableListener&gt;&amp; listener) &#123;</span><br><span class="line">    CB_LOGV(&quot;setFrameAvailableListener&quot;);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    mFrameAvailableListener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ConsumerBase::onFrameAvailable() &#123;</span><br><span class="line">    CB_LOGV(&quot;onFrameAvailable&quot;);</span><br><span class="line"></span><br><span class="line">    sp&lt;FrameAvailableListener&gt; listener;</span><br><span class="line">    &#123; // scope for the lock</span><br><span class="line">        Mutex::Autolock lock(mMutex);</span><br><span class="line">        listener = mFrameAvailableListener.promote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (listener != NULL) &#123;</span><br><span class="line">        CB_LOGV(&quot;actually calling onFrameAvailable&quot;);</span><br><span class="line">        listener-&gt;onFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会去调用 SurfaceFlinger::signalLayerUpdate() 方法发送图层更新消息，通过 handleMessageInvalidate() 方法处理消息，调用 handlePageFlip() 把有效缓冲区换到前台，等待 SurfaceFlinger 合成显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/services/surfaceflinger/Layer.cpp</span><br><span class="line"></span><br><span class="line">void Layer::onFrameAvailable() &#123;</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">    mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::onMessageReceived(int32_t what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    switch (what) &#123;</span><br><span class="line">    case MessageQueue::TRANSACTION:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        break;</span><br><span class="line">    case MessageQueue::INVALIDATE:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        handleMessageInvalidate();</span><br><span class="line">        signalRefresh();</span><br><span class="line">        break;</span><br><span class="line">    case MessageQueue::REFRESH:</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::handleMessageInvalidate() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    handlePageFlip();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::handlePageFlip()</span><br><span class="line">&#123;</span><br><span class="line">    Region dirtyRegion;</span><br><span class="line"></span><br><span class="line">    bool visibleRegions = false;</span><br><span class="line">    const LayerVector&amp; layers(mDrawingState.layersSortedByZ);</span><br><span class="line">    const size_t count = layers.size();</span><br><span class="line">    for (size_t i=0 ; i&lt;count ; i++) &#123;</span><br><span class="line">        const sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">        const Region dirty(layer-&gt;latchBuffer(visibleRegions));</span><br><span class="line">        const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">        invalidateLayerStack(s.layerStack, dirty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Surface-lock"><a href="#Surface-lock" class="headerlink" title="Surface::lock()"></a>Surface::lock()</h2><p>这里通过前面代码构建的 Surface，获取图像缓冲区内容，首先调用 Surface::dequeueBuffer() 方法申请  Buffer 进行应用层图像绘制。</p>
<p>BufferQueue 的流程图如下所示：</p>
<p><img src="//tinylaker.github.io/2019/11/11/Android-GUI框架简介/BufferQueue.png" alt="BufferQueue"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/Surface.cpp</span><br><span class="line"></span><br><span class="line">status_t Surface::lock(</span><br><span class="line">        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">&#123;</span><br><span class="line">    if (!mConnectedToCpu) &#123;</span><br><span class="line">        int err = Surface::connect(NATIVE_WINDOW_API_CPU);</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">        // we&apos;re intending to do software rendering from this point</span><br><span class="line">        setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ANativeWindowBuffer* out;</span><br><span class="line">    int fenceFd = -1;</span><br><span class="line">    status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));</span><br><span class="line">        sp&lt;Fence&gt; fence(new Fence(fenceFd));</span><br><span class="line"></span><br><span class="line">        err = fence-&gt;waitForever(&quot;Surface::lock&quot;);</span><br><span class="line">    </span><br><span class="line">        void* vaddr;</span><br><span class="line">        status_t res = backBuffer-&gt;lock(</span><br><span class="line">                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">                newDirtyRegion.bounds(), &amp;vaddr);     </span><br><span class="line">        </span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLockedBuffer = backBuffer;</span><br><span class="line">            outBuffer-&gt;width  = backBuffer-&gt;width;</span><br><span class="line">            outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">            outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">            outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">            outBuffer-&gt;bits   = vaddr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;</span><br><span class="line">    //申请buffer</span><br><span class="line">    status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, mSwapIntervalZero,</span><br><span class="line">            reqW, reqH, mReqFormat, mReqUsage);</span><br><span class="line"></span><br><span class="line">    //mSlots 在前面有提到，是 Layer 对象中定义的缓冲队列数组，这里获取队列中的第 buf 项</span><br><span class="line">    sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line"></span><br><span class="line">    if (result &amp; IGraphicBufferProducer::RELEASE_ALL_BUFFERS) &#123;</span><br><span class="line">        freeAllBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == 0) &#123;</span><br><span class="line">        // 因为内存是在 SurfaceFlinger 进程中申请的，这里将内存映射到当前 Surface 所在进程</span><br><span class="line">        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    //返回内存对象的指针</span><br><span class="line">    *buffer = gbuf.get();</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mGraphicBufferProducer-&gt;dequeueBuffer()</code> 进而会去调用 <code>BpGraphicBufferProducer::dequeueBuffer()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class BpGraphicBufferProducer : public BpInterface&lt;IGraphicBufferProducer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t dequeueBuffer(int *buf, sp&lt;Fence&gt;* fence, bool async,</span><br><span class="line">            uint32_t w, uint32_t h, uint32_t format, uint32_t usage) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(async);</span><br><span class="line">        data.writeInt32(w);</span><br><span class="line">        data.writeInt32(h);</span><br><span class="line">        data.writeInt32(format);</span><br><span class="line">        data.writeInt32(usage);</span><br><span class="line">        //这里通过 BpBinder 将相关参数进行序列化，并发送给 BBinder</span><br><span class="line">        status_t result = remote()-&gt;transact(DEQUEUE_BUFFER, data, &amp;reply);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;BpGraphicBufferProducer::dequeueBuffer binder transact failed, result: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取 BBinder 回复的int数据，这里指的是 mSlots 缓冲区数组的索引</span><br><span class="line">        *buf = reply.readInt32();</span><br><span class="line">        bool nonNull = reply.readInt32();</span><br><span class="line">        if (nonNull) &#123;</span><br><span class="line">            *fence = new Fence();</span><br><span class="line">            reply.read(**fence);</span><br><span class="line">        &#125;</span><br><span class="line">        result = reply.readInt32();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回归到 BnGraphicBufferProducer 实现，这里会调用 BufferQueue::dequeueBuffer() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">status_t BnGraphicBufferProducer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case DEQUEUE_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);</span><br><span class="line">            bool async      = data.readInt32();</span><br><span class="line">            uint32_t w      = data.readInt32();</span><br><span class="line">            uint32_t h      = data.readInt32();</span><br><span class="line">            uint32_t format = data.readInt32();</span><br><span class="line">            uint32_t usage  = data.readInt32();</span><br><span class="line">            int buf;</span><br><span class="line">            sp&lt;Fence&gt; fence;</span><br><span class="line">            int result = dequeueBuffer(&amp;buf, &amp;fence, async, w, h, format, usage);</span><br><span class="line">            reply-&gt;writeInt32(buf);</span><br><span class="line">            reply-&gt;writeInt32(fence != NULL);</span><br><span class="line">            if (fence != NULL) &#123;</span><br><span class="line">                reply-&gt;write(*fence);</span><br><span class="line">            &#125;</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先查找 mSlots 数组中 BufferSlot::FREE 状态的缓存区，如果没有找到继续等待消费者；设置找到的缓存区状态为 BufferSlot::DEQUEUED，并检查这个缓冲区的 mGraphicBuffer 内存是否满足使用条件，如果不满足则设置 BUFFER_NEEDS_REALLOCATION 标志，调用 <code>mGraphicBufferAlloc-&gt;createGraphicBuffer()</code> 重新申请内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">status_t BufferQueue::dequeueBuffer(int *outBuf, sp&lt;Fence&gt;* outFence, bool async,</span><br><span class="line">        uint32_t w, uint32_t h, uint32_t format, uint32_t usage) &#123;</span><br><span class="line"></span><br><span class="line">    bool tryAgain = true;</span><br><span class="line">    while (tryAgain) &#123;</span><br><span class="line">        // look for a free buffer to give to the client</span><br><span class="line">        found = INVALID_BUFFER_SLOT;</span><br><span class="line">        int dequeuedCount = 0;</span><br><span class="line">        int acquiredCount = 0;</span><br><span class="line">        for (int i = 0; i &lt; maxBufferCount; i++) &#123;</span><br><span class="line">            const int state = mSlots[i].mBufferState;</span><br><span class="line">            switch (state) &#123;</span><br><span class="line">                case BufferSlot::DEQUEUED:</span><br><span class="line">                    dequeuedCount++;    //统计dequeued buffer数量</span><br><span class="line">                    break;</span><br><span class="line">                case BufferSlot::ACQUIRED:</span><br><span class="line">                    acquiredCount++;</span><br><span class="line">                    break;</span><br><span class="line">                case BufferSlot::FREE:</span><br><span class="line">                    /* We return the oldest of the free buffers to avoid</span><br><span class="line">                    * stalling the producer if possible.  This is because</span><br><span class="line">                    * the consumer may still have pending reads of the</span><br><span class="line">                    * buffers in flight.</span><br><span class="line">                    */</span><br><span class="line">                    if ((found &lt; 0) ||</span><br><span class="line">                            mSlots[i].mFrameNumber &lt; mSlots[found].mFrameNumber) &#123;</span><br><span class="line">                        found = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        // See whether a buffer has been queued since the last</span><br><span class="line">        // setBufferCount so we know whether to perform the min undequeued</span><br><span class="line">        // buffers check below.</span><br><span class="line">        if (mBufferHasBeenQueued) &#123;</span><br><span class="line">            // make sure the client is not trying to dequeue more buffers</span><br><span class="line">            // than allowed.</span><br><span class="line">            const int newUndequeuedCount = maxBufferCount - (dequeuedCount+1);</span><br><span class="line">            const int minUndequeuedCount = getMinUndequeuedBufferCount(async);</span><br><span class="line">            if (newUndequeuedCount &lt; minUndequeuedCount) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: min undequeued buffer count (%d) &quot;</span><br><span class="line">                        &quot;exceeded (dequeued=%d undequeudCount=%d)&quot;,</span><br><span class="line">                        minUndequeuedCount, dequeuedCount,</span><br><span class="line">                        newUndequeuedCount);</span><br><span class="line">                return -EBUSY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If no buffer is found, wait for a buffer to be released or for</span><br><span class="line">        // the max buffer count to change.</span><br><span class="line">        tryAgain = found == INVALID_BUFFER_SLOT;</span><br><span class="line">        if (tryAgain) &#123;</span><br><span class="line">            // return an error if we&apos;re in &quot;cannot block&quot; mode (producer and consumer</span><br><span class="line">            // are controlled by the application) -- however, the consumer is allowed</span><br><span class="line">            // to acquire briefly an extra buffer (which could cause us to have to wait here)</span><br><span class="line">            // and that&apos;s okay because we know the wait will be brief (it happens</span><br><span class="line">            // if we dequeue a buffer while the consumer has acquired one but not released</span><br><span class="line">            // the old one yet -- for e.g.: see GLConsumer::updateTexImage()).</span><br><span class="line">            if (mDequeueBufferCannotBlock &amp;&amp; (acquiredCount &lt;= mMaxAcquiredBufferCount)) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: would block! returning an error instead.&quot;);</span><br><span class="line">                return WOULD_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            mDequeueCondition.wait(mMutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const int buf = found;</span><br><span class="line">    *outBuf = found;</span><br><span class="line">    mSlots[buf].mBufferState = BufferSlot::DEQUEUED;</span><br><span class="line"></span><br><span class="line">    //对找到的Slot进行初始化操作</span><br><span class="line">    const sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[buf].mGraphicBuffer);</span><br><span class="line">    if ((buffer == NULL) ||</span><br><span class="line">        (uint32_t(buffer-&gt;width)  != w) ||</span><br><span class="line">        (uint32_t(buffer-&gt;height) != h) ||</span><br><span class="line">        (uint32_t(buffer-&gt;format) != format) ||</span><br><span class="line">        ((uint32_t(buffer-&gt;usage) &amp; usage) != usage))</span><br><span class="line">    &#123;</span><br><span class="line">        mSlots[buf].mAcquireCalled = false;</span><br><span class="line">        mSlots[buf].mGraphicBuffer = NULL;</span><br><span class="line">        mSlots[buf].mRequestBufferCalled = false;</span><br><span class="line">        mSlots[buf].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">        mSlots[buf].mFence = Fence::NO_FENCE;</span><br><span class="line">        mSlots[buf].mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line"></span><br><span class="line">        returnFlags |= IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (returnFlags &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">        status_t error;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer(</span><br><span class="line">                mGraphicBufferAlloc-&gt;createGraphicBuffer(w, h, format, usage, &amp;error));</span><br><span class="line">        if (graphicBuffer == 0) &#123;</span><br><span class="line">            ST_LOGE(&quot;dequeueBuffer: SurfaceComposer::createGraphicBuffer failed&quot;);</span><br><span class="line">            return error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123; // Scope for the lock</span><br><span class="line">            Mutex::Autolock lock(mMutex);</span><br><span class="line"></span><br><span class="line">            if (mAbandoned) &#123;</span><br><span class="line">                ST_LOGE(&quot;dequeueBuffer: BufferQueue has been abandoned!&quot;);</span><br><span class="line">                return NO_INIT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSlots[*outBuf].mFrameNumber = ~0;</span><br><span class="line">            mSlots[*outBuf].mGraphicBuffer = graphicBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BpGraphicBufferAlloc::createGraphicBuffer()</code> 通过 Binder 机制调用 <code>BnGraphicBufferAlloc::onTransact()</code> ，进而调用 <code>GraphicBufferAlloc::createGraphicBuffer()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/IGraphicBufferAlloc.cpp</span><br><span class="line"></span><br><span class="line">class BpGraphicBufferAlloc : public BpInterface&lt;IGraphicBufferAlloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BpGraphicBufferAlloc(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IGraphicBufferAlloc&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;GraphicBuffer&gt; createGraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">            PixelFormat format, uint32_t usage, status_t* error) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferAlloc::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(w);</span><br><span class="line">        data.writeInt32(h);</span><br><span class="line">        data.writeInt32(format);</span><br><span class="line">        data.writeInt32(usage);</span><br><span class="line">        remote()-&gt;transact(CREATE_GRAPHIC_BUFFER, data, &amp;reply);</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer;</span><br><span class="line">        status_t result = reply.readInt32();</span><br><span class="line">        if (result == NO_ERROR) &#123;</span><br><span class="line">            graphicBuffer = new GraphicBuffer();</span><br><span class="line">            result = reply.read(*graphicBuffer);</span><br><span class="line">            // reply.readStrongBinder();</span><br><span class="line">            // here we don&apos;t even have to read the BufferReference from</span><br><span class="line">            // the parcel, it&apos;ll die with the parcel.</span><br><span class="line">        &#125;</span><br><span class="line">        *error = result;</span><br><span class="line">        return graphicBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">status_t BnGraphicBufferAlloc::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // codes that don&apos;t require permission check</span><br><span class="line"></span><br><span class="line">    /* BufferReference just keeps a strong reference to a</span><br><span class="line">     * GraphicBuffer until it is destroyed (that is, until</span><br><span class="line">     * no local or remote process have a reference to it).</span><br><span class="line">     */</span><br><span class="line">    class BufferReference : public BBinder &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">    public:</span><br><span class="line">        BufferReference(const sp&lt;GraphicBuffer&gt;&amp; buffer) : buffer(buffer) &#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case CREATE_GRAPHIC_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);</span><br><span class="line">            uint32_t w = data.readInt32();</span><br><span class="line">            uint32_t h = data.readInt32();</span><br><span class="line">            PixelFormat format = data.readInt32();</span><br><span class="line">            uint32_t usage = data.readInt32();</span><br><span class="line">            status_t error;</span><br><span class="line">            sp&lt;GraphicBuffer&gt; result =</span><br><span class="line">                    createGraphicBuffer(w, h, format, usage, &amp;error);</span><br><span class="line">            reply-&gt;writeInt32(error);</span><br><span class="line">            if (result != 0) &#123;</span><br><span class="line">                reply-&gt;write(*result);</span><br><span class="line">                // We add a BufferReference to this parcel to make sure the</span><br><span class="line">                // buffer stays alive until the GraphicBuffer object on</span><br><span class="line">                // the other side has been created.</span><br><span class="line">                // This is needed so that the buffer handle can be</span><br><span class="line">                // registered before the buffer is destroyed on implementations</span><br><span class="line">                // that do not use file-descriptors to track their buffers.</span><br><span class="line">                reply-&gt;writeStrongBinder( new BufferReference(result) );</span><br><span class="line">            &#125;</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">        default:</span><br><span class="line">            return BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据传递的宽度、高度、格式等信息来构造 GraphicBuffer 对象，GraphicBuffer 类的构造函数会调用 initSize() 分配图形缓冲区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/GraphicBufferAlloc.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">        PixelFormat format, uint32_t usage, status_t* error) &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; graphicBuffer(new GraphicBuffer(w, h, format, usage));</span><br><span class="line">    status_t err = graphicBuffer-&gt;initCheck();</span><br><span class="line">    *error = err;</span><br><span class="line">    if (err != 0 || graphicBuffer-&gt;handle == 0) &#123;</span><br><span class="line">        if (err == NO_MEMORY) &#123;</span><br><span class="line">            GraphicBuffer::dumpAllocationsToSystemLog();</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGE(&quot;GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) &quot;</span><br><span class="line">            &quot;failed (%s), handle=%p&quot;,</span><br><span class="line">                w, h, strerror(-err), graphicBuffer-&gt;handle);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return graphicBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,</span><br><span class="line">        PixelFormat reqFormat, uint32_t reqUsage)</span><br><span class="line">    : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">    mInitCheck(NO_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">    width  =</span><br><span class="line">    height =</span><br><span class="line">    stride =</span><br><span class="line">    format =</span><br><span class="line">    usage  = 0;</span><br><span class="line">    handle = NULL;</span><br><span class="line">    mInitCheck = initSize(w, h, reqFormat, reqUsage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,</span><br><span class="line">        uint32_t reqUsage)</span><br><span class="line">&#123;</span><br><span class="line">    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();</span><br><span class="line">    status_t err = allocator.alloc(w, h, format, reqUsage, &amp;handle, &amp;stride);</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        this-&gt;width  = w;</span><br><span class="line">        this-&gt;height = h;</span><br><span class="line">        this-&gt;format = format;</span><br><span class="line">        this-&gt;usage  = reqUsage;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GraphicBufferAllocator 是作为分配图形缓冲区的工具类，这里使用单例模式获取 GraphicBufferAllocator 对象，加载 Gralloc HAL ，最终调用 gralloc_alloc 实现图形缓冲区的分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/include/ui/GraphicBufferAllocator.h</span><br><span class="line"></span><br><span class="line">class GraphicBufferAllocator : public Singleton&lt;GraphicBufferAllocator&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static inline GraphicBufferAllocator&amp; get() &#123; return getInstance(); &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBufferAllocator.cpp</span><br><span class="line"></span><br><span class="line">GraphicBufferAllocator::GraphicBufferAllocator()</span><br><span class="line">    : mAllocDev(0)</span><br><span class="line">&#123;</span><br><span class="line">    hw_module_t const* module;</span><br><span class="line">    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module);</span><br><span class="line">    ALOGE_IF(err, &quot;FATAL: can&apos;t find the %s module&quot;, GRALLOC_HARDWARE_MODULE_ID);</span><br><span class="line">    if (err == 0) &#123;</span><br><span class="line">        gralloc_open(module, &amp;mAllocDev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在为止 BufferQueue 中已经申请到了内存，返回给 Surface 一个的数组下标，但这时候 Surface 还没有获取到任何图形缓冲区相关的东西。由于申请的内存是在 SurfaceFlinger 所在的进程，接下来调用 <code>mGraphicBufferProducer-&gt;requestBuffer()</code> 将 buffer 映射到 Surface 所在的进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">status_t BufferQueue::requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ST_LOGV(&quot;requestBuffer: slot=%d&quot;, slot);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    if (mAbandoned) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: BufferQueue has been abandoned!&quot;);</span><br><span class="line">        return NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (slot &lt; 0 || slot &gt;= NUM_BUFFER_SLOTS) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: slot index out of range [0, %d]: %d&quot;,</span><br><span class="line">                NUM_BUFFER_SLOTS, slot);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125; else if (mSlots[slot].mBufferState != BufferSlot::DEQUEUED) &#123;</span><br><span class="line">        ST_LOGE(&quot;requestBuffer: slot %d is not owned by the client (state=%d)&quot;,</span><br><span class="line">                slot, mSlots[slot].mBufferState);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    mSlots[slot].mRequestBufferCalled = true;</span><br><span class="line">    *buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 requestBuffer() 方法返回后，调用 <code>reply-&gt;write(*buffer)</code> ，这里经过数据打包处理然后发送到应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/binder/Parcel.cpp</span><br><span class="line"></span><br><span class="line">status_t Parcel::write(const FlattenableHelperInterface&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    // size if needed</span><br><span class="line">    const size_t len = val.getFlattenedSize();</span><br><span class="line">    const size_t fd_count = val.getFdCount();</span><br><span class="line"></span><br><span class="line">    err = this-&gt;writeInt32(len);</span><br><span class="line">    if (err) return err;</span><br><span class="line"></span><br><span class="line">    err = this-&gt;writeInt32(fd_count);</span><br><span class="line">    if (err) return err;</span><br><span class="line"></span><br><span class="line">    // payload</span><br><span class="line">    void* const buf = this-&gt;writeInplace(PAD_SIZE(len));</span><br><span class="line">    if (buf == NULL)</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line"></span><br><span class="line">    int* fds = NULL;</span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        fds = new int[fd_count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数据的打包处理</span><br><span class="line">    err = val.flatten(buf, len, fds, fd_count);</span><br><span class="line">    for (size_t i=0 ; i&lt;fd_count &amp;&amp; err==NO_ERROR ; i++) &#123;</span><br><span class="line">        err = this-&gt;writeDupFileDescriptor( fds[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        delete [] fds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::flatten(void*&amp; buffer, size_t&amp; size, int*&amp; fds, size_t&amp; count) const &#123;</span><br><span class="line">    size_t sizeNeeded = GraphicBuffer::getFlattenedSize();</span><br><span class="line">    if (size &lt; sizeNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    size_t fdCountNeeded = GraphicBuffer::getFdCount();</span><br><span class="line">    if (count &lt; fdCountNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    int* buf = static_cast&lt;int*&gt;(buffer);</span><br><span class="line">    buf[0] = &apos;GBFR&apos;;</span><br><span class="line">    buf[1] = width;</span><br><span class="line">    buf[2] = height;</span><br><span class="line">    buf[3] = stride;</span><br><span class="line">    buf[4] = format;</span><br><span class="line">    buf[5] = usage;</span><br><span class="line">    buf[6] = 0;</span><br><span class="line">    buf[7] = 0;</span><br><span class="line"></span><br><span class="line">    if (handle) &#123;</span><br><span class="line">        buf[6] = handle-&gt;numFds;</span><br><span class="line">        buf[7] = handle-&gt;numInts;</span><br><span class="line">        native_handle_t const* const h = handle;</span><br><span class="line">        memcpy(fds,     h-&gt;data,             h-&gt;numFds*sizeof(int));</span><br><span class="line">        memcpy(&amp;buf[8], h-&gt;data + h-&gt;numFds, h-&gt;numInts*sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = reinterpret_cast&lt;void*&gt;(static_cast&lt;int*&gt;(buffer) + sizeNeeded);</span><br><span class="line">    size -= sizeNeeded;</span><br><span class="line">    fds += handle-&gt;numFds;</span><br><span class="line">    count -= handle-&gt;numFds;</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用程序端使用 <code>reply.read(*graphicBuffer)</code> 把数据读取出来，这里使用 Parcel::read() 方法，进而调用 GraphicBufer::unflatten() 方法，这里使用 fd 构造 native_handle 对象，然后调用 <code>GraphicBufferMapper::registerBuffer()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/binder/Parcel.cpp</span><br><span class="line"></span><br><span class="line">status_t Parcel::read(FlattenableHelperInterface&amp; val) const</span><br><span class="line">&#123;</span><br><span class="line">    // size</span><br><span class="line">    const size_t len = this-&gt;readInt32();</span><br><span class="line">    const size_t fd_count = this-&gt;readInt32();</span><br><span class="line"></span><br><span class="line">    // payload</span><br><span class="line">    void const* const buf = this-&gt;readInplace(PAD_SIZE(len));</span><br><span class="line">    if (buf == NULL)</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line"></span><br><span class="line">    int* fds = NULL;</span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        fds = new int[fd_count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = NO_ERROR;</span><br><span class="line">    for (size_t i=0 ; i&lt;fd_count &amp;&amp; err==NO_ERROR ; i++) &#123;</span><br><span class="line">        fds[i] = dup(this-&gt;readFileDescriptor());</span><br><span class="line">        if (fds[i] &lt; 0) err = BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        err = val.unflatten(buf, len, fds, fd_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fd_count) &#123;</span><br><span class="line">        delete [] fds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBuffer::unflatten(</span><br><span class="line">        void const*&amp; buffer, size_t&amp; size, int const*&amp; fds, size_t&amp; count) &#123;</span><br><span class="line">    if (size &lt; 8*sizeof(int)) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    int const* buf = static_cast&lt;int const*&gt;(buffer);</span><br><span class="line">    if (buf[0] != &apos;GBFR&apos;) return BAD_TYPE;</span><br><span class="line"></span><br><span class="line">    const size_t numFds  = buf[6];</span><br><span class="line">    const size_t numInts = buf[7];</span><br><span class="line"></span><br><span class="line">    const size_t sizeNeeded = (8 + numInts) * sizeof(int);</span><br><span class="line">    if (size &lt; sizeNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    size_t fdCountNeeded = 0;</span><br><span class="line">    if (count &lt; fdCountNeeded) return NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    if (handle) &#123;</span><br><span class="line">        // free previous handle if any</span><br><span class="line">        free_handle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (numFds || numInts) &#123;</span><br><span class="line">        width  = buf[1];</span><br><span class="line">        height = buf[2];</span><br><span class="line">        stride = buf[3];</span><br><span class="line">        format = buf[4];</span><br><span class="line">        usage  = buf[5];</span><br><span class="line">        native_handle* h = native_handle_create(numFds, numInts);</span><br><span class="line">        memcpy(h-&gt;data,          fds,     numFds*sizeof(int));</span><br><span class="line">        memcpy(h-&gt;data + numFds, &amp;buf[8], numInts*sizeof(int));</span><br><span class="line">        handle = h;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        width = height = stride = format = usage = 0;</span><br><span class="line">        handle = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOwner = ownHandle;</span><br><span class="line"></span><br><span class="line">    if (handle != 0) &#123;</span><br><span class="line">        status_t err = mBufferMapper.registerBuffer(handle);</span><br><span class="line">        if (err != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;unflatten: registerBuffer failed: %s (%d)&quot;,</span><br><span class="line">                    strerror(-err), err);</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际会调用 Gralloc 模块的 registerBuffer() 方法，这里会把申请的 buffer 进行 mmap 映射，然后将 vaddr 数据保存在 handle-&gt;base 中。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/ui/GraphicBufferMapper.cpp</span><br><span class="line"></span><br><span class="line">status_t GraphicBufferMapper::registerBuffer(buffer_handle_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    err = mAllocMod-&gt;registerBuffer(mAllocMod, handle);</span><br><span class="line"></span><br><span class="line">    ALOGW_IF(err, &quot;registerBuffer(%p) failed %d (%s)&quot;,</span><br><span class="line">            handle, err, strerror(-err));</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dequeueBuffer() 完成之后会调用 backBuffer-&gt;lock()，实际上调用的是 gralloc_lock()，直接返回 handle-&gt;base()。</p>
<p>总结：真正的申请图形缓冲区是在 SurfaceFlinger 进程中，因为 GraphicBufferAlloc 对象是在 SurfaceFlinger 中构造出来的，然后 BufferQueue 和 Surface 中的图形缓冲区都是通过 GraphicBuffer 的序列化和反序列化新映射出来的。</p>
<h2 id="Surface-unlockAsndPost"><a href="#Surface-unlockAsndPost" class="headerlink" title="Surface::unlockAsndPost()"></a>Surface::unlockAsndPost()</h2><p>应用绘制完成后，将数据更新入 BufferQueue ，通知 Layer 更新，Layer 从 BufferQueue 中取出数据，通知SurfaceFlinger 进行合成处理。</p>
<p><code>Surface::unlockAndPost()</code> 调用 <code>Surface::queueBuffer()</code> 方法，而 <code>mGraphicBufferProducer-&gt;queueBuffer()</code> 方法实际上会调用的是本地对象的 BnGraphicBufferProducer::queueBuffer() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/Surface.cpp</span><br><span class="line"></span><br><span class="line">status_t Surface::unlockAndPost()</span><br><span class="line">&#123;</span><br><span class="line">    if (mLockedBuffer == 0) &#123;</span><br><span class="line">        ALOGE(&quot;Surface::unlockAndPost failed, no locked buffer&quot;);</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t err = mLockedBuffer-&gt;unlock();</span><br><span class="line">    ALOGE_IF(err, &quot;failed unlocking buffer (%p)&quot;, mLockedBuffer-&gt;handle);</span><br><span class="line"></span><br><span class="line">    err = queueBuffer(mLockedBuffer.get(), -1);</span><br><span class="line">    ALOGE_IF(err, &quot;queueBuffer (handle=%p) failed (%s)&quot;,</span><br><span class="line">            mLockedBuffer-&gt;handle, strerror(-err));</span><br><span class="line"></span><br><span class="line">    mPostedBuffer = mLockedBuffer;</span><br><span class="line">    mLockedBuffer = 0;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(&quot;Surface::queueBuffer&quot;);</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    int64_t timestamp;</span><br><span class="line">    bool isAutoTimestamp = false;</span><br><span class="line">    if (mTimestamp == NATIVE_WINDOW_TIMESTAMP_AUTO) &#123;</span><br><span class="line">        timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        isAutoTimestamp = true;</span><br><span class="line">        ALOGV(&quot;Surface::queueBuffer making up timestamp: %.2f ms&quot;,</span><br><span class="line">            timestamp / 1000000.f);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        timestamp = mTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = getSlotFromBufferLocked(buffer);</span><br><span class="line">    if (i &lt; 0) &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure the crop rectangle is entirely inside the buffer.</span><br><span class="line">    Rect crop;</span><br><span class="line">    mCrop.intersect(Rect(buffer-&gt;width, buffer-&gt;height), &amp;crop);</span><br><span class="line"></span><br><span class="line">    sp&lt;Fence&gt; fence(fenceFd &gt;= 0 ? new Fence(fenceFd) : Fence::NO_FENCE);</span><br><span class="line">    IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">    IGraphicBufferProducer::QueueBufferInput input(timestamp, isAutoTimestamp,</span><br><span class="line">            crop, mScalingMode, mTransform, mSwapIntervalZero, fence);</span><br><span class="line">    status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">    if (err != OK)  &#123;</span><br><span class="line">        ALOGE(&quot;queueBuffer: error queuing buffer to SurfaceTexture, %d&quot;, err);</span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t numPendingBuffers = 0;</span><br><span class="line">    output.deflate(&amp;mDefaultWidth, &amp;mDefaultHeight, &amp;mTransformHint,</span><br><span class="line">            &amp;numPendingBuffers);</span><br><span class="line"></span><br><span class="line">    mConsumerRunningBehind = (numPendingBuffers &gt;= 2);</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mGraphicBufferProducer-&gt;queueBuffer()</code> 会调用  <code>remote()-&gt;transact()</code>，进而调用 <code>BufferQueue::queueBuffer()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/libs/gui/IGraphicBufferProducer.cpp</span><br><span class="line"></span><br><span class="line">class BpGraphicBufferProducer : public BpInterface&lt;IGraphicBufferProducer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t queueBuffer(int buf,</span><br><span class="line">            const QueueBufferInput&amp; input, QueueBufferOutput* output) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());</span><br><span class="line">        data.writeInt32(buf);</span><br><span class="line">        data.write(input);</span><br><span class="line">        status_t result = remote()-&gt;transact(QUEUE_BUFFER, data, &amp;reply);</span><br><span class="line">        if (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(&quot;BpGraphicBufferProducer::queueBuffer binder transact failed, result: %d&quot;, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        memcpy(output, reply.readInplace(sizeof(*output)), sizeof(*output));</span><br><span class="line">        result = reply.readInt32();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BnGraphicBufferProducer::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        case QUEUE_BUFFER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);</span><br><span class="line">            int buf = data.readInt32(); //读取Slot序号</span><br><span class="line">            QueueBufferInput input(data);</span><br><span class="line">            QueueBufferOutput* const output =</span><br><span class="line">                    reinterpret_cast&lt;QueueBufferOutput *&gt;(</span><br><span class="line">                            reply-&gt;writeInplace(sizeof(QueueBufferOutput)));</span><br><span class="line">            status_t result = queueBuffer(buf, input, output);</span><br><span class="line">            reply-&gt;writeInt32(result);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>queueBuffer 调用 <code>listener-&gt;onFrameAvailable()</code> ，父类的构造函数 ConsumerBase 会调用 Layer 的 onFrameAvailable() ，最后调用 signalLayerUpdate() 通知 SurfaceFlinger 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">status_t BufferQueue::queueBuffer(int buf,</span><br><span class="line">        const QueueBufferInput&amp; input, QueueBufferOutput* output) &#123;</span><br><span class="line"></span><br><span class="line">    sp&lt;IConsumerListener&gt; listener;</span><br><span class="line"></span><br><span class="line">    const sp&lt;GraphicBuffer&gt;&amp; graphicBuffer(mSlots[buf].mGraphicBuffer);</span><br><span class="line"></span><br><span class="line">    mSlots[buf].mFence = fence;</span><br><span class="line">    mSlots[buf].mBufferState = BufferSlot::QUEUED;</span><br><span class="line">    mFrameCounter++;</span><br><span class="line">    mSlots[buf].mFrameNumber = mFrameCounter;</span><br><span class="line"></span><br><span class="line">    BufferItem item;</span><br><span class="line">    item.mAcquireCalled = mSlots[buf].mAcquireCalled;</span><br><span class="line">    item.mGraphicBuffer = mSlots[buf].mGraphicBuffer;</span><br><span class="line">    item.mCrop = crop;</span><br><span class="line">    item.mTransform = transform &amp; ~NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY;</span><br><span class="line">    item.mTransformToDisplayInverse = bool(transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);</span><br><span class="line">    item.mScalingMode = scalingMode;</span><br><span class="line">    item.mTimestamp = timestamp;</span><br><span class="line">    item.mIsAutoTimestamp = isAutoTimestamp;</span><br><span class="line">    item.mFrameNumber = mFrameCounter;</span><br><span class="line">    item.mBuf = buf;</span><br><span class="line">    item.mFence = fence;</span><br><span class="line">    item.mIsDroppable = mDequeueBufferCannotBlock || async;</span><br><span class="line"></span><br><span class="line">    mQueue.push_back(item);</span><br><span class="line">    listener = mConsumerListener;</span><br><span class="line"></span><br><span class="line">    mDequeueCondition.broadcast();</span><br><span class="line">    output-&gt;inflate(mDefaultWidth, mDefaultHeight, mTransformHint,</span><br><span class="line">        mQueue.size());</span><br><span class="line"></span><br><span class="line">    listener-&gt;onFrameAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 listener 保存了前面已经分配的 Layer 对象，而 Layer 的成员变量 mFlinger 保存了 SurfaceFlinger 对象，所以调用 signalLayerUpdate() 方法会唤醒其他线程，这部分后面再继续分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@ frameworks/native/libs/gui/BufferQueue.cpp</span><br><span class="line"></span><br><span class="line">void BufferQueue::ProxyConsumerListener::onFrameAvailable() &#123;</span><br><span class="line">    sp&lt;ConsumerListener&gt; listener(mConsumerListener.promote());</span><br><span class="line">    if (listener != NULL) &#123;</span><br><span class="line">        listener-&gt;onFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/Layer.cpp</span><br><span class="line"></span><br><span class="line">void Layer::onFrameAvailable() &#123;</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">    mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/GUI/" rel="tag"># GUI</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/11/09/sc7731-lcd流程分析/" rel="prev" title="sc7731 lcd流程分析">
      <i class="fa fa-chevron-left"></i> sc7731 lcd流程分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/14/sc770x-稳定性问题分析/" rel="next" title="sc770x-稳定性问题分析">
      sc770x-稳定性问题分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SurfaceFlinger内部机制"><span class="nav-number">1.</span> <span class="nav-text">SurfaceFlinger内部机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SurfaceComposerClient"><span class="nav-number">1.1.</span> <span class="nav-text">SurfaceComposerClient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SurfaceControl"><span class="nav-number">1.2.</span> <span class="nav-text">SurfaceControl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface"><span class="nav-number">1.3.</span> <span class="nav-text">Surface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface-lock"><span class="nav-number">1.4.</span> <span class="nav-text">Surface::lock()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface-unlockAsndPost"><span class="nav-number">1.5.</span> <span class="nav-text">Surface::unlockAsndPost()</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tinylaker</p>
  <div class="site-description" itemprop="description">个人学习总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tinylaker" title="GitHub → https://github.com/tinylaker" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/xyxujinlong@163.com" title="E-Mail → xyxujinlong@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tinylaker</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">133k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'http://tinylaker.github.io/2019/11/11/Android-GUI框架简介/',]
      });
      });
  </script>

</body>
</html>
